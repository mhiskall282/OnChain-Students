import {
  getInjectedMagicEdenProvider
} from "./chunk-3SKRXWUN.js";
import {
  getInjectedPhantomProvider
} from "./chunk-BGCQ64CW.js";
import {
  getInjectedRainbowProvider
} from "./chunk-SQHU4NWU.js";
import {
  require_brorand,
  require_hmac_drbg,
  require_utils as require_utils2
} from "./chunk-HGG7E5XN.js";
import {
  AbstractWallet,
  ERC6551_REGISTRY,
  checkContractWalletSignature,
  getAnalyticsHeaders,
  isZkSyncChain,
  require_dist
} from "./chunk-5Z4FKP2W.js";
import {
  getInjectedXDEFIProvider
} from "./chunk-GGII2DOJ.js";
import {
  getInjectedCoreWalletProvider
} from "./chunk-GQWRI7QN.js";
import {
  getInjectedOneKeyProvider
} from "./chunk-TFMZQD2J.js";
import {
  getInjectedCryptoDefiWalletProvider
} from "./chunk-7ZTRRMDX.js";
import {
  getInjectedRabbyProvider
} from "./chunk-M5HHJ5TL.js";
import {
  getInjectedCoin98Provider
} from "./chunk-H7BIURJ6.js";
import {
  WagmiAdapter
} from "./chunk-DJXLT4TK.js";
import {
  getInjectedMetamaskProvider
} from "./chunk-R3IZTCGT.js";
import {
  A,
  C,
  E,
  IEvents,
  Po,
  Qe,
  Qo,
  clear,
  createStore,
  del,
  destr,
  detect,
  esm_exports2 as esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  get,
  getBigIntRpcId,
  import_pino,
  init_esm,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isLocalhostUrl,
  isWsUrl,
  k,
  keys,
  parseConnectionError,
  payloadId,
  r,
  require_binary,
  require_browser,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_hkdf,
  require_lodash,
  require_query_string,
  require_random,
  require_sha256,
  require_wipe,
  require_x25519,
  safeJsonParse,
  safeJsonStringify,
  set,
  sn,
  y
} from "./chunk-MOOHJFQZ.js";
import {
  getInjectedOKXProvider
} from "./chunk-SRRH4CRM.js";
import {
  assertWindowEthereum
} from "./chunk-RKAC5DGX.js";
import {
  walletIds
} from "./chunk-KOCNAQFC.js";
import {
  _defineProperty
} from "./chunk-EKYLSAGW.js";
import {
  require_events
} from "./chunk-XAZ6AATU.js";
import {
  aesDecryptCompat,
  aesEncrypt,
  getChainProvider
} from "./chunk-QRVYLIJU.js";
import {
  require_utils
} from "./chunk-OWWVVKBF.js";
import {
  concat,
  fromString,
  init_concat,
  init_from_string,
  init_to_string,
  toString
} from "./chunk-YEGKQXMC.js";
import {
  c1,
  defaultChains,
  getValidChainRPCs,
  updateChainRPCs
} from "./chunk-Q3CBO36D.js";
import {
  eventemitter3_default
} from "./chunk-7W5ELUZF.js";
import {
  require_buffer as require_buffer2
} from "./chunk-FSHJLBLG.js";
import {
  Wallet,
  ethers_exports,
  init_lib7 as init_lib3,
  utils_exports
} from "./chunk-3QWSQV3V.js";
import {
  BigNumber,
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  recoverAddress,
  require_hash,
  require_minimalistic_assert
} from "./chunk-KZDFRIUS.js";
import {
  require_buffer,
  require_inherits_browser
} from "./chunk-KJTNN5VX.js";
import {
  __commonJS,
  __toESM
} from "./chunk-MVEJMUOB.js";

// node_modules/@walletconnect/utils/node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.6.1",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j6, w5;
        var off = 0;
        if (endian === "be") {
          for (i3 = number.length - 1, j6 = 0; i3 >= 0; i3 -= 3) {
            w5 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
            this.words[j6] |= w5 << off & 67108863;
            this.words[j6 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j6 = 0; i3 < number.length; i3 += 3) {
            w5 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
            this.words[j6] |= w5 << off & 67108863;
            this.words[j6 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c7 = string.charCodeAt(index);
        if (c7 >= 65 && c7 <= 70) {
          return c7 - 55;
        } else if (c7 >= 97 && c7 <= 102) {
          return c7 - 87;
        } else {
          return c7 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r3 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r3;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var off = 0;
        var j6 = 0;
        var w5;
        if (endian === "be") {
          for (i3 = number.length - 1; i3 >= start; i3 -= 2) {
            w5 = parseHexByte(number, start, i3) << off;
            this.words[j6] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j6 += 1;
              this.words[j6] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i3 = parseLength % 2 === 0 ? start + 1 : start; i3 < number.length; i3 += 2) {
            w5 = parseHexByte(number, start, i3) << off;
            this.words[j6] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j6 += 1;
              this.words[j6] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c7 = str.charCodeAt(i3) - 48;
          r3 *= mul;
          if (c7 >= 49) {
            r3 += c7 - 49 + 10;
          } else if (c7 >= 17) {
            r3 += c7 - 17 + 10;
          } else {
            r3 += c7;
          }
        }
        return r3;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i3 = start; i3 < end; i3 += limbLen) {
          word = parseBase(number, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i3, number.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r3 = new BN(null);
        this.copy(r3);
        return r3;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w5 = this.words[i3];
            var word = ((w5 << off | carry) & 16777215).toString(16);
            carry = w5 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c7 = this.clone();
          c7.negative = 0;
          while (!c7.isZero()) {
            var r3 = c7.modn(groupBase).toString(base);
            c7 = c7.idivn(groupBase);
            if (!c7.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b7, i3;
        var q6 = this.clone();
        if (!littleEndian) {
          for (i3 = 0; i3 < reqLength - byteLength; i3++) {
            res[i3] = 0;
          }
          for (i3 = 0; !q6.isZero(); i3++) {
            b7 = q6.andln(255);
            q6.iushrn(8);
            res[reqLength - i3 - 1] = b7;
          }
        } else {
          for (i3 = 0; !q6.isZero(); i3++) {
            b7 = q6.andln(255);
            q6.iushrn(8);
            res[i3] = b7;
          }
          for (; i3 < reqLength; i3++) {
            res[i3] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w5) {
          return 32 - Math.clz32(w5);
        };
      } else {
        BN.prototype._countBits = function _countBits(w5) {
          var t = w5;
          var r3 = 0;
          if (t >= 4096) {
            r3 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r3 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r3 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r3 += 2;
            t >>>= 2;
          }
          return r3 + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w5) {
        if (w5 === 0) return 26;
        var t = w5;
        var r3 = 0;
        if ((t & 8191) === 0) {
          r3 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r3 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r3 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r3 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN.prototype.bitLength = function bitLength() {
        var w5 = this.words[this.length - 1];
        var hi4 = this._countBits(w5);
        return (this.length - 1) * 26 + hi4;
      };
      function toBitArray(num) {
        var w5 = new Array(num.bitLength());
        for (var bit = 0; bit < w5.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w5[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w5;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r3 = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b7 = this._zeroBits(this.words[i3]);
          r3 += b7;
          if (b7 !== 26) break;
        }
        return r3;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or5(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b7;
        if (this.length > num.length) {
          b7 = num;
        } else {
          b7 = this;
        }
        for (var i3 = 0; i3 < b7.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b7.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a5;
        var b7;
        if (this.length > num.length) {
          a5 = this;
          b7 = num;
        } else {
          a5 = num;
          b7 = this;
        }
        for (var i3 = 0; i3 < b7.length; i3++) {
          this.words[i3] = a5.words[i3] ^ b7.words[i3];
        }
        if (this !== a5) {
          for (; i3 < a5.length; i3++) {
            this.words[i3] = a5.words[i3];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a5, b7;
        if (this.length > num.length) {
          a5 = this;
          b7 = num;
        } else {
          a5 = num;
          b7 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b7.length; i3++) {
          r3 = (a5.words[i3] | 0) + (b7.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i3 < a5.length; i3++) {
          r3 = (a5.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i3 < a5.length; i3++) {
            this.words[i3] = a5.words[i3];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b7;
        if (cmp > 0) {
          a5 = this;
          b7 = num;
        } else {
          a5 = num;
          b7 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b7.length; i3++) {
          r3 = (a5.words[i3] | 0) - (b7.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        for (; carry !== 0 && i3 < a5.length; i3++) {
          r3 = (a5.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        if (carry === 0 && i3 < a5.length && a5 !== this) {
          for (; i3 < a5.length; i3++) {
            this.words[i3] = a5.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b7 = num.words[0] | 0;
        var r3 = a5 * b7;
        var lo3 = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo3;
        for (var k6 = 1; k6 < len; k6++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k6, num.length - 1);
          for (var j6 = Math.max(0, k6 - self2.length + 1); j6 <= maxJ; j6++) {
            var i3 = k6 - j6 | 0;
            a5 = self2.words[i3] | 0;
            b7 = num.words[j6] | 0;
            r3 = a5 * b7 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k6] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k6] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b7 = num.words;
        var o4 = out.words;
        var c7 = 0;
        var lo3;
        var mid;
        var hi4;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b7[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b7[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b7[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b7[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b7[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b7[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b62 = b7[6] | 0;
        var bl6 = b62 & 8191;
        var bh6 = b62 >>> 13;
        var b72 = b7[7] | 0;
        var bl7 = b72 & 8191;
        var bh7 = b72 >>> 13;
        var b8 = b7[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b7[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo3 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi4 = Math.imul(ah0, bh0);
        var w0 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo3 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi4 = Math.imul(ah1, bh0);
        lo3 = lo3 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi4 = hi4 + Math.imul(ah0, bh1) | 0;
        var w1 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo3 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi4 = Math.imul(ah2, bh0);
        lo3 = lo3 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi4 = hi4 + Math.imul(ah1, bh1) | 0;
        lo3 = lo3 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi4 = hi4 + Math.imul(ah0, bh2) | 0;
        var w22 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo3 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi4 = Math.imul(ah3, bh0);
        lo3 = lo3 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi4 = hi4 + Math.imul(ah2, bh1) | 0;
        lo3 = lo3 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi4 = hi4 + Math.imul(ah1, bh2) | 0;
        lo3 = lo3 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi4 = hi4 + Math.imul(ah0, bh3) | 0;
        var w32 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo3 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi4 = Math.imul(ah4, bh0);
        lo3 = lo3 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi4 = hi4 + Math.imul(ah3, bh1) | 0;
        lo3 = lo3 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi4 = hi4 + Math.imul(ah2, bh2) | 0;
        lo3 = lo3 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi4 = hi4 + Math.imul(ah1, bh3) | 0;
        lo3 = lo3 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi4 = hi4 + Math.imul(ah0, bh4) | 0;
        var w42 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo3 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi4 = Math.imul(ah5, bh0);
        lo3 = lo3 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi4 = hi4 + Math.imul(ah4, bh1) | 0;
        lo3 = lo3 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi4 = hi4 + Math.imul(ah3, bh2) | 0;
        lo3 = lo3 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi4 = hi4 + Math.imul(ah2, bh3) | 0;
        lo3 = lo3 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi4 = hi4 + Math.imul(ah1, bh4) | 0;
        lo3 = lo3 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi4 = hi4 + Math.imul(ah0, bh5) | 0;
        var w5 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo3 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi4 = Math.imul(ah6, bh0);
        lo3 = lo3 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi4 = hi4 + Math.imul(ah5, bh1) | 0;
        lo3 = lo3 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi4 = hi4 + Math.imul(ah4, bh2) | 0;
        lo3 = lo3 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi4 = hi4 + Math.imul(ah3, bh3) | 0;
        lo3 = lo3 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi4 = hi4 + Math.imul(ah2, bh4) | 0;
        lo3 = lo3 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi4 = hi4 + Math.imul(ah1, bh5) | 0;
        lo3 = lo3 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi4 = hi4 + Math.imul(ah0, bh6) | 0;
        var w6 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo3 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi4 = Math.imul(ah7, bh0);
        lo3 = lo3 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi4 = hi4 + Math.imul(ah6, bh1) | 0;
        lo3 = lo3 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi4 = hi4 + Math.imul(ah5, bh2) | 0;
        lo3 = lo3 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi4 = hi4 + Math.imul(ah4, bh3) | 0;
        lo3 = lo3 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi4 = hi4 + Math.imul(ah3, bh4) | 0;
        lo3 = lo3 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi4 = hi4 + Math.imul(ah2, bh5) | 0;
        lo3 = lo3 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi4 = hi4 + Math.imul(ah1, bh6) | 0;
        lo3 = lo3 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi4 = hi4 + Math.imul(ah0, bh7) | 0;
        var w7 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo3 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi4 = Math.imul(ah8, bh0);
        lo3 = lo3 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi4 = hi4 + Math.imul(ah7, bh1) | 0;
        lo3 = lo3 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi4 = hi4 + Math.imul(ah6, bh2) | 0;
        lo3 = lo3 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi4 = hi4 + Math.imul(ah5, bh3) | 0;
        lo3 = lo3 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi4 = hi4 + Math.imul(ah4, bh4) | 0;
        lo3 = lo3 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi4 = hi4 + Math.imul(ah3, bh5) | 0;
        lo3 = lo3 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi4 = hi4 + Math.imul(ah2, bh6) | 0;
        lo3 = lo3 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi4 = hi4 + Math.imul(ah1, bh7) | 0;
        lo3 = lo3 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi4 = hi4 + Math.imul(ah0, bh8) | 0;
        var w8 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo3 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi4 = Math.imul(ah9, bh0);
        lo3 = lo3 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi4 = hi4 + Math.imul(ah8, bh1) | 0;
        lo3 = lo3 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi4 = hi4 + Math.imul(ah7, bh2) | 0;
        lo3 = lo3 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi4 = hi4 + Math.imul(ah6, bh3) | 0;
        lo3 = lo3 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi4 = hi4 + Math.imul(ah5, bh4) | 0;
        lo3 = lo3 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi4 = hi4 + Math.imul(ah4, bh5) | 0;
        lo3 = lo3 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi4 = hi4 + Math.imul(ah3, bh6) | 0;
        lo3 = lo3 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi4 = hi4 + Math.imul(ah2, bh7) | 0;
        lo3 = lo3 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi4 = hi4 + Math.imul(ah1, bh8) | 0;
        lo3 = lo3 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi4 = hi4 + Math.imul(ah0, bh9) | 0;
        var w9 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo3 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi4 = Math.imul(ah9, bh1);
        lo3 = lo3 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi4 = hi4 + Math.imul(ah8, bh2) | 0;
        lo3 = lo3 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi4 = hi4 + Math.imul(ah7, bh3) | 0;
        lo3 = lo3 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi4 = hi4 + Math.imul(ah6, bh4) | 0;
        lo3 = lo3 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi4 = hi4 + Math.imul(ah5, bh5) | 0;
        lo3 = lo3 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi4 = hi4 + Math.imul(ah4, bh6) | 0;
        lo3 = lo3 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi4 = hi4 + Math.imul(ah3, bh7) | 0;
        lo3 = lo3 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi4 = hi4 + Math.imul(ah2, bh8) | 0;
        lo3 = lo3 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi4 = hi4 + Math.imul(ah1, bh9) | 0;
        var w10 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo3 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi4 = Math.imul(ah9, bh2);
        lo3 = lo3 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi4 = hi4 + Math.imul(ah8, bh3) | 0;
        lo3 = lo3 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi4 = hi4 + Math.imul(ah7, bh4) | 0;
        lo3 = lo3 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi4 = hi4 + Math.imul(ah6, bh5) | 0;
        lo3 = lo3 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi4 = hi4 + Math.imul(ah5, bh6) | 0;
        lo3 = lo3 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi4 = hi4 + Math.imul(ah4, bh7) | 0;
        lo3 = lo3 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi4 = hi4 + Math.imul(ah3, bh8) | 0;
        lo3 = lo3 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi4 = hi4 + Math.imul(ah2, bh9) | 0;
        var w11 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo3 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi4 = Math.imul(ah9, bh3);
        lo3 = lo3 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi4 = hi4 + Math.imul(ah8, bh4) | 0;
        lo3 = lo3 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi4 = hi4 + Math.imul(ah7, bh5) | 0;
        lo3 = lo3 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi4 = hi4 + Math.imul(ah6, bh6) | 0;
        lo3 = lo3 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi4 = hi4 + Math.imul(ah5, bh7) | 0;
        lo3 = lo3 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi4 = hi4 + Math.imul(ah4, bh8) | 0;
        lo3 = lo3 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi4 = hi4 + Math.imul(ah3, bh9) | 0;
        var w12 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo3 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi4 = Math.imul(ah9, bh4);
        lo3 = lo3 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi4 = hi4 + Math.imul(ah8, bh5) | 0;
        lo3 = lo3 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi4 = hi4 + Math.imul(ah7, bh6) | 0;
        lo3 = lo3 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi4 = hi4 + Math.imul(ah6, bh7) | 0;
        lo3 = lo3 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi4 = hi4 + Math.imul(ah5, bh8) | 0;
        lo3 = lo3 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi4 = hi4 + Math.imul(ah4, bh9) | 0;
        var w13 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo3 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi4 = Math.imul(ah9, bh5);
        lo3 = lo3 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi4 = hi4 + Math.imul(ah8, bh6) | 0;
        lo3 = lo3 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi4 = hi4 + Math.imul(ah7, bh7) | 0;
        lo3 = lo3 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi4 = hi4 + Math.imul(ah6, bh8) | 0;
        lo3 = lo3 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi4 = hi4 + Math.imul(ah5, bh9) | 0;
        var w14 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo3 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi4 = Math.imul(ah9, bh6);
        lo3 = lo3 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi4 = hi4 + Math.imul(ah8, bh7) | 0;
        lo3 = lo3 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi4 = hi4 + Math.imul(ah7, bh8) | 0;
        lo3 = lo3 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi4 = hi4 + Math.imul(ah6, bh9) | 0;
        var w15 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo3 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi4 = Math.imul(ah9, bh7);
        lo3 = lo3 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi4 = hi4 + Math.imul(ah8, bh8) | 0;
        lo3 = lo3 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi4 = hi4 + Math.imul(ah7, bh9) | 0;
        var w16 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo3 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi4 = Math.imul(ah9, bh8);
        lo3 = lo3 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi4 = hi4 + Math.imul(ah8, bh9) | 0;
        var w17 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo3 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi4 = Math.imul(ah9, bh9);
        var w18 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w0;
        o4[1] = w1;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w5;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w12;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c7 !== 0) {
          o4[19] = c7;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k6 = 0; k6 < out.length - 1; k6++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k6, num.length - 1);
          for (var j6 = Math.max(0, k6 - self2.length + 1); j6 <= maxJ; j6++) {
            var i3 = k6 - j6;
            var a5 = self2.words[i3] | 0;
            var b7 = num.words[j6] | 0;
            var r3 = a5 * b7;
            var lo3 = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo3 = lo3 + rword | 0;
            rword = lo3 & 67108863;
            ncarry = ncarry + (lo3 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k6] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k6] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x10, y9) {
        this.x = x10;
        this.y = y9;
      }
      FFTM.prototype.makeRBT = function makeRBT(N5) {
        var t = new Array(N5);
        var l7 = BN.prototype._countBits(N5) - 1;
        for (var i3 = 0; i3 < N5; i3++) {
          t[i3] = this.revBin(i3, l7, N5);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x10, l7, N5) {
        if (x10 === 0 || x10 === N5 - 1) return x10;
        var rb = 0;
        for (var i3 = 0; i3 < l7; i3++) {
          rb |= (x10 & 1) << l7 - i3 - 1;
          x10 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N5) {
        for (var i3 = 0; i3 < N5; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N5, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N5);
        for (var s2 = 1; s2 < N5; s2 <<= 1) {
          var l7 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l7);
          var itwdf = Math.sin(2 * Math.PI / l7);
          for (var p5 = 0; p5 < N5; p5 += l7) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j6 = 0; j6 < s2; j6++) {
              var re5 = rtws[p5 + j6];
              var ie6 = itws[p5 + j6];
              var ro4 = rtws[p5 + j6 + s2];
              var io3 = itws[p5 + j6 + s2];
              var rx = rtwdf_ * ro4 - itwdf_ * io3;
              io3 = rtwdf_ * io3 + itwdf_ * ro4;
              ro4 = rx;
              rtws[p5 + j6] = re5 + ro4;
              itws[p5 + j6] = ie6 + io3;
              rtws[p5 + j6 + s2] = re5 - ro4;
              itws[p5 + j6 + s2] = ie6 - io3;
              if (j6 !== l7) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m2) {
        var N5 = Math.max(m2, n4) | 1;
        var odd = N5 & 1;
        var i3 = 0;
        for (N5 = N5 / 2 | 0; N5; N5 = N5 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N5) {
        if (N5 <= 1) return;
        for (var i3 = 0; i3 < N5 / 2; i3++) {
          var t = rws[i3];
          rws[i3] = rws[N5 - i3 - 1];
          rws[N5 - i3 - 1] = t;
          t = iws[i3];
          iws[i3] = -iws[N5 - i3 - 1];
          iws[N5 - i3 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws3, N5) {
        var carry = 0;
        for (var i3 = 0; i3 < N5 / 2; i3++) {
          var w5 = Math.round(ws3[2 * i3 + 1] / N5) * 8192 + Math.round(ws3[2 * i3] / N5) + carry;
          ws3[i3] = w5 & 67108863;
          if (w5 < 67108864) {
            carry = 0;
          } else {
            carry = w5 / 67108864 | 0;
          }
        }
        return ws3;
      };
      FFTM.prototype.convert13b = function convert13b(ws3, len, rws, N5) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws3[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N5; ++i3) {
          rws[i3] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N5) {
        var ph = new Array(N5);
        for (var i3 = 0; i3 < N5; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x10, y9, out) {
        var N5 = 2 * this.guessLen13b(x10.length, y9.length);
        var rbt = this.makeRBT(N5);
        var _6 = this.stub(N5);
        var rws = new Array(N5);
        var rwst = new Array(N5);
        var iwst = new Array(N5);
        var nrws = new Array(N5);
        var nrwst = new Array(N5);
        var niwst = new Array(N5);
        var rmws = out.words;
        rmws.length = N5;
        this.convert13b(x10.words, x10.length, rws, N5);
        this.convert13b(y9.words, y9.length, nrws, N5);
        this.transform(rws, _6, rwst, iwst, N5, rbt);
        this.transform(nrws, _6, nrwst, niwst, N5, rbt);
        for (var i3 = 0; i3 < N5; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N5);
        this.transform(rwst, iwst, rmws, _6, N5, rbt);
        this.conjugate(rmws, _6, N5);
        this.normalize13b(rmws, N5);
        out.negative = x10.negative ^ y9.negative;
        out.length = x10.length + y9.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w5 = (this.words[i3] | 0) * num;
          var lo3 = (w5 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w5 / 67108864 | 0;
          carry += lo3 >>> 26;
          this.words[i3] = lo3 & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w5 = toBitArray(num);
        if (w5.length === 0) return new BN(1);
        var res = this;
        for (var i3 = 0; i3 < w5.length; i3++, res = res.sqr()) {
          if (w5[i3] !== 0) break;
        }
        if (++i3 < w5.length) {
          for (var q6 = res.sqr(); i3 < w5.length; i3++, q6 = q6.sqr()) {
            if (w5[i3] === 0) continue;
            res = res.mul(q6);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i3;
        if (r3 !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c7 = (this.words[i3] | 0) - newCarry << r3;
            this.words[i3] = c7 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s2] = this.words[i3];
          }
          for (i3 = 0; i3 < s2; i3++) {
            this.words[i3] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h7;
        if (hint) {
          h7 = (hint - hint % 26) / 26;
        } else {
          h7 = 0;
        }
        var r3 = bits % 26;
        var s2 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h7 -= s2;
        h7 = Math.max(0, h7);
        if (maskedWords) {
          for (var i3 = 0; i3 < s2; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h7); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q6 = 1 << r3;
        if (this.length <= s2) return false;
        var w5 = this.words[s2];
        return !!(w5 & q6);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r3 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i3;
        this._expand(len);
        var w5;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w5 = (this.words[i3 + shift] | 0) + carry;
          var right = (num.words[i3] | 0) * mul;
          w5 -= right & 67108863;
          carry = (w5 >> 26) - (right / 67108864 | 0);
          this.words[i3 + shift] = w5 & 67108863;
        }
        for (; i3 < this.length - shift; i3++) {
          w5 = (this.words[i3 + shift] | 0) + carry;
          carry = w5 >> 26;
          this.words[i3 + shift] = w5 & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w5 = -(this.words[i3] | 0) + carry;
          carry = w5 >> 26;
          this.words[i3] = w5 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b7 = num;
        var bhi = b7.words[b7.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b7 = b7.ushln(shift);
          a5.iushln(shift);
          bhi = b7.words[b7.length - 1] | 0;
        }
        var m2 = a5.length - b7.length;
        var q6;
        if (mode !== "mod") {
          q6 = new BN(null);
          q6.length = m2 + 1;
          q6.words = new Array(q6.length);
          for (var i3 = 0; i3 < q6.length; i3++) {
            q6.words[i3] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b7, 1, m2);
        if (diff.negative === 0) {
          a5 = diff;
          if (q6) {
            q6.words[m2] = 1;
          }
        }
        for (var j6 = m2 - 1; j6 >= 0; j6--) {
          var qj = (a5.words[b7.length + j6] | 0) * 67108864 + (a5.words[b7.length + j6 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b7, qj, j6);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b7, 1, j6);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q6) {
            q6.words[j6] = qj;
          }
        }
        if (q6) {
          q6.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q6 || null,
          mod: a5
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p5 * acc + (this.words[i3] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w5 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w5 / num | 0;
          carry = w5 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p5) {
        assert(p5.negative === 0);
        assert(!p5.isZero());
        var x10 = this;
        var y9 = p5.clone();
        if (x10.negative !== 0) {
          x10 = x10.umod(p5);
        } else {
          x10 = x10.clone();
        }
        var A4 = new BN(1);
        var B6 = new BN(0);
        var C6 = new BN(0);
        var D7 = new BN(1);
        var g5 = 0;
        while (x10.isEven() && y9.isEven()) {
          x10.iushrn(1);
          y9.iushrn(1);
          ++g5;
        }
        var yp = y9.clone();
        var xp = x10.clone();
        while (!x10.isZero()) {
          for (var i3 = 0, im = 1; (x10.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1) ;
          if (i3 > 0) {
            x10.iushrn(i3);
            while (i3-- > 0) {
              if (A4.isOdd() || B6.isOdd()) {
                A4.iadd(yp);
                B6.isub(xp);
              }
              A4.iushrn(1);
              B6.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (y9.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1) ;
          if (j6 > 0) {
            y9.iushrn(j6);
            while (j6-- > 0) {
              if (C6.isOdd() || D7.isOdd()) {
                C6.iadd(yp);
                D7.isub(xp);
              }
              C6.iushrn(1);
              D7.iushrn(1);
            }
          }
          if (x10.cmp(y9) >= 0) {
            x10.isub(y9);
            A4.isub(C6);
            B6.isub(D7);
          } else {
            y9.isub(x10);
            C6.isub(A4);
            D7.isub(B6);
          }
        }
        return {
          a: C6,
          b: D7,
          gcd: y9.iushln(g5)
        };
      };
      BN.prototype._invmp = function _invmp(p5) {
        assert(p5.negative === 0);
        assert(!p5.isZero());
        var a5 = this;
        var b7 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN(1);
        var x22 = new BN(0);
        var delta = b7.clone();
        while (a5.cmpn(1) > 0 && b7.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a5.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1) ;
          if (i3 > 0) {
            a5.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (b7.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1) ;
          if (j6 > 0) {
            b7.iushrn(j6);
            while (j6-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b7) >= 0) {
            a5.isub(b7);
            x1.isub(x22);
          } else {
            b7.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a5 = this.clone();
        var b7 = num.clone();
        a5.negative = 0;
        b7.negative = 0;
        for (var shift = 0; a5.isEven() && b7.isEven(); shift++) {
          a5.iushrn(1);
          b7.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b7.isEven()) {
            b7.iushrn(1);
          }
          var r3 = a5.cmp(b7);
          if (r3 < 0) {
            var t = a5;
            a5 = b7;
            b7 = t;
          } else if (r3 === 0 || b7.cmpn(1) === 0) {
            break;
          }
          a5.isub(b7);
        } while (true);
        return b7.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q6 = 1 << r3;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q6;
          return this;
        }
        var carry = q6;
        for (var i3 = s2; carry !== 0 && i3 < this.length; i3++) {
          var w5 = this.words[i3] | 0;
          w5 += carry;
          carry = w5 >>> 26;
          w5 &= 67108863;
          this.words[i3] = w5;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w5 = this.words[0] | 0;
          res = w5 === num ? 0 : w5 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a5 = this.words[i3] | 0;
          var b7 = num.words[i3] | 0;
          if (a5 === b7) continue;
          if (a5 < b7) {
            res = -1;
          } else if (a5 > b7) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt6(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt4(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next = input.words[i3] | 0;
          input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo3 = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w5 = num.words[i3] | 0;
          lo3 += w5 * 977;
          num.words[i3] = lo3 & 67108863;
          lo3 = w5 * 64 + (lo3 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi4 = (num.words[i3] | 0) * 19 + carry;
          var lo3 = hi4 & 67108863;
          hi4 >>>= 26;
          num.words[i3] = lo3;
          carry = hi4;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN._prime(m2);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m2.gtn(1), "modulus must be greater than 1");
          this.m = m2;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert(a5.negative === 0, "red works only with positives");
        assert(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b7) {
        assert((a5.negative | b7.negative) === 0, "red works only with positives");
        assert(
          a5.red && a5.red === b7.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime) return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b7) {
        this._verify2(a5, b7);
        var res = a5.add(b7);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b7) {
        this._verify2(a5, b7);
        var res = a5.iadd(b7);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b7) {
        this._verify2(a5, b7);
        var res = a5.sub(b7);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b7) {
        this._verify2(a5, b7);
        var res = a5.isub(b7);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b7) {
        this._verify2(a5, b7);
        return this.imod(a5.imul(b7));
      };
      Red.prototype.mul = function mul(a5, b7) {
        this._verify2(a5, b7);
        return this.imod(a5.mul(b7));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero()) return a5.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q6 = this.m.subn(1);
        var s2 = 0;
        while (!q6.isZero() && q6.andln(1) === 0) {
          s2++;
          q6.iushrn(1);
        }
        assert(!q6.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z10 = this.m.bitLength();
        z10 = new BN(2 * z10 * z10).toRed(this);
        while (this.pow(z10, lpow).cmp(nOne) !== 0) {
          z10.redIAdd(nOne);
        }
        var c7 = this.pow(z10, q6);
        var r3 = this.pow(a5, q6.addn(1).iushrn(1));
        var t = this.pow(a5, q6);
        var m2 = s2;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert(i3 < m2);
          var b7 = this.pow(c7, new BN(1).iushln(m2 - i3 - 1));
          r3 = r3.redMul(b7);
          c7 = b7.redSqr();
          t = t.redMul(c7);
          m2 = i3;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a5;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j6 = start - 1; j6 >= 0; j6--) {
            var bit = word >> j6 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j6 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        Red.call(this, m2);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a5, b7) {
        if (a5.isZero() || b7.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t = a5.imul(b7);
        var c7 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t.isub(c7).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b7) {
        if (a5.isZero() || b7.isZero()) return new BN(0)._forceRed(this);
        var t = a5.mul(b7);
        var c7 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t.isub(c7).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w5, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i3;
      for (i3 = 0; i3 < naf.length; i3 += 1) {
        naf[i3] = 0;
      }
      var ws3 = 1 << w5 + 1;
      var k6 = num.clone();
      for (i3 = 0; i3 < naf.length; i3++) {
        var z10;
        var mod = k6.andln(ws3 - 1);
        if (k6.isOdd()) {
          if (mod > (ws3 >> 1) - 1)
            z10 = (ws3 >> 1) - mod;
          else
            z10 = mod;
          k6.isubn(z10);
        } else {
          z10 = 0;
        }
        naf[i3] = z10;
        k6.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p5, k6) {
      assert(p5.precomputed);
      var doubles = p5._getDoubles();
      var naf = getNAF(k6, 1, this._bitLength);
      var I6 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I6 /= 3;
      var repr = [];
      var j6;
      var nafW;
      for (j6 = 0; j6 < naf.length; j6 += doubles.step) {
        nafW = 0;
        for (var l7 = j6 + doubles.step - 1; l7 >= j6; l7--)
          nafW = (nafW << 1) + naf[l7];
        repr.push(nafW);
      }
      var a5 = this.jpoint(null, null, null);
      var b7 = this.jpoint(null, null, null);
      for (var i3 = I6; i3 > 0; i3--) {
        for (j6 = 0; j6 < repr.length; j6++) {
          nafW = repr[j6];
          if (nafW === i3)
            b7 = b7.mixedAdd(doubles.points[j6]);
          else if (nafW === -i3)
            b7 = b7.mixedAdd(doubles.points[j6].neg());
        }
        a5 = a5.add(b7);
      }
      return a5.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p5, k6) {
      var w5 = 4;
      var nafPoints = p5._getNAFPoints(w5);
      w5 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k6, w5, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i3 = naf.length - 1; i3 >= 0; i3--) {
        for (var l7 = 0; i3 >= 0 && naf[i3] === 0; i3--)
          l7++;
        if (i3 >= 0)
          l7++;
        acc = acc.dblp(l7);
        if (i3 < 0)
          break;
        var z10 = naf[i3];
        assert(z10 !== 0);
        if (p5.type === "affine") {
          if (z10 > 0)
            acc = acc.mixedAdd(wnd[z10 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z10 - 1 >> 1].neg());
        } else {
          if (z10 > 0)
            acc = acc.add(wnd[z10 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z10 - 1 >> 1].neg());
        }
      }
      return p5.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i3;
      var j6;
      var p5;
      for (i3 = 0; i3 < len; i3++) {
        p5 = points[i3];
        var nafPoints = p5._getNAFPoints(defW);
        wndWidth[i3] = nafPoints.wnd;
        wnd[i3] = nafPoints.points;
      }
      for (i3 = len - 1; i3 >= 1; i3 -= 2) {
        var a5 = i3 - 1;
        var b7 = i3;
        if (wndWidth[a5] !== 1 || wndWidth[b7] !== 1) {
          naf[a5] = getNAF(coeffs[a5], wndWidth[a5], this._bitLength);
          naf[b7] = getNAF(coeffs[b7], wndWidth[b7], this._bitLength);
          max = Math.max(naf[a5].length, max);
          max = Math.max(naf[b7].length, max);
          continue;
        }
        var comb = [
          points[a5],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b7]
          /* 7 */
        ];
        if (points[a5].y.cmp(points[b7].y) === 0) {
          comb[1] = points[a5].add(points[b7]);
          comb[2] = points[a5].toJ().mixedAdd(points[b7].neg());
        } else if (points[a5].y.cmp(points[b7].y.redNeg()) === 0) {
          comb[1] = points[a5].toJ().mixedAdd(points[b7]);
          comb[2] = points[a5].add(points[b7].neg());
        } else {
          comb[1] = points[a5].toJ().mixedAdd(points[b7]);
          comb[2] = points[a5].toJ().mixedAdd(points[b7].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a5], coeffs[b7]);
        max = Math.max(jsf[0].length, max);
        naf[a5] = new Array(max);
        naf[b7] = new Array(max);
        for (j6 = 0; j6 < max; j6++) {
          var ja = jsf[0][j6] | 0;
          var jb = jsf[1][j6] | 0;
          naf[a5][j6] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b7][j6] = 0;
          wnd[a5] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i3 = max; i3 >= 0; i3--) {
        var k6 = 0;
        while (i3 >= 0) {
          var zero = true;
          for (j6 = 0; j6 < len; j6++) {
            tmp[j6] = naf[j6][i3] | 0;
            if (tmp[j6] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k6++;
          i3--;
        }
        if (i3 >= 0)
          k6++;
        acc = acc.dblp(k6);
        if (i3 < 0)
          break;
        for (j6 = 0; j6 < len; j6++) {
          var z10 = tmp[j6];
          p5;
          if (z10 === 0)
            continue;
          else if (z10 > 0)
            p5 = wnd[j6][z10 - 1 >> 1];
          else if (z10 < 0)
            p5 = wnd[j6][-z10 - 1 >> 1].neg();
          if (p5.type === "affine")
            acc = acc.mixedAdd(p5);
          else
            acc = acc.add(p5);
        }
      }
      for (i3 = 0; i3 < len; i3++)
        wnd[i3] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x10 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x10);
      return [4].concat(x10, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k6) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k6.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i3 = 0; i3 < power; i3 += step) {
        for (var j6 = 0; j6 < step; j6++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i3 = 1; i3 < max; i3++)
        res[i3] = res[i3 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k6) {
      var r3 = this;
      for (var i3 = 0; i3 < k6; i3++)
        r3 = r3.dbl();
      return r3;
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s2 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s2).fromRed();
      var l22 = ntinv.redSub(s2).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u4 = lambda;
      var v7 = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x22 = new BN(0);
      var y22 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i3 = 0;
      var r3;
      var x10;
      while (u4.cmpn(0) !== 0) {
        var q6 = v7.div(u4);
        r3 = v7.sub(q6.mul(u4));
        x10 = x22.sub(q6.mul(x1));
        var y9 = y22.sub(q6.mul(y1));
        if (!a1 && r3.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r3.neg();
          b1 = x10;
        } else if (a1 && ++i3 === 2) {
          break;
        }
        prevR = r3;
        v7 = u4;
        u4 = r3;
        x22 = x1;
        x1 = x10;
        y22 = y1;
        y1 = y9;
      }
      a22 = r3.neg();
      b22 = x10;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k6) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c12 = v22.b.mul(k6).divRound(this.n);
      var c22 = v1.b.neg().mul(k6).divRound(this.n);
      var p1 = c12.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c12.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k6.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x10, odd) {
      x10 = new BN(x10, 16);
      if (!x10.red)
        x10 = x10.toRed(this.red);
      var y22 = x10.redSqr().redMul(x10).redIAdd(x10.redMul(this.a)).redIAdd(this.b);
      var y9 = y22.redSqrt();
      if (y9.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y9.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y9 = y9.redNeg();
      return this.point(x10, y9);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x10 = point.x;
      var y9 = point.y;
      var ax = this.a.redMul(x10);
      var rhs = x10.redSqr().redMul(x10).redIAdd(ax).redIAdd(this.b);
      return y9.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i3 = 0; i3 < points.length; i3++) {
        var split = this._endoSplit(coeffs[i3]);
        var p5 = points[i3];
        var beta = p5._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p5 = p5.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i3 * 2] = p5;
        npoints[i3 * 2 + 1] = beta;
        ncoeffs[i3 * 2] = split.k1;
        ncoeffs[i3 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i3 * 2, jacobianResult);
      for (var j6 = 0; j6 < i3 * 2; j6++) {
        npoints[j6] = null;
        ncoeffs[j6] = null;
      }
      return res;
    };
    function Point(curve, x10, y9, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x10 === null && y9 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x10, 16);
        this.y = new BN(y9, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x10, y9, isRed) {
      return new Point(this, x10, y9, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p5) {
          return curve.point(p5.x.redMul(curve.endo.beta), p5.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p5) {
      if (this.inf)
        return p5;
      if (p5.inf)
        return this;
      if (this.eq(p5))
        return this.dbl();
      if (this.neg().eq(p5))
        return this.curve.point(null, null);
      if (this.x.cmp(p5.x) === 0)
        return this.curve.point(null, null);
      var c7 = this.y.redSub(p5.y);
      if (c7.cmpn(0) !== 0)
        c7 = c7.redMul(this.x.redSub(p5.x).redInvm());
      var nx = c7.redSqr().redISub(this.x).redISub(p5.x);
      var ny = c7.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a5 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c7 = x22.redAdd(x22).redIAdd(x22).redIAdd(a5).redMul(dyinv);
      var nx = c7.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c7.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k6) {
      k6 = new BN(k6, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k6))
        return this.curve._fixedNafMul(this, k6);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k6]);
      else
        return this.curve._wnafMul(this, k6);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p5) {
      return this === p5 || this.inf === p5.inf && (this.inf || this.x.cmp(p5.x) === 0 && this.y.cmp(p5.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p5) {
          return p5.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x10, y9, z10) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x10 === null && y9 === null && z10 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x10, 16);
        this.y = new BN(y9, 16);
        this.z = new BN(z10, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x10, y9, z10) {
      return new JPoint(this, x10, y9, z10);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      var pz2 = p5.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p5.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p5.z));
      var s2 = p5.y.redMul(z22.redMul(this.z));
      var h7 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h7.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h7.redSqr();
      var h32 = h22.redMul(h7);
      var v7 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
      var ny = r3.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p5.z).redMul(h7);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p5) {
      if (this.isInfinity())
        return p5.toJ();
      if (p5.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p5.x.redMul(z22);
      var s1 = this.y;
      var s2 = p5.y.redMul(z22).redMul(this.z);
      var h7 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h7.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h7.redSqr();
      var h32 = h22.redMul(h7);
      var v7 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
      var ny = r3.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h7);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i3;
      if (this.curve.zeroA || this.curve.threeA) {
        var r3 = this;
        for (i3 = 0; i3 < pow; i3++)
          r3 = r3.dbl();
        return r3;
      }
      var a5 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i3 = 0; i3 < pow; i3++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c7 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c7.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c7.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i3 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m2 = xx.redAdd(xx).redIAdd(xx);
        var t = m2.redSqr().redISub(s2).redISub(s2);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m2.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a5 = this.x.redSqr();
        var b7 = this.y.redSqr();
        var c7 = b7.redSqr();
        var d6 = this.x.redAdd(b7).redSqr().redISub(a5).redISub(c7);
        d6 = d6.redIAdd(d6);
        var e = a5.redAdd(a5).redIAdd(a5);
        var f7 = e.redSqr();
        var c8 = c7.redIAdd(c7);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f7.redISub(d6).redISub(d6);
        ny = e.redMul(d6.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m2.redSqr().redISub(s2).redISub(s2);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m2.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a5 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c7 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c7.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c7.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m2 = xx.redAdd(xx).redIAdd(xx);
      var mm = m2.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee7 = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u4 = m2.redIAdd(e).redSqr().redISub(mm).redISub(ee7).redISub(t);
      var yyu4 = yy.redMul(u4);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee7).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u4.redMul(t.redISub(u4)).redISub(e.redMul(ee7)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee7);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k6, kbase) {
      k6 = new BN(k6, kbase);
      return this.curve._wnafMul(this, k6);
    };
    JPoint.prototype.eq = function eq(p5) {
      if (p5.type === "affine")
        return this.eq(p5.toJ());
      if (this === p5)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p5.z.redSqr();
      if (this.x.redMul(pz2).redISub(p5.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p5.z);
      return this.y.redMul(pz3).redISub(p5.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x10) {
      var zs3 = this.z.redSqr();
      var rx = x10.toRed(this.curve.red).redMul(zs3);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x10.clone();
      var t = this.curve.redN.redMul(zs3);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils3();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x10 = point.normalize().x;
      var x22 = x10.redSqr();
      var rhs = x22.redMul(x10).redAdd(x22.redMul(this.a)).redAdd(x10);
      var y9 = rhs.redSqrt();
      return y9.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x10, z10) {
      Base.BasePoint.call(this, curve, "projective");
      if (x10 === null && z10 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x10, 16);
        this.z = new BN(z10, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x10, z10) {
      return new Point(this, x10, z10);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a5 = this.x.redAdd(this.z);
      var aa = a5.redSqr();
      var b7 = this.x.redSub(this.z);
      var bb = b7.redSqr();
      var c7 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c7.redMul(bb.redAdd(this.curve.a24.redMul(c7)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p5, diff) {
      var a5 = this.x.redAdd(this.z);
      var b7 = this.x.redSub(this.z);
      var c7 = p5.x.redAdd(p5.z);
      var d6 = p5.x.redSub(p5.z);
      var da = d6.redMul(a5);
      var cb = c7.redMul(b7);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k6) {
      var t = k6.clone();
      var a5 = this;
      var b7 = this.curve.point(null, null);
      var c7 = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i3 = bits.length - 1; i3 >= 0; i3--) {
        if (bits[i3] === 0) {
          a5 = a5.diffAdd(b7, c7);
          b7 = b7.dbl();
        } else {
          b7 = a5.diffAdd(b7, c7);
          a5 = a5.dbl();
        }
      }
      return b7;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x10, y9, z10, t) {
      return this.point(x10, y9, z10, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x10, odd) {
      x10 = new BN(x10, 16);
      if (!x10.red)
        x10 = x10.toRed(this.red);
      var x22 = x10.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y9 = y22.redSqrt();
      if (y9.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y9.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y9 = y9.redNeg();
      return this.point(x10, y9);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y9, odd) {
      y9 = new BN(y9, 16);
      if (!y9.red)
        y9 = y9.toRed(this.red);
      var y22 = y9.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y9);
      }
      var x10 = x22.redSqrt();
      if (x10.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x10.fromRed().isOdd() !== odd)
        x10 = x10.redNeg();
      return this.point(x10, y9);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x10, y9, z10, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x10 === null && y9 === null && z10 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x10, 16);
        this.y = new BN(y9, 16);
        this.z = z10 ? new BN(z10, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x10, y9, z10, t) {
      return new Point(this, x10, y9, z10, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a5 = this.x.redSqr();
      var b7 = this.y.redSqr();
      var c7 = this.z.redSqr();
      c7 = c7.redIAdd(c7);
      var d6 = this.curve._mulA(a5);
      var e = this.x.redAdd(this.y).redSqr().redISub(a5).redISub(b7);
      var g5 = d6.redAdd(b7);
      var f7 = g5.redSub(c7);
      var h7 = d6.redSub(b7);
      var nx = e.redMul(f7);
      var ny = g5.redMul(h7);
      var nt4 = e.redMul(h7);
      var nz = f7.redMul(g5);
      return this.curve.point(nx, ny, nz, nt4);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b7 = this.x.redAdd(this.y).redSqr();
      var c7 = this.x.redSqr();
      var d6 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h7;
      var j6;
      if (this.curve.twisted) {
        e = this.curve._mulA(c7);
        var f7 = e.redAdd(d6);
        if (this.zOne) {
          nx = b7.redSub(c7).redSub(d6).redMul(f7.redSub(this.curve.two));
          ny = f7.redMul(e.redSub(d6));
          nz = f7.redSqr().redSub(f7).redSub(f7);
        } else {
          h7 = this.z.redSqr();
          j6 = f7.redSub(h7).redISub(h7);
          nx = b7.redSub(c7).redISub(d6).redMul(j6);
          ny = f7.redMul(e.redSub(d6));
          nz = f7.redMul(j6);
        }
      } else {
        e = c7.redAdd(d6);
        h7 = this.curve._mulC(this.z).redSqr();
        j6 = e.redSub(h7).redSub(h7);
        nx = this.curve._mulC(b7.redISub(e)).redMul(j6);
        ny = this.curve._mulC(e).redMul(c7.redISub(d6));
        nz = e.redMul(j6);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p5) {
      var a5 = this.y.redSub(this.x).redMul(p5.y.redSub(p5.x));
      var b7 = this.y.redAdd(this.x).redMul(p5.y.redAdd(p5.x));
      var c7 = this.t.redMul(this.curve.dd).redMul(p5.t);
      var d6 = this.z.redMul(p5.z.redAdd(p5.z));
      var e = b7.redSub(a5);
      var f7 = d6.redSub(c7);
      var g5 = d6.redAdd(c7);
      var h7 = b7.redAdd(a5);
      var nx = e.redMul(f7);
      var ny = g5.redMul(h7);
      var nt4 = e.redMul(h7);
      var nz = f7.redMul(g5);
      return this.curve.point(nx, ny, nz, nt4);
    };
    Point.prototype._projAdd = function _projAdd(p5) {
      var a5 = this.z.redMul(p5.z);
      var b7 = a5.redSqr();
      var c7 = this.x.redMul(p5.x);
      var d6 = this.y.redMul(p5.y);
      var e = this.curve.d.redMul(c7).redMul(d6);
      var f7 = b7.redSub(e);
      var g5 = b7.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p5.x.redAdd(p5.y)).redISub(c7).redISub(d6);
      var nx = a5.redMul(f7).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a5.redMul(g5).redMul(d6.redSub(this.curve._mulA(c7)));
        nz = f7.redMul(g5);
      } else {
        ny = a5.redMul(g5).redMul(d6.redSub(c7));
        nz = this.curve._mulC(f7).redMul(g5);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p5);
      else
        return this._projAdd(p5);
    };
    Point.prototype.mul = function mul(k6) {
      if (this._hasDoubles(k6))
        return this.curve._fixedNafMul(this, k6);
      else
        return this.curve._wnafMul(this, k6);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k1, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k1, k22], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi3 = this.z.redInvm();
      this.x = this.x.redMul(zi3);
      this.y = this.y.redMul(zi3);
      if (this.t)
        this.t = this.t.redMul(zi3);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x10) {
      var rx = x10.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x10.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve();
    var utils = require_utils3();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify2(msg, signature, options) {
      return this.ec.verify(msg, signature, this, void 0, options);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p5) {
      var initial = buf[p5.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p5.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i3 = 0, off = p5.place; i3 < octetLen; i3++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p5.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i3 = 0;
      var len = buf.length - 1;
      while (!buf[i3] && !(buf[i3 + 1] & 128) && i3 < len) {
        i3++;
      }
      if (i3 === 0) {
        return buf;
      }
      return buf.slice(i3);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p5 = new Position();
      if (data[p5.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p5);
      if (len === false) {
        return false;
      }
      if (len + p5.place !== data.length) {
        return false;
      }
      if (data[p5.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p5);
      if (rlen === false) {
        return false;
      }
      if ((data[p5.place] & 128) !== 0) {
        return false;
      }
      var r3 = data.slice(p5.place, rlen + p5.place);
      p5.place += rlen;
      if (data[p5.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p5);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p5.place) {
        return false;
      }
      if ((data[p5.place] & 128) !== 0) {
        return false;
      }
      var s2 = data.slice(p5.place, slen + p5.place);
      if (r3[0] === 0) {
        if (r3[1] & 128) {
          r3 = r3.slice(1);
        } else {
          return false;
        }
      }
      if (s2[0] === 0) {
        if (s2[1] & 128) {
          s2 = s2.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r3);
      this.s = new BN(s2);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r3 = this.r.toArray();
      var s2 = this.s.toArray();
      if (r3[0] & 128)
        r3 = [0].concat(r3);
      if (s2[0] & 128)
        s2 = [0].concat(s2);
      r3 = rmPadding(r3);
      s2 = rmPadding(s2);
      while (!s2[0] && !(s2[1] & 128)) {
        s2 = s2.slice(1);
      }
      var arr = [2];
      constructLength(arr, r3.length);
      arr = arr.concat(r3);
      arr.push(2);
      constructLength(arr, s2.length);
      var backHalf = arr.concat(s2);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils3();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
      var byteLength;
      if (BN.isBN(msg) || typeof msg === "number") {
        msg = new BN(msg, 16);
        byteLength = msg.byteLength();
      } else if (typeof msg === "object") {
        byteLength = msg.length;
        msg = new BN(msg, 16);
      } else {
        var str = msg.toString();
        byteLength = str.length + 1 >>> 1;
        msg = new BN(str, 16);
      }
      if (typeof bitLength !== "number") {
        bitLength = byteLength * 8;
      }
      var delta = bitLength - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
        assert(
          typeof msg === "object" && msg && typeof msg.length === "number",
          "Expected message to be an array-like, a hex string, or a BN instance"
        );
        assert(msg.length >>> 0 === msg.length);
        for (var i3 = 0; i3 < msg.length; i3++) assert((msg[i3] & 255) === msg[i3]);
      }
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(msg, false, options.msgBitLength);
      assert(!msg.isNeg(), "Can not sign a negative message");
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      assert(new BN(nonce).eq(msg), "Can not sign message");
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k6 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k6 = this._truncateToN(k6, true);
        if (k6.cmpn(1) <= 0 || k6.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k6);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r3 = kpX.umod(this.n);
        if (r3.cmpn(0) === 0)
          continue;
        var s2 = k6.invm(this.n).mul(r3.mul(key.getPrivate()).iadd(msg));
        s2 = s2.umod(this.n);
        if (s2.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r3) !== 0 ? 2 : 0);
        if (options.canonical && s2.cmp(this.nh) > 0) {
          s2 = this.n.sub(s2);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r3, s: s2, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature, key, enc, options) {
      if (!options)
        options = {};
      msg = this._truncateToN(msg, false, options.msgBitLength);
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r3 = signature.r;
      var s2 = signature.s;
      if (r3.cmpn(1) < 0 || r3.cmp(this.n) >= 0)
        return false;
      if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
        return false;
      var sinv = s2.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r3).umod(this.n);
      var p5;
      if (!this.curve._maxwellTrick) {
        p5 = this.g.mulAdd(u1, key.getPublic(), u22);
        if (p5.isInfinity())
          return false;
        return p5.getX().umod(this.n).cmp(r3) === 0;
      }
      p5 = this.g.jmulAdd(u1, key.getPublic(), u22);
      if (p5.isInfinity())
        return false;
      return p5.eqXToP(r3);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j6, enc) {
      assert((3 & j6) === j6, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n4 = this.n;
      var e = new BN(msg);
      var r3 = signature.r;
      var s2 = signature.s;
      var isYOdd = j6 & 1;
      var isSecondKey = j6 >> 1;
      if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r3 = this.curve.pointFromX(r3.add(this.curve.n), isYOdd);
      else
        r3 = this.curve.pointFromX(r3, isYOdd);
      var rInv = signature.r.invm(n4);
      var s1 = n4.sub(e).mul(rInv).umod(n4);
      var s22 = s2.mul(rInv).umod(n4);
      return this.g.mulAdd(s1, r3, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q5, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i3 = 0; i3 < 4; i3++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i3);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q5))
          return i3;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a5 = hash.slice(0, eddsa.encodingLength);
      a5[0] &= 248;
      a5[lastIx] &= 127;
      a5[lastIx] |= 64;
      return a5;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify2(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S9() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R6() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves();
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r3 = this.hashInt(key.messagePrefix(), message);
      var R6 = this.g.mul(r3);
      var Rencoded = this.encodePoint(R6);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S9 = r3.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R6, S: S9, Rencoded });
    };
    EDDSA.prototype.verify = function verify2(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h7 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h7));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i3 = 0; i3 < arguments.length; i3++)
        hash2.update(arguments[i3]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y9 = utils.intFromLE(normed);
      return this.curve.pointFromY(y9, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils3();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@stablelib/sha512/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA512 = (
      /** @class */
      function() {
        function SHA5122() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._stateHi = new Int32Array(8);
          this._stateLo = new Int32Array(8);
          this._tempHi = new Int32Array(16);
          this._tempLo = new Int32Array(16);
          this._buffer = new Uint8Array(256);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA5122.prototype._initState = function() {
          this._stateHi[0] = 1779033703;
          this._stateHi[1] = 3144134277;
          this._stateHi[2] = 1013904242;
          this._stateHi[3] = 2773480762;
          this._stateHi[4] = 1359893119;
          this._stateHi[5] = 2600822924;
          this._stateHi[6] = 528734635;
          this._stateHi[7] = 1541459225;
          this._stateLo[0] = 4089235720;
          this._stateLo[1] = 2227873595;
          this._stateLo[2] = 4271175723;
          this._stateLo[3] = 1595750129;
          this._stateLo[4] = 2917565137;
          this._stateLo[5] = 725511199;
          this._stateLo[6] = 4215389547;
          this._stateLo[7] = 327033209;
        };
        SHA5122.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._tempHi);
          wipe_1.wipe(this._tempLo);
          this.reset();
        };
        SHA5122.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA5122.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 128 < 112 ? 128 : 256;
            this._buffer[left] = 128;
            for (var i3 = left + 1; i3 < padLength - 8; i3++) {
              this._buffer[i3] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i3 = 0; i3 < this.digestLength / 8; i3++) {
            binary_1.writeUint32BE(this._stateHi[i3], out, i3 * 8);
            binary_1.writeUint32BE(this._stateLo[i3], out, i3 * 8 + 4);
          }
          return this;
        };
        SHA5122.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA5122.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA5122.prototype.restoreState = function(savedState) {
          this._stateHi.set(savedState.stateHi);
          this._stateLo.set(savedState.stateLo);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.stateHi);
          wipe_1.wipe(savedState.stateLo);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA5122;
      }()
    );
    exports.SHA512 = SHA512;
    var K6 = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m2, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h7, l7;
      var th, tl;
      var a5, b7, c7, d6;
      while (len >= 128) {
        for (var i3 = 0; i3 < 16; i3++) {
          var j6 = 8 * i3 + pos;
          wh[i3] = binary_1.readUint32BE(m2, j6);
          wl[i3] = binary_1.readUint32BE(m2, j6 + 4);
        }
        for (var i3 = 0; i3 < 80; i3++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h7 = ah7;
          l7 = al7;
          a5 = l7 & 65535;
          b7 = l7 >>> 16;
          c7 = h7 & 65535;
          d6 = h7 >>> 16;
          h7 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l7 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a5 += l7 & 65535;
          b7 += l7 >>> 16;
          c7 += h7 & 65535;
          d6 += h7 >>> 16;
          h7 = ah4 & ah5 ^ ~ah4 & ah6;
          l7 = al4 & al5 ^ ~al4 & al6;
          a5 += l7 & 65535;
          b7 += l7 >>> 16;
          c7 += h7 & 65535;
          d6 += h7 >>> 16;
          h7 = K6[i3 * 2];
          l7 = K6[i3 * 2 + 1];
          a5 += l7 & 65535;
          b7 += l7 >>> 16;
          c7 += h7 & 65535;
          d6 += h7 >>> 16;
          h7 = wh[i3 % 16];
          l7 = wl[i3 % 16];
          a5 += l7 & 65535;
          b7 += l7 >>> 16;
          c7 += h7 & 65535;
          d6 += h7 >>> 16;
          b7 += a5 >>> 16;
          c7 += b7 >>> 16;
          d6 += c7 >>> 16;
          th = c7 & 65535 | d6 << 16;
          tl = a5 & 65535 | b7 << 16;
          h7 = th;
          l7 = tl;
          a5 = l7 & 65535;
          b7 = l7 >>> 16;
          c7 = h7 & 65535;
          d6 = h7 >>> 16;
          h7 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l7 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a5 += l7 & 65535;
          b7 += l7 >>> 16;
          c7 += h7 & 65535;
          d6 += h7 >>> 16;
          h7 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l7 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a5 += l7 & 65535;
          b7 += l7 >>> 16;
          c7 += h7 & 65535;
          d6 += h7 >>> 16;
          b7 += a5 >>> 16;
          c7 += b7 >>> 16;
          d6 += c7 >>> 16;
          bh7 = c7 & 65535 | d6 << 16;
          bl7 = a5 & 65535 | b7 << 16;
          h7 = bh3;
          l7 = bl3;
          a5 = l7 & 65535;
          b7 = l7 >>> 16;
          c7 = h7 & 65535;
          d6 = h7 >>> 16;
          h7 = th;
          l7 = tl;
          a5 += l7 & 65535;
          b7 += l7 >>> 16;
          c7 += h7 & 65535;
          d6 += h7 >>> 16;
          b7 += a5 >>> 16;
          c7 += b7 >>> 16;
          d6 += c7 >>> 16;
          bh3 = c7 & 65535 | d6 << 16;
          bl3 = a5 & 65535 | b7 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i3 % 16 === 15) {
            for (var j6 = 0; j6 < 16; j6++) {
              h7 = wh[j6];
              l7 = wl[j6];
              a5 = l7 & 65535;
              b7 = l7 >>> 16;
              c7 = h7 & 65535;
              d6 = h7 >>> 16;
              h7 = wh[(j6 + 9) % 16];
              l7 = wl[(j6 + 9) % 16];
              a5 += l7 & 65535;
              b7 += l7 >>> 16;
              c7 += h7 & 65535;
              d6 += h7 >>> 16;
              th = wh[(j6 + 1) % 16];
              tl = wl[(j6 + 1) % 16];
              h7 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l7 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a5 += l7 & 65535;
              b7 += l7 >>> 16;
              c7 += h7 & 65535;
              d6 += h7 >>> 16;
              th = wh[(j6 + 14) % 16];
              tl = wl[(j6 + 14) % 16];
              h7 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l7 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a5 += l7 & 65535;
              b7 += l7 >>> 16;
              c7 += h7 & 65535;
              d6 += h7 >>> 16;
              b7 += a5 >>> 16;
              c7 += b7 >>> 16;
              d6 += c7 >>> 16;
              wh[j6] = c7 & 65535 | d6 << 16;
              wl[j6] = a5 & 65535 | b7 << 16;
            }
          }
        }
        h7 = ah0;
        l7 = al0;
        a5 = l7 & 65535;
        b7 = l7 >>> 16;
        c7 = h7 & 65535;
        d6 = h7 >>> 16;
        h7 = hh[0];
        l7 = hl[0];
        a5 += l7 & 65535;
        b7 += l7 >>> 16;
        c7 += h7 & 65535;
        d6 += h7 >>> 16;
        b7 += a5 >>> 16;
        c7 += b7 >>> 16;
        d6 += c7 >>> 16;
        hh[0] = ah0 = c7 & 65535 | d6 << 16;
        hl[0] = al0 = a5 & 65535 | b7 << 16;
        h7 = ah1;
        l7 = al1;
        a5 = l7 & 65535;
        b7 = l7 >>> 16;
        c7 = h7 & 65535;
        d6 = h7 >>> 16;
        h7 = hh[1];
        l7 = hl[1];
        a5 += l7 & 65535;
        b7 += l7 >>> 16;
        c7 += h7 & 65535;
        d6 += h7 >>> 16;
        b7 += a5 >>> 16;
        c7 += b7 >>> 16;
        d6 += c7 >>> 16;
        hh[1] = ah1 = c7 & 65535 | d6 << 16;
        hl[1] = al1 = a5 & 65535 | b7 << 16;
        h7 = ah2;
        l7 = al2;
        a5 = l7 & 65535;
        b7 = l7 >>> 16;
        c7 = h7 & 65535;
        d6 = h7 >>> 16;
        h7 = hh[2];
        l7 = hl[2];
        a5 += l7 & 65535;
        b7 += l7 >>> 16;
        c7 += h7 & 65535;
        d6 += h7 >>> 16;
        b7 += a5 >>> 16;
        c7 += b7 >>> 16;
        d6 += c7 >>> 16;
        hh[2] = ah2 = c7 & 65535 | d6 << 16;
        hl[2] = al2 = a5 & 65535 | b7 << 16;
        h7 = ah3;
        l7 = al3;
        a5 = l7 & 65535;
        b7 = l7 >>> 16;
        c7 = h7 & 65535;
        d6 = h7 >>> 16;
        h7 = hh[3];
        l7 = hl[3];
        a5 += l7 & 65535;
        b7 += l7 >>> 16;
        c7 += h7 & 65535;
        d6 += h7 >>> 16;
        b7 += a5 >>> 16;
        c7 += b7 >>> 16;
        d6 += c7 >>> 16;
        hh[3] = ah3 = c7 & 65535 | d6 << 16;
        hl[3] = al3 = a5 & 65535 | b7 << 16;
        h7 = ah4;
        l7 = al4;
        a5 = l7 & 65535;
        b7 = l7 >>> 16;
        c7 = h7 & 65535;
        d6 = h7 >>> 16;
        h7 = hh[4];
        l7 = hl[4];
        a5 += l7 & 65535;
        b7 += l7 >>> 16;
        c7 += h7 & 65535;
        d6 += h7 >>> 16;
        b7 += a5 >>> 16;
        c7 += b7 >>> 16;
        d6 += c7 >>> 16;
        hh[4] = ah4 = c7 & 65535 | d6 << 16;
        hl[4] = al4 = a5 & 65535 | b7 << 16;
        h7 = ah5;
        l7 = al5;
        a5 = l7 & 65535;
        b7 = l7 >>> 16;
        c7 = h7 & 65535;
        d6 = h7 >>> 16;
        h7 = hh[5];
        l7 = hl[5];
        a5 += l7 & 65535;
        b7 += l7 >>> 16;
        c7 += h7 & 65535;
        d6 += h7 >>> 16;
        b7 += a5 >>> 16;
        c7 += b7 >>> 16;
        d6 += c7 >>> 16;
        hh[5] = ah5 = c7 & 65535 | d6 << 16;
        hl[5] = al5 = a5 & 65535 | b7 << 16;
        h7 = ah6;
        l7 = al6;
        a5 = l7 & 65535;
        b7 = l7 >>> 16;
        c7 = h7 & 65535;
        d6 = h7 >>> 16;
        h7 = hh[6];
        l7 = hl[6];
        a5 += l7 & 65535;
        b7 += l7 >>> 16;
        c7 += h7 & 65535;
        d6 += h7 >>> 16;
        b7 += a5 >>> 16;
        c7 += b7 >>> 16;
        d6 += c7 >>> 16;
        hh[6] = ah6 = c7 & 65535 | d6 << 16;
        hl[6] = al6 = a5 & 65535 | b7 << 16;
        h7 = ah7;
        l7 = al7;
        a5 = l7 & 65535;
        b7 = l7 >>> 16;
        c7 = h7 & 65535;
        d6 = h7 >>> 16;
        h7 = hh[7];
        l7 = hl[7];
        a5 += l7 & 65535;
        b7 += l7 >>> 16;
        c7 += h7 & 65535;
        d6 += h7 >>> 16;
        b7 += a5 >>> 16;
        c7 += b7 >>> 16;
        d6 += c7 >>> 16;
        hh[7] = ah7 = c7 & 65535 | d6 << 16;
        hl[7] = al7 = a5 & 65535 | b7 << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    function hash(data) {
      var h7 = new SHA512();
      h7.update(data);
      var digest = h7.digest();
      h7.clean();
      return digest;
    }
    exports.hash = hash;
  }
});

// node_modules/@stablelib/ed25519/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf(init) {
      const r3 = new Float64Array(16);
      if (init) {
        for (let i3 = 0; i3 < init.length; i3++) {
          r3[i3] = init[i3];
        }
      }
      return r3;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D7 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X3 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y4 = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I6 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r3, a5) {
      for (let i3 = 0; i3 < 16; i3++) {
        r3[i3] = a5[i3] | 0;
      }
    }
    function car25519(o4) {
      let c7 = 1;
      for (let i3 = 0; i3 < 16; i3++) {
        let v7 = o4[i3] + c7 + 65535;
        c7 = Math.floor(v7 / 65536);
        o4[i3] = v7 - c7 * 65536;
      }
      o4[0] += c7 - 1 + 37 * (c7 - 1);
    }
    function sel25519(p5, q6, b7) {
      const c7 = ~(b7 - 1);
      for (let i3 = 0; i3 < 16; i3++) {
        const t = c7 & (p5[i3] ^ q6[i3]);
        p5[i3] ^= t;
        q6[i3] ^= t;
      }
    }
    function pack25519(o4, n4) {
      const m2 = gf();
      const t = gf();
      for (let i3 = 0; i3 < 16; i3++) {
        t[i3] = n4[i3];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j6 = 0; j6 < 2; j6++) {
        m2[0] = t[0] - 65517;
        for (let i3 = 1; i3 < 15; i3++) {
          m2[i3] = t[i3] - 65535 - (m2[i3 - 1] >> 16 & 1);
          m2[i3 - 1] &= 65535;
        }
        m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
        const b7 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t, m2, 1 - b7);
      }
      for (let i3 = 0; i3 < 16; i3++) {
        o4[2 * i3] = t[i3] & 255;
        o4[2 * i3 + 1] = t[i3] >> 8;
      }
    }
    function verify32(x10, y9) {
      let d6 = 0;
      for (let i3 = 0; i3 < 32; i3++) {
        d6 |= x10[i3] ^ y9[i3];
      }
      return (1 & d6 - 1 >>> 8) - 1;
    }
    function neq25519(a5, b7) {
      const c7 = new Uint8Array(32);
      const d6 = new Uint8Array(32);
      pack25519(c7, a5);
      pack25519(d6, b7);
      return verify32(c7, d6);
    }
    function par25519(a5) {
      const d6 = new Uint8Array(32);
      pack25519(d6, a5);
      return d6[0] & 1;
    }
    function unpack25519(o4, n4) {
      for (let i3 = 0; i3 < 16; i3++) {
        o4[i3] = n4[2 * i3] + (n4[2 * i3 + 1] << 8);
      }
      o4[15] &= 32767;
    }
    function add(o4, a5, b7) {
      for (let i3 = 0; i3 < 16; i3++) {
        o4[i3] = a5[i3] + b7[i3];
      }
    }
    function sub(o4, a5, b7) {
      for (let i3 = 0; i3 < 16; i3++) {
        o4[i3] = a5[i3] - b7[i3];
      }
    }
    function mul(o4, a5, b7) {
      let v7, c7, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b7[0], b1 = b7[1], b22 = b7[2], b32 = b7[3], b42 = b7[4], b52 = b7[5], b62 = b7[6], b72 = b7[7], b8 = b7[8], b9 = b7[9], b10 = b7[10], b11 = b7[11], b12 = b7[12], b13 = b7[13], b14 = b7[14], b15 = b7[15];
      v7 = a5[0];
      t0 += v7 * b0;
      t1 += v7 * b1;
      t2 += v7 * b22;
      t3 += v7 * b32;
      t4 += v7 * b42;
      t5 += v7 * b52;
      t6 += v7 * b62;
      t7 += v7 * b72;
      t8 += v7 * b8;
      t9 += v7 * b9;
      t10 += v7 * b10;
      t11 += v7 * b11;
      t12 += v7 * b12;
      t13 += v7 * b13;
      t14 += v7 * b14;
      t15 += v7 * b15;
      v7 = a5[1];
      t1 += v7 * b0;
      t2 += v7 * b1;
      t3 += v7 * b22;
      t4 += v7 * b32;
      t5 += v7 * b42;
      t6 += v7 * b52;
      t7 += v7 * b62;
      t8 += v7 * b72;
      t9 += v7 * b8;
      t10 += v7 * b9;
      t11 += v7 * b10;
      t12 += v7 * b11;
      t13 += v7 * b12;
      t14 += v7 * b13;
      t15 += v7 * b14;
      t16 += v7 * b15;
      v7 = a5[2];
      t2 += v7 * b0;
      t3 += v7 * b1;
      t4 += v7 * b22;
      t5 += v7 * b32;
      t6 += v7 * b42;
      t7 += v7 * b52;
      t8 += v7 * b62;
      t9 += v7 * b72;
      t10 += v7 * b8;
      t11 += v7 * b9;
      t12 += v7 * b10;
      t13 += v7 * b11;
      t14 += v7 * b12;
      t15 += v7 * b13;
      t16 += v7 * b14;
      t17 += v7 * b15;
      v7 = a5[3];
      t3 += v7 * b0;
      t4 += v7 * b1;
      t5 += v7 * b22;
      t6 += v7 * b32;
      t7 += v7 * b42;
      t8 += v7 * b52;
      t9 += v7 * b62;
      t10 += v7 * b72;
      t11 += v7 * b8;
      t12 += v7 * b9;
      t13 += v7 * b10;
      t14 += v7 * b11;
      t15 += v7 * b12;
      t16 += v7 * b13;
      t17 += v7 * b14;
      t18 += v7 * b15;
      v7 = a5[4];
      t4 += v7 * b0;
      t5 += v7 * b1;
      t6 += v7 * b22;
      t7 += v7 * b32;
      t8 += v7 * b42;
      t9 += v7 * b52;
      t10 += v7 * b62;
      t11 += v7 * b72;
      t12 += v7 * b8;
      t13 += v7 * b9;
      t14 += v7 * b10;
      t15 += v7 * b11;
      t16 += v7 * b12;
      t17 += v7 * b13;
      t18 += v7 * b14;
      t19 += v7 * b15;
      v7 = a5[5];
      t5 += v7 * b0;
      t6 += v7 * b1;
      t7 += v7 * b22;
      t8 += v7 * b32;
      t9 += v7 * b42;
      t10 += v7 * b52;
      t11 += v7 * b62;
      t12 += v7 * b72;
      t13 += v7 * b8;
      t14 += v7 * b9;
      t15 += v7 * b10;
      t16 += v7 * b11;
      t17 += v7 * b12;
      t18 += v7 * b13;
      t19 += v7 * b14;
      t20 += v7 * b15;
      v7 = a5[6];
      t6 += v7 * b0;
      t7 += v7 * b1;
      t8 += v7 * b22;
      t9 += v7 * b32;
      t10 += v7 * b42;
      t11 += v7 * b52;
      t12 += v7 * b62;
      t13 += v7 * b72;
      t14 += v7 * b8;
      t15 += v7 * b9;
      t16 += v7 * b10;
      t17 += v7 * b11;
      t18 += v7 * b12;
      t19 += v7 * b13;
      t20 += v7 * b14;
      t21 += v7 * b15;
      v7 = a5[7];
      t7 += v7 * b0;
      t8 += v7 * b1;
      t9 += v7 * b22;
      t10 += v7 * b32;
      t11 += v7 * b42;
      t12 += v7 * b52;
      t13 += v7 * b62;
      t14 += v7 * b72;
      t15 += v7 * b8;
      t16 += v7 * b9;
      t17 += v7 * b10;
      t18 += v7 * b11;
      t19 += v7 * b12;
      t20 += v7 * b13;
      t21 += v7 * b14;
      t22 += v7 * b15;
      v7 = a5[8];
      t8 += v7 * b0;
      t9 += v7 * b1;
      t10 += v7 * b22;
      t11 += v7 * b32;
      t12 += v7 * b42;
      t13 += v7 * b52;
      t14 += v7 * b62;
      t15 += v7 * b72;
      t16 += v7 * b8;
      t17 += v7 * b9;
      t18 += v7 * b10;
      t19 += v7 * b11;
      t20 += v7 * b12;
      t21 += v7 * b13;
      t22 += v7 * b14;
      t23 += v7 * b15;
      v7 = a5[9];
      t9 += v7 * b0;
      t10 += v7 * b1;
      t11 += v7 * b22;
      t12 += v7 * b32;
      t13 += v7 * b42;
      t14 += v7 * b52;
      t15 += v7 * b62;
      t16 += v7 * b72;
      t17 += v7 * b8;
      t18 += v7 * b9;
      t19 += v7 * b10;
      t20 += v7 * b11;
      t21 += v7 * b12;
      t22 += v7 * b13;
      t23 += v7 * b14;
      t24 += v7 * b15;
      v7 = a5[10];
      t10 += v7 * b0;
      t11 += v7 * b1;
      t12 += v7 * b22;
      t13 += v7 * b32;
      t14 += v7 * b42;
      t15 += v7 * b52;
      t16 += v7 * b62;
      t17 += v7 * b72;
      t18 += v7 * b8;
      t19 += v7 * b9;
      t20 += v7 * b10;
      t21 += v7 * b11;
      t22 += v7 * b12;
      t23 += v7 * b13;
      t24 += v7 * b14;
      t25 += v7 * b15;
      v7 = a5[11];
      t11 += v7 * b0;
      t12 += v7 * b1;
      t13 += v7 * b22;
      t14 += v7 * b32;
      t15 += v7 * b42;
      t16 += v7 * b52;
      t17 += v7 * b62;
      t18 += v7 * b72;
      t19 += v7 * b8;
      t20 += v7 * b9;
      t21 += v7 * b10;
      t22 += v7 * b11;
      t23 += v7 * b12;
      t24 += v7 * b13;
      t25 += v7 * b14;
      t26 += v7 * b15;
      v7 = a5[12];
      t12 += v7 * b0;
      t13 += v7 * b1;
      t14 += v7 * b22;
      t15 += v7 * b32;
      t16 += v7 * b42;
      t17 += v7 * b52;
      t18 += v7 * b62;
      t19 += v7 * b72;
      t20 += v7 * b8;
      t21 += v7 * b9;
      t22 += v7 * b10;
      t23 += v7 * b11;
      t24 += v7 * b12;
      t25 += v7 * b13;
      t26 += v7 * b14;
      t27 += v7 * b15;
      v7 = a5[13];
      t13 += v7 * b0;
      t14 += v7 * b1;
      t15 += v7 * b22;
      t16 += v7 * b32;
      t17 += v7 * b42;
      t18 += v7 * b52;
      t19 += v7 * b62;
      t20 += v7 * b72;
      t21 += v7 * b8;
      t22 += v7 * b9;
      t23 += v7 * b10;
      t24 += v7 * b11;
      t25 += v7 * b12;
      t26 += v7 * b13;
      t27 += v7 * b14;
      t28 += v7 * b15;
      v7 = a5[14];
      t14 += v7 * b0;
      t15 += v7 * b1;
      t16 += v7 * b22;
      t17 += v7 * b32;
      t18 += v7 * b42;
      t19 += v7 * b52;
      t20 += v7 * b62;
      t21 += v7 * b72;
      t22 += v7 * b8;
      t23 += v7 * b9;
      t24 += v7 * b10;
      t25 += v7 * b11;
      t26 += v7 * b12;
      t27 += v7 * b13;
      t28 += v7 * b14;
      t29 += v7 * b15;
      v7 = a5[15];
      t15 += v7 * b0;
      t16 += v7 * b1;
      t17 += v7 * b22;
      t18 += v7 * b32;
      t19 += v7 * b42;
      t20 += v7 * b52;
      t21 += v7 * b62;
      t22 += v7 * b72;
      t23 += v7 * b8;
      t24 += v7 * b9;
      t25 += v7 * b10;
      t26 += v7 * b11;
      t27 += v7 * b12;
      t28 += v7 * b13;
      t29 += v7 * b14;
      t30 += v7 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c7 = 1;
      v7 = t0 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t0 = v7 - c7 * 65536;
      v7 = t1 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t1 = v7 - c7 * 65536;
      v7 = t2 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t2 = v7 - c7 * 65536;
      v7 = t3 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t3 = v7 - c7 * 65536;
      v7 = t4 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t4 = v7 - c7 * 65536;
      v7 = t5 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t5 = v7 - c7 * 65536;
      v7 = t6 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t6 = v7 - c7 * 65536;
      v7 = t7 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t7 = v7 - c7 * 65536;
      v7 = t8 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t8 = v7 - c7 * 65536;
      v7 = t9 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t9 = v7 - c7 * 65536;
      v7 = t10 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t10 = v7 - c7 * 65536;
      v7 = t11 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t11 = v7 - c7 * 65536;
      v7 = t12 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t12 = v7 - c7 * 65536;
      v7 = t13 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t13 = v7 - c7 * 65536;
      v7 = t14 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t14 = v7 - c7 * 65536;
      v7 = t15 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t15 = v7 - c7 * 65536;
      t0 += c7 - 1 + 37 * (c7 - 1);
      c7 = 1;
      v7 = t0 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t0 = v7 - c7 * 65536;
      v7 = t1 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t1 = v7 - c7 * 65536;
      v7 = t2 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t2 = v7 - c7 * 65536;
      v7 = t3 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t3 = v7 - c7 * 65536;
      v7 = t4 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t4 = v7 - c7 * 65536;
      v7 = t5 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t5 = v7 - c7 * 65536;
      v7 = t6 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t6 = v7 - c7 * 65536;
      v7 = t7 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t7 = v7 - c7 * 65536;
      v7 = t8 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t8 = v7 - c7 * 65536;
      v7 = t9 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t9 = v7 - c7 * 65536;
      v7 = t10 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t10 = v7 - c7 * 65536;
      v7 = t11 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t11 = v7 - c7 * 65536;
      v7 = t12 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t12 = v7 - c7 * 65536;
      v7 = t13 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t13 = v7 - c7 * 65536;
      v7 = t14 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t14 = v7 - c7 * 65536;
      v7 = t15 + c7 + 65535;
      c7 = Math.floor(v7 / 65536);
      t15 = v7 - c7 * 65536;
      t0 += c7 - 1 + 37 * (c7 - 1);
      o4[0] = t0;
      o4[1] = t1;
      o4[2] = t2;
      o4[3] = t3;
      o4[4] = t4;
      o4[5] = t5;
      o4[6] = t6;
      o4[7] = t7;
      o4[8] = t8;
      o4[9] = t9;
      o4[10] = t10;
      o4[11] = t11;
      o4[12] = t12;
      o4[13] = t13;
      o4[14] = t14;
      o4[15] = t15;
    }
    function square(o4, a5) {
      mul(o4, a5, a5);
    }
    function inv25519(o4, i3) {
      const c7 = gf();
      let a5;
      for (a5 = 0; a5 < 16; a5++) {
        c7[a5] = i3[a5];
      }
      for (a5 = 253; a5 >= 0; a5--) {
        square(c7, c7);
        if (a5 !== 2 && a5 !== 4) {
          mul(c7, c7, i3);
        }
      }
      for (a5 = 0; a5 < 16; a5++) {
        o4[a5] = c7[a5];
      }
    }
    function pow2523(o4, i3) {
      const c7 = gf();
      let a5;
      for (a5 = 0; a5 < 16; a5++) {
        c7[a5] = i3[a5];
      }
      for (a5 = 250; a5 >= 0; a5--) {
        square(c7, c7);
        if (a5 !== 1) {
          mul(c7, c7, i3);
        }
      }
      for (a5 = 0; a5 < 16; a5++) {
        o4[a5] = c7[a5];
      }
    }
    function edadd(p5, q6) {
      const a5 = gf(), b7 = gf(), c7 = gf(), d6 = gf(), e = gf(), f7 = gf(), g5 = gf(), h7 = gf(), t = gf();
      sub(a5, p5[1], p5[0]);
      sub(t, q6[1], q6[0]);
      mul(a5, a5, t);
      add(b7, p5[0], p5[1]);
      add(t, q6[0], q6[1]);
      mul(b7, b7, t);
      mul(c7, p5[3], q6[3]);
      mul(c7, c7, D22);
      mul(d6, p5[2], q6[2]);
      add(d6, d6, d6);
      sub(e, b7, a5);
      sub(f7, d6, c7);
      add(g5, d6, c7);
      add(h7, b7, a5);
      mul(p5[0], e, f7);
      mul(p5[1], h7, g5);
      mul(p5[2], g5, f7);
      mul(p5[3], e, h7);
    }
    function cswap(p5, q6, b7) {
      for (let i3 = 0; i3 < 4; i3++) {
        sel25519(p5[i3], q6[i3], b7);
      }
    }
    function pack(r3, p5) {
      const tx = gf(), ty = gf(), zi3 = gf();
      inv25519(zi3, p5[2]);
      mul(tx, p5[0], zi3);
      mul(ty, p5[1], zi3);
      pack25519(r3, ty);
      r3[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p5, q6, s2) {
      set25519(p5[0], gf0);
      set25519(p5[1], gf1);
      set25519(p5[2], gf1);
      set25519(p5[3], gf0);
      for (let i3 = 255; i3 >= 0; --i3) {
        const b7 = s2[i3 / 8 | 0] >> (i3 & 7) & 1;
        cswap(p5, q6, b7);
        edadd(q6, p5);
        edadd(p5, p5);
        cswap(p5, q6, b7);
      }
    }
    function scalarbase(p5, s2) {
      const q6 = [gf(), gf(), gf(), gf()];
      set25519(q6[0], X3);
      set25519(q6[1], Y4);
      set25519(q6[2], gf1);
      mul(q6[3], X3, Y4);
      scalarmult(p5, q6, s2);
    }
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
      }
      const d6 = (0, sha512_1.hash)(seed);
      d6[0] &= 248;
      d6[31] &= 127;
      d6[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p5 = [gf(), gf(), gf(), gf()];
      scalarbase(p5, d6);
      pack(publicKey, p5);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair3(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair3;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L5 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r3, x10) {
      let carry;
      let i3;
      let j6;
      let k6;
      for (i3 = 63; i3 >= 32; --i3) {
        carry = 0;
        for (j6 = i3 - 32, k6 = i3 - 12; j6 < k6; ++j6) {
          x10[j6] += carry - 16 * x10[i3] * L5[j6 - (i3 - 32)];
          carry = Math.floor((x10[j6] + 128) / 256);
          x10[j6] -= carry * 256;
        }
        x10[j6] += carry;
        x10[i3] = 0;
      }
      carry = 0;
      for (j6 = 0; j6 < 32; j6++) {
        x10[j6] += carry - (x10[31] >> 4) * L5[j6];
        carry = x10[j6] >> 8;
        x10[j6] &= 255;
      }
      for (j6 = 0; j6 < 32; j6++) {
        x10[j6] -= carry * L5[j6];
      }
      for (i3 = 0; i3 < 32; i3++) {
        x10[i3 + 1] += x10[i3] >> 8;
        r3[i3] = x10[i3] & 255;
      }
    }
    function reduce(r3) {
      const x10 = new Float64Array(64);
      for (let i3 = 0; i3 < 64; i3++) {
        x10[i3] = r3[i3];
      }
      for (let i3 = 0; i3 < 64; i3++) {
        r3[i3] = 0;
      }
      modL(r3, x10);
    }
    function sign2(secretKey, message) {
      const x10 = new Float64Array(64);
      const p5 = [gf(), gf(), gf(), gf()];
      const d6 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d6[0] &= 248;
      d6[31] &= 127;
      d6[31] |= 64;
      const signature = new Uint8Array(64);
      signature.set(d6.subarray(32), 32);
      const hs2 = new sha512_1.SHA512();
      hs2.update(signature.subarray(32));
      hs2.update(message);
      const r3 = hs2.digest();
      hs2.clean();
      reduce(r3);
      scalarbase(p5, r3);
      pack(signature, p5);
      hs2.reset();
      hs2.update(signature.subarray(0, 32));
      hs2.update(secretKey.subarray(32));
      hs2.update(message);
      const h7 = hs2.digest();
      reduce(h7);
      for (let i3 = 0; i3 < 32; i3++) {
        x10[i3] = r3[i3];
      }
      for (let i3 = 0; i3 < 32; i3++) {
        for (let j6 = 0; j6 < 32; j6++) {
          x10[i3 + j6] += h7[i3] * d6[j6];
        }
      }
      modL(signature.subarray(32), x10);
      return signature;
    }
    exports.sign = sign2;
    function unpackneg(r3, p5) {
      const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r3[2], gf1);
      unpack25519(r3[1], p5);
      square(num, r3[1]);
      mul(den, num, D7);
      sub(num, num, r3[2]);
      add(den, r3[2], den);
      square(den2, den);
      square(den4, den2);
      mul(den6, den4, den2);
      mul(t, den6, num);
      mul(t, t, den);
      pow2523(t, t);
      mul(t, t, num);
      mul(t, t, den);
      mul(t, t, den);
      mul(r3[0], t, den);
      square(chk, r3[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        mul(r3[0], r3[0], I6);
      }
      square(chk, r3[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r3[0]) === p5[31] >> 7) {
        sub(r3[0], gf0, r3[0]);
      }
      mul(r3[3], r3[0], r3[1]);
      return 0;
    }
    function verify2(publicKey, message, signature) {
      const t = new Uint8Array(32);
      const p5 = [gf(), gf(), gf(), gf()];
      const q6 = [gf(), gf(), gf(), gf()];
      if (signature.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q6, publicKey)) {
        return false;
      }
      const hs2 = new sha512_1.SHA512();
      hs2.update(signature.subarray(0, 32));
      hs2.update(publicKey);
      hs2.update(message);
      const h7 = hs2.digest();
      reduce(h7);
      scalarmult(p5, q6, h7);
      scalarbase(q6, signature.subarray(32));
      edadd(p5, q6);
      pack(t, p5);
      if (verify32(signature, t)) {
        return false;
      }
      return true;
    }
    exports.verify = verify2;
    function convertPublicKeyToX25519(publicKey) {
      let q6 = [gf(), gf(), gf(), gf()];
      if (unpackneg(q6, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a5 = gf();
      let b7 = gf();
      let y9 = q6[1];
      add(a5, gf1, y9);
      sub(b7, gf1, y9);
      inv25519(b7, b7);
      mul(a5, a5, b7);
      let z10 = new Uint8Array(32);
      pack25519(z10, a5);
      return z10;
    }
    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX25519(secretKey) {
      const d6 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d6[0] &= 248;
      d6[31] &= 127;
      d6[31] |= 64;
      const o4 = new Uint8Array(d6.subarray(0, 32));
      (0, wipe_1.wipe)(d6);
      return o4;
    }
    exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/package.json
var require_package2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.7",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j6, w5;
        var off = 0;
        if (endian === "be") {
          for (i3 = number.length - 1, j6 = 0; i3 >= 0; i3 -= 3) {
            w5 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
            this.words[j6] |= w5 << off & 67108863;
            this.words[j6 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j6 = 0; i3 < number.length; i3 += 3) {
            w5 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
            this.words[j6] |= w5 << off & 67108863;
            this.words[j6 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c7 = string.charCodeAt(index);
        if (c7 >= 65 && c7 <= 70) {
          return c7 - 55;
        } else if (c7 >= 97 && c7 <= 102) {
          return c7 - 87;
        } else {
          return c7 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r3 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r3;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var off = 0;
        var j6 = 0;
        var w5;
        if (endian === "be") {
          for (i3 = number.length - 1; i3 >= start; i3 -= 2) {
            w5 = parseHexByte(number, start, i3) << off;
            this.words[j6] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j6 += 1;
              this.words[j6] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i3 = parseLength % 2 === 0 ? start + 1 : start; i3 < number.length; i3 += 2) {
            w5 = parseHexByte(number, start, i3) << off;
            this.words[j6] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j6 += 1;
              this.words[j6] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c7 = str.charCodeAt(i3) - 48;
          r3 *= mul;
          if (c7 >= 49) {
            r3 += c7 - 49 + 10;
          } else if (c7 >= 17) {
            r3 += c7 - 17 + 10;
          } else {
            r3 += c7;
          }
        }
        return r3;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i3 = start; i3 < end; i3 += limbLen) {
          word = parseBase(number, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i3, number.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r3 = new BN(null);
        this.copy(r3);
        return r3;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w5 = this.words[i3];
            var word = ((w5 << off | carry) & 16777215).toString(16);
            carry = w5 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c7 = this.clone();
          c7.negative = 0;
          while (!c7.isZero()) {
            var r3 = c7.modn(groupBase).toString(base);
            c7 = c7.idivn(groupBase);
            if (!c7.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b7, i3;
        var q6 = this.clone();
        if (!littleEndian) {
          for (i3 = 0; i3 < reqLength - byteLength; i3++) {
            res[i3] = 0;
          }
          for (i3 = 0; !q6.isZero(); i3++) {
            b7 = q6.andln(255);
            q6.iushrn(8);
            res[reqLength - i3 - 1] = b7;
          }
        } else {
          for (i3 = 0; !q6.isZero(); i3++) {
            b7 = q6.andln(255);
            q6.iushrn(8);
            res[i3] = b7;
          }
          for (; i3 < reqLength; i3++) {
            res[i3] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w5) {
          return 32 - Math.clz32(w5);
        };
      } else {
        BN.prototype._countBits = function _countBits(w5) {
          var t = w5;
          var r3 = 0;
          if (t >= 4096) {
            r3 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r3 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r3 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r3 += 2;
            t >>>= 2;
          }
          return r3 + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w5) {
        if (w5 === 0) return 26;
        var t = w5;
        var r3 = 0;
        if ((t & 8191) === 0) {
          r3 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r3 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r3 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r3 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN.prototype.bitLength = function bitLength() {
        var w5 = this.words[this.length - 1];
        var hi4 = this._countBits(w5);
        return (this.length - 1) * 26 + hi4;
      };
      function toBitArray(num) {
        var w5 = new Array(num.bitLength());
        for (var bit = 0; bit < w5.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w5[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w5;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r3 = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b7 = this._zeroBits(this.words[i3]);
          r3 += b7;
          if (b7 !== 26) break;
        }
        return r3;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or5(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b7;
        if (this.length > num.length) {
          b7 = num;
        } else {
          b7 = this;
        }
        for (var i3 = 0; i3 < b7.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b7.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a5;
        var b7;
        if (this.length > num.length) {
          a5 = this;
          b7 = num;
        } else {
          a5 = num;
          b7 = this;
        }
        for (var i3 = 0; i3 < b7.length; i3++) {
          this.words[i3] = a5.words[i3] ^ b7.words[i3];
        }
        if (this !== a5) {
          for (; i3 < a5.length; i3++) {
            this.words[i3] = a5.words[i3];
          }
        }
        this.length = a5.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a5, b7;
        if (this.length > num.length) {
          a5 = this;
          b7 = num;
        } else {
          a5 = num;
          b7 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b7.length; i3++) {
          r3 = (a5.words[i3] | 0) + (b7.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i3 < a5.length; i3++) {
          r3 = (a5.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a5.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a5 !== this) {
          for (; i3 < a5.length; i3++) {
            this.words[i3] = a5.words[i3];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a5, b7;
        if (cmp > 0) {
          a5 = this;
          b7 = num;
        } else {
          a5 = num;
          b7 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b7.length; i3++) {
          r3 = (a5.words[i3] | 0) - (b7.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        for (; carry !== 0 && i3 < a5.length; i3++) {
          r3 = (a5.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        if (carry === 0 && i3 < a5.length && a5 !== this) {
          for (; i3 < a5.length; i3++) {
            this.words[i3] = a5.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a5 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a5 = self2.words[0] | 0;
        var b7 = num.words[0] | 0;
        var r3 = a5 * b7;
        var lo3 = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo3;
        for (var k6 = 1; k6 < len; k6++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k6, num.length - 1);
          for (var j6 = Math.max(0, k6 - self2.length + 1); j6 <= maxJ; j6++) {
            var i3 = k6 - j6 | 0;
            a5 = self2.words[i3] | 0;
            b7 = num.words[j6] | 0;
            r3 = a5 * b7 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k6] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k6] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a5 = self2.words;
        var b7 = num.words;
        var o4 = out.words;
        var c7 = 0;
        var lo3;
        var mid;
        var hi4;
        var a0 = a5[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a5[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a5[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a5[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a5[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a5[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a6 = a5[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a5[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a5[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a5[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b7[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b7[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b7[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b7[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b7[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b7[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b62 = b7[6] | 0;
        var bl6 = b62 & 8191;
        var bh6 = b62 >>> 13;
        var b72 = b7[7] | 0;
        var bl7 = b72 & 8191;
        var bh7 = b72 >>> 13;
        var b8 = b7[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b7[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo3 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi4 = Math.imul(ah0, bh0);
        var w0 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo3 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi4 = Math.imul(ah1, bh0);
        lo3 = lo3 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi4 = hi4 + Math.imul(ah0, bh1) | 0;
        var w1 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo3 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi4 = Math.imul(ah2, bh0);
        lo3 = lo3 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi4 = hi4 + Math.imul(ah1, bh1) | 0;
        lo3 = lo3 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi4 = hi4 + Math.imul(ah0, bh2) | 0;
        var w22 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo3 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi4 = Math.imul(ah3, bh0);
        lo3 = lo3 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi4 = hi4 + Math.imul(ah2, bh1) | 0;
        lo3 = lo3 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi4 = hi4 + Math.imul(ah1, bh2) | 0;
        lo3 = lo3 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi4 = hi4 + Math.imul(ah0, bh3) | 0;
        var w32 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo3 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi4 = Math.imul(ah4, bh0);
        lo3 = lo3 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi4 = hi4 + Math.imul(ah3, bh1) | 0;
        lo3 = lo3 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi4 = hi4 + Math.imul(ah2, bh2) | 0;
        lo3 = lo3 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi4 = hi4 + Math.imul(ah1, bh3) | 0;
        lo3 = lo3 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi4 = hi4 + Math.imul(ah0, bh4) | 0;
        var w42 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo3 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi4 = Math.imul(ah5, bh0);
        lo3 = lo3 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi4 = hi4 + Math.imul(ah4, bh1) | 0;
        lo3 = lo3 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi4 = hi4 + Math.imul(ah3, bh2) | 0;
        lo3 = lo3 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi4 = hi4 + Math.imul(ah2, bh3) | 0;
        lo3 = lo3 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi4 = hi4 + Math.imul(ah1, bh4) | 0;
        lo3 = lo3 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi4 = hi4 + Math.imul(ah0, bh5) | 0;
        var w5 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo3 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi4 = Math.imul(ah6, bh0);
        lo3 = lo3 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi4 = hi4 + Math.imul(ah5, bh1) | 0;
        lo3 = lo3 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi4 = hi4 + Math.imul(ah4, bh2) | 0;
        lo3 = lo3 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi4 = hi4 + Math.imul(ah3, bh3) | 0;
        lo3 = lo3 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi4 = hi4 + Math.imul(ah2, bh4) | 0;
        lo3 = lo3 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi4 = hi4 + Math.imul(ah1, bh5) | 0;
        lo3 = lo3 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi4 = hi4 + Math.imul(ah0, bh6) | 0;
        var w6 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo3 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi4 = Math.imul(ah7, bh0);
        lo3 = lo3 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi4 = hi4 + Math.imul(ah6, bh1) | 0;
        lo3 = lo3 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi4 = hi4 + Math.imul(ah5, bh2) | 0;
        lo3 = lo3 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi4 = hi4 + Math.imul(ah4, bh3) | 0;
        lo3 = lo3 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi4 = hi4 + Math.imul(ah3, bh4) | 0;
        lo3 = lo3 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi4 = hi4 + Math.imul(ah2, bh5) | 0;
        lo3 = lo3 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi4 = hi4 + Math.imul(ah1, bh6) | 0;
        lo3 = lo3 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi4 = hi4 + Math.imul(ah0, bh7) | 0;
        var w7 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo3 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi4 = Math.imul(ah8, bh0);
        lo3 = lo3 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi4 = hi4 + Math.imul(ah7, bh1) | 0;
        lo3 = lo3 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi4 = hi4 + Math.imul(ah6, bh2) | 0;
        lo3 = lo3 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi4 = hi4 + Math.imul(ah5, bh3) | 0;
        lo3 = lo3 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi4 = hi4 + Math.imul(ah4, bh4) | 0;
        lo3 = lo3 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi4 = hi4 + Math.imul(ah3, bh5) | 0;
        lo3 = lo3 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi4 = hi4 + Math.imul(ah2, bh6) | 0;
        lo3 = lo3 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi4 = hi4 + Math.imul(ah1, bh7) | 0;
        lo3 = lo3 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi4 = hi4 + Math.imul(ah0, bh8) | 0;
        var w8 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo3 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi4 = Math.imul(ah9, bh0);
        lo3 = lo3 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi4 = hi4 + Math.imul(ah8, bh1) | 0;
        lo3 = lo3 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi4 = hi4 + Math.imul(ah7, bh2) | 0;
        lo3 = lo3 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi4 = hi4 + Math.imul(ah6, bh3) | 0;
        lo3 = lo3 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi4 = hi4 + Math.imul(ah5, bh4) | 0;
        lo3 = lo3 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi4 = hi4 + Math.imul(ah4, bh5) | 0;
        lo3 = lo3 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi4 = hi4 + Math.imul(ah3, bh6) | 0;
        lo3 = lo3 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi4 = hi4 + Math.imul(ah2, bh7) | 0;
        lo3 = lo3 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi4 = hi4 + Math.imul(ah1, bh8) | 0;
        lo3 = lo3 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi4 = hi4 + Math.imul(ah0, bh9) | 0;
        var w9 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo3 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi4 = Math.imul(ah9, bh1);
        lo3 = lo3 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi4 = hi4 + Math.imul(ah8, bh2) | 0;
        lo3 = lo3 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi4 = hi4 + Math.imul(ah7, bh3) | 0;
        lo3 = lo3 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi4 = hi4 + Math.imul(ah6, bh4) | 0;
        lo3 = lo3 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi4 = hi4 + Math.imul(ah5, bh5) | 0;
        lo3 = lo3 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi4 = hi4 + Math.imul(ah4, bh6) | 0;
        lo3 = lo3 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi4 = hi4 + Math.imul(ah3, bh7) | 0;
        lo3 = lo3 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi4 = hi4 + Math.imul(ah2, bh8) | 0;
        lo3 = lo3 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi4 = hi4 + Math.imul(ah1, bh9) | 0;
        var w10 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo3 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi4 = Math.imul(ah9, bh2);
        lo3 = lo3 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi4 = hi4 + Math.imul(ah8, bh3) | 0;
        lo3 = lo3 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi4 = hi4 + Math.imul(ah7, bh4) | 0;
        lo3 = lo3 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi4 = hi4 + Math.imul(ah6, bh5) | 0;
        lo3 = lo3 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi4 = hi4 + Math.imul(ah5, bh6) | 0;
        lo3 = lo3 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi4 = hi4 + Math.imul(ah4, bh7) | 0;
        lo3 = lo3 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi4 = hi4 + Math.imul(ah3, bh8) | 0;
        lo3 = lo3 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi4 = hi4 + Math.imul(ah2, bh9) | 0;
        var w11 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo3 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi4 = Math.imul(ah9, bh3);
        lo3 = lo3 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi4 = hi4 + Math.imul(ah8, bh4) | 0;
        lo3 = lo3 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi4 = hi4 + Math.imul(ah7, bh5) | 0;
        lo3 = lo3 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi4 = hi4 + Math.imul(ah6, bh6) | 0;
        lo3 = lo3 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi4 = hi4 + Math.imul(ah5, bh7) | 0;
        lo3 = lo3 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi4 = hi4 + Math.imul(ah4, bh8) | 0;
        lo3 = lo3 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi4 = hi4 + Math.imul(ah3, bh9) | 0;
        var w12 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo3 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi4 = Math.imul(ah9, bh4);
        lo3 = lo3 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi4 = hi4 + Math.imul(ah8, bh5) | 0;
        lo3 = lo3 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi4 = hi4 + Math.imul(ah7, bh6) | 0;
        lo3 = lo3 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi4 = hi4 + Math.imul(ah6, bh7) | 0;
        lo3 = lo3 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi4 = hi4 + Math.imul(ah5, bh8) | 0;
        lo3 = lo3 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi4 = hi4 + Math.imul(ah4, bh9) | 0;
        var w13 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo3 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi4 = Math.imul(ah9, bh5);
        lo3 = lo3 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi4 = hi4 + Math.imul(ah8, bh6) | 0;
        lo3 = lo3 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi4 = hi4 + Math.imul(ah7, bh7) | 0;
        lo3 = lo3 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi4 = hi4 + Math.imul(ah6, bh8) | 0;
        lo3 = lo3 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi4 = hi4 + Math.imul(ah5, bh9) | 0;
        var w14 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo3 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi4 = Math.imul(ah9, bh6);
        lo3 = lo3 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi4 = hi4 + Math.imul(ah8, bh7) | 0;
        lo3 = lo3 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi4 = hi4 + Math.imul(ah7, bh8) | 0;
        lo3 = lo3 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi4 = hi4 + Math.imul(ah6, bh9) | 0;
        var w15 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo3 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi4 = Math.imul(ah9, bh7);
        lo3 = lo3 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi4 = hi4 + Math.imul(ah8, bh8) | 0;
        lo3 = lo3 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi4 = hi4 + Math.imul(ah7, bh9) | 0;
        var w16 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo3 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi4 = Math.imul(ah9, bh8);
        lo3 = lo3 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi4 = hi4 + Math.imul(ah8, bh9) | 0;
        var w17 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo3 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi4 = Math.imul(ah9, bh9);
        var w18 = (c7 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c7 = (hi4 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w0;
        o4[1] = w1;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w5;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w12;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c7 !== 0) {
          o4[19] = c7;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k6 = 0; k6 < out.length - 1; k6++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k6, num.length - 1);
          for (var j6 = Math.max(0, k6 - self2.length + 1); j6 <= maxJ; j6++) {
            var i3 = k6 - j6;
            var a5 = self2.words[i3] | 0;
            var b7 = num.words[j6] | 0;
            var r3 = a5 * b7;
            var lo3 = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo3 = lo3 + rword | 0;
            rword = lo3 & 67108863;
            ncarry = ncarry + (lo3 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k6] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k6] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x10, y9) {
        this.x = x10;
        this.y = y9;
      }
      FFTM.prototype.makeRBT = function makeRBT(N5) {
        var t = new Array(N5);
        var l7 = BN.prototype._countBits(N5) - 1;
        for (var i3 = 0; i3 < N5; i3++) {
          t[i3] = this.revBin(i3, l7, N5);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x10, l7, N5) {
        if (x10 === 0 || x10 === N5 - 1) return x10;
        var rb = 0;
        for (var i3 = 0; i3 < l7; i3++) {
          rb |= (x10 & 1) << l7 - i3 - 1;
          x10 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N5) {
        for (var i3 = 0; i3 < N5; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N5, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N5);
        for (var s2 = 1; s2 < N5; s2 <<= 1) {
          var l7 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l7);
          var itwdf = Math.sin(2 * Math.PI / l7);
          for (var p5 = 0; p5 < N5; p5 += l7) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j6 = 0; j6 < s2; j6++) {
              var re5 = rtws[p5 + j6];
              var ie6 = itws[p5 + j6];
              var ro4 = rtws[p5 + j6 + s2];
              var io3 = itws[p5 + j6 + s2];
              var rx = rtwdf_ * ro4 - itwdf_ * io3;
              io3 = rtwdf_ * io3 + itwdf_ * ro4;
              ro4 = rx;
              rtws[p5 + j6] = re5 + ro4;
              itws[p5 + j6] = ie6 + io3;
              rtws[p5 + j6 + s2] = re5 - ro4;
              itws[p5 + j6 + s2] = ie6 - io3;
              if (j6 !== l7) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m2) {
        var N5 = Math.max(m2, n4) | 1;
        var odd = N5 & 1;
        var i3 = 0;
        for (N5 = N5 / 2 | 0; N5; N5 = N5 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N5) {
        if (N5 <= 1) return;
        for (var i3 = 0; i3 < N5 / 2; i3++) {
          var t = rws[i3];
          rws[i3] = rws[N5 - i3 - 1];
          rws[N5 - i3 - 1] = t;
          t = iws[i3];
          iws[i3] = -iws[N5 - i3 - 1];
          iws[N5 - i3 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws3, N5) {
        var carry = 0;
        for (var i3 = 0; i3 < N5 / 2; i3++) {
          var w5 = Math.round(ws3[2 * i3 + 1] / N5) * 8192 + Math.round(ws3[2 * i3] / N5) + carry;
          ws3[i3] = w5 & 67108863;
          if (w5 < 67108864) {
            carry = 0;
          } else {
            carry = w5 / 67108864 | 0;
          }
        }
        return ws3;
      };
      FFTM.prototype.convert13b = function convert13b(ws3, len, rws, N5) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws3[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N5; ++i3) {
          rws[i3] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N5) {
        var ph = new Array(N5);
        for (var i3 = 0; i3 < N5; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x10, y9, out) {
        var N5 = 2 * this.guessLen13b(x10.length, y9.length);
        var rbt = this.makeRBT(N5);
        var _6 = this.stub(N5);
        var rws = new Array(N5);
        var rwst = new Array(N5);
        var iwst = new Array(N5);
        var nrws = new Array(N5);
        var nrwst = new Array(N5);
        var niwst = new Array(N5);
        var rmws = out.words;
        rmws.length = N5;
        this.convert13b(x10.words, x10.length, rws, N5);
        this.convert13b(y9.words, y9.length, nrws, N5);
        this.transform(rws, _6, rwst, iwst, N5, rbt);
        this.transform(nrws, _6, nrwst, niwst, N5, rbt);
        for (var i3 = 0; i3 < N5; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N5);
        this.transform(rwst, iwst, rmws, _6, N5, rbt);
        this.conjugate(rmws, _6, N5);
        this.normalize13b(rmws, N5);
        out.negative = x10.negative ^ y9.negative;
        out.length = x10.length + y9.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w5 = (this.words[i3] | 0) * num;
          var lo3 = (w5 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w5 / 67108864 | 0;
          carry += lo3 >>> 26;
          this.words[i3] = lo3 & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w5 = toBitArray(num);
        if (w5.length === 0) return new BN(1);
        var res = this;
        for (var i3 = 0; i3 < w5.length; i3++, res = res.sqr()) {
          if (w5[i3] !== 0) break;
        }
        if (++i3 < w5.length) {
          for (var q6 = res.sqr(); i3 < w5.length; i3++, q6 = q6.sqr()) {
            if (w5[i3] === 0) continue;
            res = res.mul(q6);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i3;
        if (r3 !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c7 = (this.words[i3] | 0) - newCarry << r3;
            this.words[i3] = c7 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s2] = this.words[i3];
          }
          for (i3 = 0; i3 < s2; i3++) {
            this.words[i3] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h7;
        if (hint) {
          h7 = (hint - hint % 26) / 26;
        } else {
          h7 = 0;
        }
        var r3 = bits % 26;
        var s2 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h7 -= s2;
        h7 = Math.max(0, h7);
        if (maskedWords) {
          for (var i3 = 0; i3 < s2; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h7); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q6 = 1 << r3;
        if (this.length <= s2) return false;
        var w5 = this.words[s2];
        return !!(w5 & q6);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r3 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i3;
        this._expand(len);
        var w5;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w5 = (this.words[i3 + shift] | 0) + carry;
          var right = (num.words[i3] | 0) * mul;
          w5 -= right & 67108863;
          carry = (w5 >> 26) - (right / 67108864 | 0);
          this.words[i3 + shift] = w5 & 67108863;
        }
        for (; i3 < this.length - shift; i3++) {
          w5 = (this.words[i3 + shift] | 0) + carry;
          carry = w5 >> 26;
          this.words[i3 + shift] = w5 & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w5 = -(this.words[i3] | 0) + carry;
          carry = w5 >> 26;
          this.words[i3] = w5 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a5 = this.clone();
        var b7 = num;
        var bhi = b7.words[b7.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b7 = b7.ushln(shift);
          a5.iushln(shift);
          bhi = b7.words[b7.length - 1] | 0;
        }
        var m2 = a5.length - b7.length;
        var q6;
        if (mode !== "mod") {
          q6 = new BN(null);
          q6.length = m2 + 1;
          q6.words = new Array(q6.length);
          for (var i3 = 0; i3 < q6.length; i3++) {
            q6.words[i3] = 0;
          }
        }
        var diff = a5.clone()._ishlnsubmul(b7, 1, m2);
        if (diff.negative === 0) {
          a5 = diff;
          if (q6) {
            q6.words[m2] = 1;
          }
        }
        for (var j6 = m2 - 1; j6 >= 0; j6--) {
          var qj = (a5.words[b7.length + j6] | 0) * 67108864 + (a5.words[b7.length + j6 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a5._ishlnsubmul(b7, qj, j6);
          while (a5.negative !== 0) {
            qj--;
            a5.negative = 0;
            a5._ishlnsubmul(b7, 1, j6);
            if (!a5.isZero()) {
              a5.negative ^= 1;
            }
          }
          if (q6) {
            q6.words[j6] = qj;
          }
        }
        if (q6) {
          q6.strip();
        }
        a5.strip();
        if (mode !== "div" && shift !== 0) {
          a5.iushrn(shift);
        }
        return {
          div: q6 || null,
          mod: a5
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p5 * acc + (this.words[i3] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w5 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w5 / num | 0;
          carry = w5 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p5) {
        assert(p5.negative === 0);
        assert(!p5.isZero());
        var x10 = this;
        var y9 = p5.clone();
        if (x10.negative !== 0) {
          x10 = x10.umod(p5);
        } else {
          x10 = x10.clone();
        }
        var A4 = new BN(1);
        var B6 = new BN(0);
        var C6 = new BN(0);
        var D7 = new BN(1);
        var g5 = 0;
        while (x10.isEven() && y9.isEven()) {
          x10.iushrn(1);
          y9.iushrn(1);
          ++g5;
        }
        var yp = y9.clone();
        var xp = x10.clone();
        while (!x10.isZero()) {
          for (var i3 = 0, im = 1; (x10.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1) ;
          if (i3 > 0) {
            x10.iushrn(i3);
            while (i3-- > 0) {
              if (A4.isOdd() || B6.isOdd()) {
                A4.iadd(yp);
                B6.isub(xp);
              }
              A4.iushrn(1);
              B6.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (y9.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1) ;
          if (j6 > 0) {
            y9.iushrn(j6);
            while (j6-- > 0) {
              if (C6.isOdd() || D7.isOdd()) {
                C6.iadd(yp);
                D7.isub(xp);
              }
              C6.iushrn(1);
              D7.iushrn(1);
            }
          }
          if (x10.cmp(y9) >= 0) {
            x10.isub(y9);
            A4.isub(C6);
            B6.isub(D7);
          } else {
            y9.isub(x10);
            C6.isub(A4);
            D7.isub(B6);
          }
        }
        return {
          a: C6,
          b: D7,
          gcd: y9.iushln(g5)
        };
      };
      BN.prototype._invmp = function _invmp(p5) {
        assert(p5.negative === 0);
        assert(!p5.isZero());
        var a5 = this;
        var b7 = p5.clone();
        if (a5.negative !== 0) {
          a5 = a5.umod(p5);
        } else {
          a5 = a5.clone();
        }
        var x1 = new BN(1);
        var x22 = new BN(0);
        var delta = b7.clone();
        while (a5.cmpn(1) > 0 && b7.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a5.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1) ;
          if (i3 > 0) {
            a5.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (b7.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1) ;
          if (j6 > 0) {
            b7.iushrn(j6);
            while (j6-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a5.cmp(b7) >= 0) {
            a5.isub(b7);
            x1.isub(x22);
          } else {
            b7.isub(a5);
            x22.isub(x1);
          }
        }
        var res;
        if (a5.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a5 = this.clone();
        var b7 = num.clone();
        a5.negative = 0;
        b7.negative = 0;
        for (var shift = 0; a5.isEven() && b7.isEven(); shift++) {
          a5.iushrn(1);
          b7.iushrn(1);
        }
        do {
          while (a5.isEven()) {
            a5.iushrn(1);
          }
          while (b7.isEven()) {
            b7.iushrn(1);
          }
          var r3 = a5.cmp(b7);
          if (r3 < 0) {
            var t = a5;
            a5 = b7;
            b7 = t;
          } else if (r3 === 0 || b7.cmpn(1) === 0) {
            break;
          }
          a5.isub(b7);
        } while (true);
        return b7.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q6 = 1 << r3;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q6;
          return this;
        }
        var carry = q6;
        for (var i3 = s2; carry !== 0 && i3 < this.length; i3++) {
          var w5 = this.words[i3] | 0;
          w5 += carry;
          carry = w5 >>> 26;
          w5 &= 67108863;
          this.words[i3] = w5;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w5 = this.words[0] | 0;
          res = w5 === num ? 0 : w5 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a5 = this.words[i3] | 0;
          var b7 = num.words[i3] | 0;
          if (a5 === b7) continue;
          if (a5 < b7) {
            res = -1;
          } else if (a5 > b7) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt6(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt4(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next = input.words[i3] | 0;
          input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo3 = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w5 = num.words[i3] | 0;
          lo3 += w5 * 977;
          num.words[i3] = lo3 & 67108863;
          lo3 = w5 * 64 + (lo3 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi4 = (num.words[i3] | 0) * 19 + carry;
          var lo3 = hi4 & 67108863;
          hi4 >>>= 26;
          num.words[i3] = lo3;
          carry = hi4;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN._prime(m2);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m2.gtn(1), "modulus must be greater than 1");
          this.m = m2;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a5) {
        assert(a5.negative === 0, "red works only with positives");
        assert(a5.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a5, b7) {
        assert((a5.negative | b7.negative) === 0, "red works only with positives");
        assert(
          a5.red && a5.red === b7.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a5) {
        if (this.prime) return this.prime.ireduce(a5)._forceRed(this);
        return a5.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a5) {
        if (a5.isZero()) {
          return a5.clone();
        }
        return this.m.sub(a5)._forceRed(this);
      };
      Red.prototype.add = function add(a5, b7) {
        this._verify2(a5, b7);
        var res = a5.add(b7);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a5, b7) {
        this._verify2(a5, b7);
        var res = a5.iadd(b7);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a5, b7) {
        this._verify2(a5, b7);
        var res = a5.sub(b7);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a5, b7) {
        this._verify2(a5, b7);
        var res = a5.isub(b7);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a5, num) {
        this._verify1(a5);
        return this.imod(a5.ushln(num));
      };
      Red.prototype.imul = function imul(a5, b7) {
        this._verify2(a5, b7);
        return this.imod(a5.imul(b7));
      };
      Red.prototype.mul = function mul(a5, b7) {
        this._verify2(a5, b7);
        return this.imod(a5.mul(b7));
      };
      Red.prototype.isqr = function isqr(a5) {
        return this.imul(a5, a5.clone());
      };
      Red.prototype.sqr = function sqr(a5) {
        return this.mul(a5, a5);
      };
      Red.prototype.sqrt = function sqrt(a5) {
        if (a5.isZero()) return a5.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a5, pow);
        }
        var q6 = this.m.subn(1);
        var s2 = 0;
        while (!q6.isZero() && q6.andln(1) === 0) {
          s2++;
          q6.iushrn(1);
        }
        assert(!q6.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z10 = this.m.bitLength();
        z10 = new BN(2 * z10 * z10).toRed(this);
        while (this.pow(z10, lpow).cmp(nOne) !== 0) {
          z10.redIAdd(nOne);
        }
        var c7 = this.pow(z10, q6);
        var r3 = this.pow(a5, q6.addn(1).iushrn(1));
        var t = this.pow(a5, q6);
        var m2 = s2;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert(i3 < m2);
          var b7 = this.pow(c7, new BN(1).iushln(m2 - i3 - 1));
          r3 = r3.redMul(b7);
          c7 = b7.redSqr();
          t = t.redMul(c7);
          m2 = i3;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a5) {
        var inv = a5._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a5, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a5.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a5;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a5);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j6 = start - 1; j6 >= 0; j6--) {
            var bit = word >> j6 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j6 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        Red.call(this, m2);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a5, b7) {
        if (a5.isZero() || b7.isZero()) {
          a5.words[0] = 0;
          a5.length = 1;
          return a5;
        }
        var t = a5.imul(b7);
        var c7 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t.isub(c7).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a5, b7) {
        if (a5.isZero() || b7.isZero()) return new BN(0)._forceRed(this);
        var t = a5.mul(b7);
        var c7 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t.isub(c7).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a5) {
        var res = this.imod(a5._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/utils.js
var require_utils4 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w5, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i3;
      for (i3 = 0; i3 < naf.length; i3 += 1) {
        naf[i3] = 0;
      }
      var ws3 = 1 << w5 + 1;
      var k6 = num.clone();
      for (i3 = 0; i3 < naf.length; i3++) {
        var z10;
        var mod = k6.andln(ws3 - 1);
        if (k6.isOdd()) {
          if (mod > (ws3 >> 1) - 1)
            z10 = (ws3 >> 1) - mod;
          else
            z10 = mod;
          k6.isubn(z10);
        } else {
          z10 = 0;
        }
        naf[i3] = z10;
        k6.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/base.js
var require_base2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p5, k6) {
      assert(p5.precomputed);
      var doubles = p5._getDoubles();
      var naf = getNAF(k6, 1, this._bitLength);
      var I6 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I6 /= 3;
      var repr = [];
      var j6;
      var nafW;
      for (j6 = 0; j6 < naf.length; j6 += doubles.step) {
        nafW = 0;
        for (var l7 = j6 + doubles.step - 1; l7 >= j6; l7--)
          nafW = (nafW << 1) + naf[l7];
        repr.push(nafW);
      }
      var a5 = this.jpoint(null, null, null);
      var b7 = this.jpoint(null, null, null);
      for (var i3 = I6; i3 > 0; i3--) {
        for (j6 = 0; j6 < repr.length; j6++) {
          nafW = repr[j6];
          if (nafW === i3)
            b7 = b7.mixedAdd(doubles.points[j6]);
          else if (nafW === -i3)
            b7 = b7.mixedAdd(doubles.points[j6].neg());
        }
        a5 = a5.add(b7);
      }
      return a5.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p5, k6) {
      var w5 = 4;
      var nafPoints = p5._getNAFPoints(w5);
      w5 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k6, w5, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i3 = naf.length - 1; i3 >= 0; i3--) {
        for (var l7 = 0; i3 >= 0 && naf[i3] === 0; i3--)
          l7++;
        if (i3 >= 0)
          l7++;
        acc = acc.dblp(l7);
        if (i3 < 0)
          break;
        var z10 = naf[i3];
        assert(z10 !== 0);
        if (p5.type === "affine") {
          if (z10 > 0)
            acc = acc.mixedAdd(wnd[z10 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z10 - 1 >> 1].neg());
        } else {
          if (z10 > 0)
            acc = acc.add(wnd[z10 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z10 - 1 >> 1].neg());
        }
      }
      return p5.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i3;
      var j6;
      var p5;
      for (i3 = 0; i3 < len; i3++) {
        p5 = points[i3];
        var nafPoints = p5._getNAFPoints(defW);
        wndWidth[i3] = nafPoints.wnd;
        wnd[i3] = nafPoints.points;
      }
      for (i3 = len - 1; i3 >= 1; i3 -= 2) {
        var a5 = i3 - 1;
        var b7 = i3;
        if (wndWidth[a5] !== 1 || wndWidth[b7] !== 1) {
          naf[a5] = getNAF(coeffs[a5], wndWidth[a5], this._bitLength);
          naf[b7] = getNAF(coeffs[b7], wndWidth[b7], this._bitLength);
          max = Math.max(naf[a5].length, max);
          max = Math.max(naf[b7].length, max);
          continue;
        }
        var comb = [
          points[a5],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b7]
          /* 7 */
        ];
        if (points[a5].y.cmp(points[b7].y) === 0) {
          comb[1] = points[a5].add(points[b7]);
          comb[2] = points[a5].toJ().mixedAdd(points[b7].neg());
        } else if (points[a5].y.cmp(points[b7].y.redNeg()) === 0) {
          comb[1] = points[a5].toJ().mixedAdd(points[b7]);
          comb[2] = points[a5].add(points[b7].neg());
        } else {
          comb[1] = points[a5].toJ().mixedAdd(points[b7]);
          comb[2] = points[a5].toJ().mixedAdd(points[b7].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a5], coeffs[b7]);
        max = Math.max(jsf[0].length, max);
        naf[a5] = new Array(max);
        naf[b7] = new Array(max);
        for (j6 = 0; j6 < max; j6++) {
          var ja = jsf[0][j6] | 0;
          var jb = jsf[1][j6] | 0;
          naf[a5][j6] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b7][j6] = 0;
          wnd[a5] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i3 = max; i3 >= 0; i3--) {
        var k6 = 0;
        while (i3 >= 0) {
          var zero = true;
          for (j6 = 0; j6 < len; j6++) {
            tmp[j6] = naf[j6][i3] | 0;
            if (tmp[j6] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k6++;
          i3--;
        }
        if (i3 >= 0)
          k6++;
        acc = acc.dblp(k6);
        if (i3 < 0)
          break;
        for (j6 = 0; j6 < len; j6++) {
          var z10 = tmp[j6];
          p5;
          if (z10 === 0)
            continue;
          else if (z10 > 0)
            p5 = wnd[j6][z10 - 1 >> 1];
          else if (z10 < 0)
            p5 = wnd[j6][-z10 - 1 >> 1].neg();
          if (p5.type === "affine")
            acc = acc.mixedAdd(p5);
          else
            acc = acc.add(p5);
        }
      }
      for (i3 = 0; i3 < len; i3++)
        wnd[i3] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x10 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x10);
      return [4].concat(x10, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k6) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k6.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i3 = 0; i3 < power; i3 += step) {
        for (var j6 = 0; j6 < step; j6++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i3 = 1; i3 < max; i3++)
        res[i3] = res[i3 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k6) {
      var r3 = this;
      for (var i3 = 0; i3 < k6; i3++)
        r3 = r3.dbl();
      return r3;
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/short.js
var require_short2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s2 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s2).fromRed();
      var l22 = ntinv.redSub(s2).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u4 = lambda;
      var v7 = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x22 = new BN(0);
      var y22 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i3 = 0;
      var r3;
      var x10;
      while (u4.cmpn(0) !== 0) {
        var q6 = v7.div(u4);
        r3 = v7.sub(q6.mul(u4));
        x10 = x22.sub(q6.mul(x1));
        var y9 = y22.sub(q6.mul(y1));
        if (!a1 && r3.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r3.neg();
          b1 = x10;
        } else if (a1 && ++i3 === 2) {
          break;
        }
        prevR = r3;
        v7 = u4;
        u4 = r3;
        x22 = x1;
        x1 = x10;
        y22 = y1;
        y1 = y9;
      }
      a22 = r3.neg();
      b22 = x10;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k6) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c12 = v22.b.mul(k6).divRound(this.n);
      var c22 = v1.b.neg().mul(k6).divRound(this.n);
      var p1 = c12.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c12.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k6.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x10, odd) {
      x10 = new BN(x10, 16);
      if (!x10.red)
        x10 = x10.toRed(this.red);
      var y22 = x10.redSqr().redMul(x10).redIAdd(x10.redMul(this.a)).redIAdd(this.b);
      var y9 = y22.redSqrt();
      if (y9.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y9.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y9 = y9.redNeg();
      return this.point(x10, y9);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x10 = point.x;
      var y9 = point.y;
      var ax = this.a.redMul(x10);
      var rhs = x10.redSqr().redMul(x10).redIAdd(ax).redIAdd(this.b);
      return y9.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i3 = 0; i3 < points.length; i3++) {
        var split = this._endoSplit(coeffs[i3]);
        var p5 = points[i3];
        var beta = p5._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p5 = p5.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i3 * 2] = p5;
        npoints[i3 * 2 + 1] = beta;
        ncoeffs[i3 * 2] = split.k1;
        ncoeffs[i3 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i3 * 2, jacobianResult);
      for (var j6 = 0; j6 < i3 * 2; j6++) {
        npoints[j6] = null;
        ncoeffs[j6] = null;
      }
      return res;
    };
    function Point(curve, x10, y9, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x10 === null && y9 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x10, 16);
        this.y = new BN(y9, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x10, y9, isRed) {
      return new Point(this, x10, y9, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p5) {
          return curve.point(p5.x.redMul(curve.endo.beta), p5.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p5) {
      if (this.inf)
        return p5;
      if (p5.inf)
        return this;
      if (this.eq(p5))
        return this.dbl();
      if (this.neg().eq(p5))
        return this.curve.point(null, null);
      if (this.x.cmp(p5.x) === 0)
        return this.curve.point(null, null);
      var c7 = this.y.redSub(p5.y);
      if (c7.cmpn(0) !== 0)
        c7 = c7.redMul(this.x.redSub(p5.x).redInvm());
      var nx = c7.redSqr().redISub(this.x).redISub(p5.x);
      var ny = c7.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a5 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c7 = x22.redAdd(x22).redIAdd(x22).redIAdd(a5).redMul(dyinv);
      var nx = c7.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c7.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k6) {
      k6 = new BN(k6, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k6))
        return this.curve._fixedNafMul(this, k6);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k6]);
      else
        return this.curve._wnafMul(this, k6);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p5) {
      return this === p5 || this.inf === p5.inf && (this.inf || this.x.cmp(p5.x) === 0 && this.y.cmp(p5.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p5) {
          return p5.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x10, y9, z10) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x10 === null && y9 === null && z10 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x10, 16);
        this.y = new BN(y9, 16);
        this.z = new BN(z10, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x10, y9, z10) {
      return new JPoint(this, x10, y9, z10);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      var pz2 = p5.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p5.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p5.z));
      var s2 = p5.y.redMul(z22.redMul(this.z));
      var h7 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h7.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h7.redSqr();
      var h32 = h22.redMul(h7);
      var v7 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
      var ny = r3.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p5.z).redMul(h7);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p5) {
      if (this.isInfinity())
        return p5.toJ();
      if (p5.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p5.x.redMul(z22);
      var s1 = this.y;
      var s2 = p5.y.redMul(z22).redMul(this.z);
      var h7 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h7.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h7.redSqr();
      var h32 = h22.redMul(h7);
      var v7 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
      var ny = r3.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h7);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i3;
      if (this.curve.zeroA || this.curve.threeA) {
        var r3 = this;
        for (i3 = 0; i3 < pow; i3++)
          r3 = r3.dbl();
        return r3;
      }
      var a5 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i3 = 0; i3 < pow; i3++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c7 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c7.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c7.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i3 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m2 = xx.redAdd(xx).redIAdd(xx);
        var t = m2.redSqr().redISub(s2).redISub(s2);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m2.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a5 = this.x.redSqr();
        var b7 = this.y.redSqr();
        var c7 = b7.redSqr();
        var d6 = this.x.redAdd(b7).redSqr().redISub(a5).redISub(c7);
        d6 = d6.redIAdd(d6);
        var e = a5.redAdd(a5).redIAdd(a5);
        var f7 = e.redSqr();
        var c8 = c7.redIAdd(c7);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f7.redISub(d6).redISub(d6);
        ny = e.redMul(d6.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m2.redSqr().redISub(s2).redISub(s2);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m2.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a5 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c7 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a5.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c7.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c7.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m2 = xx.redAdd(xx).redIAdd(xx);
      var mm = m2.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee7 = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u4 = m2.redIAdd(e).redSqr().redISub(mm).redISub(ee7).redISub(t);
      var yyu4 = yy.redMul(u4);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee7).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u4.redMul(t.redISub(u4)).redISub(e.redMul(ee7)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee7);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k6, kbase) {
      k6 = new BN(k6, kbase);
      return this.curve._wnafMul(this, k6);
    };
    JPoint.prototype.eq = function eq(p5) {
      if (p5.type === "affine")
        return this.eq(p5.toJ());
      if (this === p5)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p5.z.redSqr();
      if (this.x.redMul(pz2).redISub(p5.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p5.z);
      return this.y.redMul(pz3).redISub(p5.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x10) {
      var zs3 = this.z.redSqr();
      var rx = x10.toRed(this.curve.red).redMul(zs3);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x10.clone();
      var t = this.curve.redN.redMul(zs3);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var utils = require_utils4();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x10 = point.normalize().x;
      var x22 = x10.redSqr();
      var rhs = x22.redMul(x10).redAdd(x22.redMul(this.a)).redAdd(x10);
      var y9 = rhs.redSqrt();
      return y9.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x10, z10) {
      Base.BasePoint.call(this, curve, "projective");
      if (x10 === null && z10 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x10, 16);
        this.z = new BN(z10, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x10, z10) {
      return new Point(this, x10, z10);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a5 = this.x.redAdd(this.z);
      var aa = a5.redSqr();
      var b7 = this.x.redSub(this.z);
      var bb = b7.redSqr();
      var c7 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c7.redMul(bb.redAdd(this.curve.a24.redMul(c7)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p5, diff) {
      var a5 = this.x.redAdd(this.z);
      var b7 = this.x.redSub(this.z);
      var c7 = p5.x.redAdd(p5.z);
      var d6 = p5.x.redSub(p5.z);
      var da = d6.redMul(a5);
      var cb = c7.redMul(b7);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k6) {
      var t = k6.clone();
      var a5 = this;
      var b7 = this.curve.point(null, null);
      var c7 = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i3 = bits.length - 1; i3 >= 0; i3--) {
        if (bits[i3] === 0) {
          a5 = a5.diffAdd(b7, c7);
          b7 = b7.dbl();
        } else {
          b7 = a5.diffAdd(b7, c7);
          a5 = a5.dbl();
        }
      }
      return b7;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x10, y9, z10, t) {
      return this.point(x10, y9, z10, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x10, odd) {
      x10 = new BN(x10, 16);
      if (!x10.red)
        x10 = x10.toRed(this.red);
      var x22 = x10.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y9 = y22.redSqrt();
      if (y9.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y9.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y9 = y9.redNeg();
      return this.point(x10, y9);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y9, odd) {
      y9 = new BN(y9, 16);
      if (!y9.red)
        y9 = y9.toRed(this.red);
      var y22 = y9.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y9);
      }
      var x10 = x22.redSqrt();
      if (x10.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x10.fromRed().isOdd() !== odd)
        x10 = x10.redNeg();
      return this.point(x10, y9);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x10, y9, z10, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x10 === null && y9 === null && z10 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x10, 16);
        this.y = new BN(y9, 16);
        this.z = z10 ? new BN(z10, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x10, y9, z10, t) {
      return new Point(this, x10, y9, z10, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a5 = this.x.redSqr();
      var b7 = this.y.redSqr();
      var c7 = this.z.redSqr();
      c7 = c7.redIAdd(c7);
      var d6 = this.curve._mulA(a5);
      var e = this.x.redAdd(this.y).redSqr().redISub(a5).redISub(b7);
      var g5 = d6.redAdd(b7);
      var f7 = g5.redSub(c7);
      var h7 = d6.redSub(b7);
      var nx = e.redMul(f7);
      var ny = g5.redMul(h7);
      var nt4 = e.redMul(h7);
      var nz = f7.redMul(g5);
      return this.curve.point(nx, ny, nz, nt4);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b7 = this.x.redAdd(this.y).redSqr();
      var c7 = this.x.redSqr();
      var d6 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h7;
      var j6;
      if (this.curve.twisted) {
        e = this.curve._mulA(c7);
        var f7 = e.redAdd(d6);
        if (this.zOne) {
          nx = b7.redSub(c7).redSub(d6).redMul(f7.redSub(this.curve.two));
          ny = f7.redMul(e.redSub(d6));
          nz = f7.redSqr().redSub(f7).redSub(f7);
        } else {
          h7 = this.z.redSqr();
          j6 = f7.redSub(h7).redISub(h7);
          nx = b7.redSub(c7).redISub(d6).redMul(j6);
          ny = f7.redMul(e.redSub(d6));
          nz = f7.redMul(j6);
        }
      } else {
        e = c7.redAdd(d6);
        h7 = this.curve._mulC(this.z).redSqr();
        j6 = e.redSub(h7).redSub(h7);
        nx = this.curve._mulC(b7.redISub(e)).redMul(j6);
        ny = this.curve._mulC(e).redMul(c7.redISub(d6));
        nz = e.redMul(j6);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p5) {
      var a5 = this.y.redSub(this.x).redMul(p5.y.redSub(p5.x));
      var b7 = this.y.redAdd(this.x).redMul(p5.y.redAdd(p5.x));
      var c7 = this.t.redMul(this.curve.dd).redMul(p5.t);
      var d6 = this.z.redMul(p5.z.redAdd(p5.z));
      var e = b7.redSub(a5);
      var f7 = d6.redSub(c7);
      var g5 = d6.redAdd(c7);
      var h7 = b7.redAdd(a5);
      var nx = e.redMul(f7);
      var ny = g5.redMul(h7);
      var nt4 = e.redMul(h7);
      var nz = f7.redMul(g5);
      return this.curve.point(nx, ny, nz, nt4);
    };
    Point.prototype._projAdd = function _projAdd(p5) {
      var a5 = this.z.redMul(p5.z);
      var b7 = a5.redSqr();
      var c7 = this.x.redMul(p5.x);
      var d6 = this.y.redMul(p5.y);
      var e = this.curve.d.redMul(c7).redMul(d6);
      var f7 = b7.redSub(e);
      var g5 = b7.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p5.x.redAdd(p5.y)).redISub(c7).redISub(d6);
      var nx = a5.redMul(f7).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a5.redMul(g5).redMul(d6.redSub(this.curve._mulA(c7)));
        nz = f7.redMul(g5);
      } else {
        ny = a5.redMul(g5).redMul(d6.redSub(c7));
        nz = this.curve._mulC(f7).redMul(g5);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p5);
      else
        return this._projAdd(p5);
    };
    Point.prototype.mul = function mul(k6) {
      if (this._hasDoubles(k6))
        return this.curve._fixedNafMul(this, k6);
      else
        return this.curve._wnafMul(this, k6);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k1, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k1, k22], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi3 = this.z.redInvm();
      this.x = this.x.redMul(zi3);
      this.y = this.y.redMul(zi3);
      if (this.t)
        this.t = this.t.redMul(zi3);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x10) {
      var rx = x10.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x10.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base2();
    curve.short = require_short2();
    curve.mont = require_mont2();
    curve.edwards = require_edwards2();
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curves.js
var require_curves2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve2();
    var utils = require_utils4();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k12();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/key.js
var require_key3 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify2(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature3 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p5) {
      var initial = buf[p5.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p5.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i3 = 0, off = p5.place; i3 < octetLen; i3++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p5.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i3 = 0;
      var len = buf.length - 1;
      while (!buf[i3] && !(buf[i3 + 1] & 128) && i3 < len) {
        i3++;
      }
      if (i3 === 0) {
        return buf;
      }
      return buf.slice(i3);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p5 = new Position();
      if (data[p5.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p5);
      if (len === false) {
        return false;
      }
      if (len + p5.place !== data.length) {
        return false;
      }
      if (data[p5.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p5);
      if (rlen === false) {
        return false;
      }
      if ((data[p5.place] & 128) !== 0) {
        return false;
      }
      var r3 = data.slice(p5.place, rlen + p5.place);
      p5.place += rlen;
      if (data[p5.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p5);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p5.place) {
        return false;
      }
      if ((data[p5.place] & 128) !== 0) {
        return false;
      }
      var s2 = data.slice(p5.place, slen + p5.place);
      if (r3[0] === 0) {
        if (r3[1] & 128) {
          r3 = r3.slice(1);
        } else {
          return false;
        }
      }
      if (s2[0] === 0) {
        if (s2[1] & 128) {
          s2 = s2.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r3);
      this.s = new BN(s2);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r3 = this.r.toArray();
      var s2 = this.s.toArray();
      if (r3[0] & 128)
        r3 = [0].concat(r3);
      if (s2[0] & 128)
        s2 = [0].concat(s2);
      r3 = rmPadding(r3);
      s2 = rmPadding(s2);
      while (!s2[0] && !(s2[1] & 128)) {
        s2 = s2.slice(1);
      }
      var arr = [2];
      constructLength(arr, r3.length);
      arr = arr.concat(r3);
      arr.push(2);
      constructLength(arr, s2.length);
      var backHalf = arr.concat(s2);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils4();
    var curves = require_curves2();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key3();
    var Signature = require_signature3();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k6 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k6 = this._truncateToN(k6, true);
        if (k6.cmpn(1) <= 0 || k6.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k6);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r3 = kpX.umod(this.n);
        if (r3.cmpn(0) === 0)
          continue;
        var s2 = k6.invm(this.n).mul(r3.mul(key.getPrivate()).iadd(msg));
        s2 = s2.umod(this.n);
        if (s2.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r3) !== 0 ? 2 : 0);
        if (options.canonical && s2.cmp(this.nh) > 0) {
          s2 = this.n.sub(s2);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r3, s: s2, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r3 = signature.r;
      var s2 = signature.s;
      if (r3.cmpn(1) < 0 || r3.cmp(this.n) >= 0)
        return false;
      if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
        return false;
      var sinv = s2.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r3).umod(this.n);
      var p5;
      if (!this.curve._maxwellTrick) {
        p5 = this.g.mulAdd(u1, key.getPublic(), u22);
        if (p5.isInfinity())
          return false;
        return p5.getX().umod(this.n).cmp(r3) === 0;
      }
      p5 = this.g.jmulAdd(u1, key.getPublic(), u22);
      if (p5.isInfinity())
        return false;
      return p5.eqXToP(r3);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j6, enc) {
      assert((3 & j6) === j6, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n4 = this.n;
      var e = new BN(msg);
      var r3 = signature.r;
      var s2 = signature.s;
      var isYOdd = j6 & 1;
      var isSecondKey = j6 >> 1;
      if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r3 = this.curve.pointFromX(r3.add(this.curve.n), isYOdd);
      else
        r3 = this.curve.pointFromX(r3, isYOdd);
      var rInv = signature.r.invm(n4);
      var s1 = n4.sub(e).mul(rInv).umod(n4);
      var s22 = s2.mul(rInv).umod(n4);
      return this.g.mulAdd(s1, r3, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q5, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i3 = 0; i3 < 4; i3++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i3);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q5))
          return i3;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key4 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a5 = hash.slice(0, eddsa.encodingLength);
      a5[0] &= 248;
      a5[lastIx] &= 127;
      a5[lastIx] |= 64;
      return a5;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify2(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature4 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S9() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R6() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves2();
    var utils = require_utils4();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key4();
    var Signature = require_signature4();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r3 = this.hashInt(key.messagePrefix(), message);
      var R6 = this.g.mul(r3);
      var Rencoded = this.encodePoint(R6);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S9 = r3.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R6, S: S9, Rencoded });
    };
    EDDSA.prototype.verify = function verify2(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h7 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h7));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i3 = 0; i3 < arguments.length; i3++)
        hash2.update(arguments[i3]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y9 = utils.intFromLE(normed);
      return this.curve.pointFromY(y9, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package2().version;
    elliptic.utils = require_utils4();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve2();
    elliptic.curves = require_curves2();
    elliptic.ec = require_ec2();
    elliptic.eddsa = require_eddsa2();
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/core/dist/index.es.js
var import_events7 = __toESM(require_events());

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());
init_esm();
var n = class extends IEvents {
  constructor(e) {
    super();
  }
};
var s = import_time.FIVE_SECONDS;
var r2 = { pulse: "heartbeat_pulse" };
var i = class _i2 extends n {
  constructor(e) {
    super(e), this.events = new import_events.EventEmitter(), this.interval = s, this.interval = (e == null ? void 0 : e.interval) || s;
  }
  static async init(e) {
    const t = new _i2(e);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), (0, import_time.toMiliseconds)(this.interval));
  }
  pulse() {
    this.events.emit(r2.pulse);
  }
};

// node_modules/@walletconnect/core/node_modules/unstorage/dist/shared/unstorage.mNKHTF5Y.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c7) => c7.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  var _a;
  if (!key) {
    return "";
  }
  return ((_a = key.split("?")[0]) == null ? void 0 : _a.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@walletconnect/core/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r3) => r3.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r3) => r3.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      var _a;
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a = mount.driver.flags) == null ? void 0 : _a.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p5) => fullKey.startsWith(p5))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p5) => !p5.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m2.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a5, b7) => b7.length - a5.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      var _a, _b;
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        (_b = (_a = context.unwatch)[base]) == null ? void 0 : _b.call(_a);
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m2 = getMount(key);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e = (s2) => t + s2;
  let n4;
  return i3.dbName && i3.storeName && (n4 = createStore(i3.dbName, i3.storeName)), { name: x, options: i3, async hasItem(s2) {
    return !(typeof await get(e(s2), n4) > "u");
  }, async getItem(s2) {
    return await get(e(s2), n4) ?? null;
  }, setItem(s2, a5) {
    return set(e(s2), a5, n4);
  }, removeItem(s2) {
    return del(e(s2), n4);
  }, getKeys() {
    return keys(n4);
  }, clear() {
    return clear(n4);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E2 = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null) return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i3.prototype.setItem = function(e, n4) {
    this[e] = String(n4);
  }, i3.prototype.removeItem = function(e) {
    delete this[e];
  }, i3.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n4) {
      e[n4] = void 0, delete e[n4];
    });
  }, i3.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l2 < "u" && l2.localStorage ? c.exports = l2.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k2(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null) return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N = "wc_storage_version";
var y2 = 1;
var O = async (i3, t, e) => {
  const n4 = N, s2 = await t.getItem(n4);
  if (s2 && s2 >= y2) {
    e(t);
    return;
  }
  const a5 = await i3.getKeys();
  if (!a5.length) {
    e(t);
    return;
  }
  const m2 = [];
  for (; a5.length; ) {
    const r3 = a5.shift();
    if (!r3) continue;
    const o4 = r3.toLowerCase();
    if (o4.includes("wc@") || o4.includes("walletconnect") || o4.includes("wc_") || o4.includes("wallet_connect")) {
      const f7 = await i3.getItem(r3);
      await t.setItem(r3, f7), m2.push(r3);
    }
  }
  await t.setItem(n4, y2), e(t), j(i3, m2);
};
var j = async (i3, t) => {
  t.length && t.forEach(async (e) => {
    await i3.removeItem(e);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K();
    this.storage = t;
    try {
      const e = new _();
      O(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/types/dist/index.es.js
init_esm();
var import_events4 = __toESM(require_events());
var a2 = Object.defineProperty;
var u = (e, s2, r3) => s2 in e ? a2(e, s2, { enumerable: true, configurable: true, writable: true, value: r3 }) : e[s2] = r3;
var c2 = (e, s2, r3) => u(e, typeof s2 != "symbol" ? s2 + "" : s2, r3);
var h2 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, c2(this, "protocol", "wc"), c2(this, "version", 2);
  }
};
var p = Object.defineProperty;
var b = (e, s2, r3) => s2 in e ? p(e, s2, { enumerable: true, configurable: true, writable: true, value: r3 }) : e[s2] = r3;
var v = (e, s2, r3) => b(e, typeof s2 != "symbol" ? s2 + "" : s2, r3);
var I = class extends IEvents {
  constructor(s2, r3) {
    super(), this.core = s2, this.logger = r3, v(this, "records", /* @__PURE__ */ new Map());
  }
};
var y3 = class {
  constructor(s2, r3) {
    this.logger = s2, this.core = r3;
  }
};
var m = class extends IEvents {
  constructor(s2, r3) {
    super(), this.relayer = s2, this.logger = r3;
  }
};
var d = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var f = class {
  constructor(s2, r3, t, q6) {
    this.core = s2, this.logger = r3, this.name = t;
  }
};
var P = class extends IEvents {
  constructor(s2, r3) {
    super(), this.relayer = s2, this.logger = r3;
  }
};
var S = class extends IEvents {
  constructor(s2, r3) {
    super(), this.core = s2, this.logger = r3;
  }
};
var M = class {
  constructor(s2, r3, t) {
    this.core = s2, this.logger = r3, this.store = t;
  }
};
var O2 = class {
  constructor(s2, r3) {
    this.projectId = s2, this.logger = r3;
  }
};
var R = class {
  constructor(s2, r3, t) {
    this.core = s2, this.logger = r3, this.telemetryEnabled = t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());

// node_modules/@walletconnect/utils/dist/index.es.js
var import_time2 = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());
init_lib2();
var import_elliptic = __toESM(require_elliptic());
var Ft = "ReactNative";
var H = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var Gt = "js";
function et() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function ne() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ft;
}
function Wr() {
  return ne() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function zr() {
  return ne() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Ae() {
  return !et() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function ue() {
  return ne() ? H.reactNative : et() ? H.node : Ae() ? H.browser : H.unknown;
}
function Jr() {
  var e;
  try {
    return ne() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function Wt(e, t) {
  const n4 = new URLSearchParams(e);
  for (const r3 of Object.keys(t).sort()) if (t.hasOwnProperty(r3)) {
    const o4 = t[r3];
    o4 !== void 0 && n4.set(r3, o4);
  }
  return n4.toString();
}
function Yr() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function zt() {
  if (ue() === H.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n4, Version: r3 } = global.Platform;
    return [n4, r3].join("-");
  }
  const e = detect();
  if (e === null) return "unknown";
  const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [t, e.name, e.version].join("-") : [t, e.version].join("-");
}
function Jt() {
  var e;
  const t = ue();
  return t === H.browser ? [t, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : t;
}
function Yt(e, t, n4) {
  const r3 = zt(), o4 = Jt();
  return [[e, t].join("-"), [Gt, n4].join("-"), r3, o4].join("/");
}
function Zr({ protocol: e, version: t, relayUrl: n4, sdkVersion: r3, auth: o4, projectId: s2, useOnCloseEvent: i3, bundleId: c7, packageName: u4 }) {
  const a5 = n4.split("?"), l7 = Yt(e, t, r3), f7 = { auth: o4, ua: l7, projectId: s2, useOnCloseEvent: i3 || void 0, packageName: u4 || void 0, bundleId: c7 || void 0 }, d6 = Wt(a5[1] || "", f7);
  return a5[0] + "?" + d6;
}
function no(e) {
  return Object.fromEntries(e.entries());
}
function ro(e) {
  return new Map(Object.entries(e));
}
function co(e = import_time2.FIVE_MINUTES, t) {
  const n4 = (0, import_time2.toMiliseconds)(e || import_time2.FIVE_MINUTES);
  let r3, o4, s2, i3;
  return { resolve: (c7) => {
    s2 && r3 && (clearTimeout(s2), r3(c7), i3 = Promise.resolve(c7));
  }, reject: (c7) => {
    s2 && o4 && (clearTimeout(s2), o4(c7));
  }, done: () => new Promise((c7, u4) => {
    if (i3) return c7(i3);
    s2 = setTimeout(() => {
      const a5 = new Error(t);
      i3 = Promise.reject(a5), u4(a5);
    }, n4), r3 = c7, o4 = u4;
  }) };
}
function ao(e, t, n4) {
  return new Promise(async (r3, o4) => {
    const s2 = setTimeout(() => o4(new Error(n4)), t);
    try {
      const i3 = await e;
      r3(i3);
    } catch (i3) {
      o4(i3);
    }
    clearTimeout(s2);
  });
}
function tt(e, t) {
  if (typeof t == "string" && t.startsWith(`${e}:`)) return t;
  if (e.toLowerCase() === "topic") {
    if (typeof t != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof t != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function uo(e) {
  return tt("topic", e);
}
function fo(e) {
  return tt("id", e);
}
function lo(e) {
  const [t, n4] = e.split(":"), r3 = { id: void 0, topic: void 0 };
  if (t === "topic" && typeof n4 == "string") r3.topic = n4;
  else if (t === "id" && Number.isInteger(Number(n4))) r3.id = Number(n4);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n4}`);
  return r3;
}
function ho(e, t) {
  return (0, import_time2.fromMiliseconds)((t || Date.now()) + (0, import_time2.toMiliseconds)(e));
}
function po(e) {
  return Date.now() >= (0, import_time2.toMiliseconds)(e);
}
function go(e, t) {
  return `${e}${t ? `:${t}` : ""}`;
}
function wo() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
    const t = Math.random() * 16 | 0;
    return (e === "x" ? t : t & 3 | 8).toString(16);
  });
}
function Eo() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function rt(e) {
  return Buffer.from(e, "base64").toString("utf-8");
}
function vo(e) {
  return new Promise((t) => setTimeout(t, e));
}
function Ne(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function xo(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function je(e, ...t) {
  if (!xo(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function ot(e) {
  if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ne(e.outputLen), Ne(e.blockLen);
}
function me(e, t = true) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function sn2(e, t) {
  je(e);
  const n4 = t.outputLen;
  if (e.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
var Ce = BigInt(2 ** 32 - 1);
var cn = BigInt(32);
function Oo(e, t = false) {
  return t ? { h: Number(e & Ce), l: Number(e >> cn & Ce) } : { h: Number(e >> cn & Ce) | 0, l: Number(e & Ce) | 0 };
}
function Io(e, t = false) {
  let n4 = new Uint32Array(e.length), r3 = new Uint32Array(e.length);
  for (let o4 = 0; o4 < e.length; o4++) {
    const { h: s2, l: i3 } = Oo(e[o4], t);
    [n4[o4], r3[o4]] = [s2, i3];
  }
  return [n4, r3];
}
var Ao = (e, t, n4) => e << n4 | t >>> 32 - n4;
var No = (e, t, n4) => t << n4 | e >>> 32 - n4;
var So = (e, t, n4) => t << n4 - 32 | e >>> 64 - n4;
var Uo = (e, t, n4) => e << n4 - 32 | t >>> 64 - n4;
var be = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function _o(e) {
  return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
}
function st(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function J(e, t) {
  return e << 32 - t | e >>> t;
}
var an = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function To(e) {
  return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
}
function un(e) {
  for (let t = 0; t < e.length; t++) e[t] = To(e[t]);
}
function $o(e) {
  if (typeof e != "string") throw new Error("utf8ToBytes expected string, got " + typeof e);
  return new Uint8Array(new TextEncoder().encode(e));
}
function we(e) {
  return typeof e == "string" && (e = $o(e)), je(e), e;
}
var it = class {
  clone() {
    return this._cloneInto();
  }
};
function fn(e) {
  const t = (r3) => e().update(we(r3)).digest(), n4 = e();
  return t.outputLen = n4.outputLen, t.blockLen = n4.blockLen, t.create = () => e(), t;
}
function Se(e = 32) {
  if (be && typeof be.getRandomValues == "function") return be.getRandomValues(new Uint8Array(e));
  if (be && typeof be.randomBytes == "function") return be.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
var ln = [];
var dn = [];
var hn = [];
var Ro = BigInt(0);
var Ue = BigInt(1);
var Po2 = BigInt(2);
var Lo = BigInt(7);
var Bo = BigInt(256);
var jo = BigInt(113);
for (let e = 0, t = Ue, n4 = 1, r3 = 0; e < 24; e++) {
  [n4, r3] = [r3, (2 * n4 + 3 * r3) % 5], ln.push(2 * (5 * r3 + n4)), dn.push((e + 1) * (e + 2) / 2 % 64);
  let o4 = Ro;
  for (let s2 = 0; s2 < 7; s2++) t = (t << Ue ^ (t >> Lo) * jo) % Bo, t & Po2 && (o4 ^= Ue << (Ue << BigInt(s2)) - Ue);
  hn.push(o4);
}
var [Co, ko] = Io(hn, true);
var pn = (e, t, n4) => n4 > 32 ? So(e, t, n4) : Ao(e, t, n4);
var gn = (e, t, n4) => n4 > 32 ? Uo(e, t, n4) : No(e, t, n4);
function Do(e, t = 24) {
  const n4 = new Uint32Array(10);
  for (let r3 = 24 - t; r3 < 24; r3++) {
    for (let i3 = 0; i3 < 10; i3++) n4[i3] = e[i3] ^ e[i3 + 10] ^ e[i3 + 20] ^ e[i3 + 30] ^ e[i3 + 40];
    for (let i3 = 0; i3 < 10; i3 += 2) {
      const c7 = (i3 + 8) % 10, u4 = (i3 + 2) % 10, a5 = n4[u4], l7 = n4[u4 + 1], f7 = pn(a5, l7, 1) ^ n4[c7], d6 = gn(a5, l7, 1) ^ n4[c7 + 1];
      for (let g5 = 0; g5 < 50; g5 += 10) e[i3 + g5] ^= f7, e[i3 + g5 + 1] ^= d6;
    }
    let o4 = e[2], s2 = e[3];
    for (let i3 = 0; i3 < 24; i3++) {
      const c7 = dn[i3], u4 = pn(o4, s2, c7), a5 = gn(o4, s2, c7), l7 = ln[i3];
      o4 = e[l7], s2 = e[l7 + 1], e[l7] = u4, e[l7 + 1] = a5;
    }
    for (let i3 = 0; i3 < 50; i3 += 10) {
      for (let c7 = 0; c7 < 10; c7++) n4[c7] = e[i3 + c7];
      for (let c7 = 0; c7 < 10; c7++) e[i3 + c7] ^= ~n4[(c7 + 2) % 10] & n4[(c7 + 4) % 10];
    }
    e[0] ^= Co[r3], e[1] ^= ko[r3];
  }
  n4.fill(0);
}
var Bt = class _Bt extends it {
  constructor(t, n4, r3, o4 = false, s2 = 24) {
    if (super(), this.blockLen = t, this.suffix = n4, this.outputLen = r3, this.enableXOF = o4, this.rounds = s2, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Ne(r3), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = _o(this.state);
  }
  keccak() {
    an || un(this.state32), Do(this.state32, this.rounds), an || un(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    me(this);
    const { blockLen: n4, state: r3 } = this;
    t = we(t);
    const o4 = t.length;
    for (let s2 = 0; s2 < o4; ) {
      const i3 = Math.min(n4 - this.pos, o4 - s2);
      for (let c7 = 0; c7 < i3; c7++) r3[this.pos++] ^= t[s2++];
      this.pos === n4 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: t, suffix: n4, pos: r3, blockLen: o4 } = this;
    t[r3] ^= n4, (n4 & 128) !== 0 && r3 === o4 - 1 && this.keccak(), t[o4 - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    me(this, false), je(t), this.finish();
    const n4 = this.state, { blockLen: r3 } = this;
    for (let o4 = 0, s2 = t.length; o4 < s2; ) {
      this.posOut >= r3 && this.keccak();
      const i3 = Math.min(r3 - this.posOut, s2 - o4);
      t.set(n4.subarray(this.posOut, this.posOut + i3), o4), this.posOut += i3, o4 += i3;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Ne(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (sn2(t, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n4, suffix: r3, outputLen: o4, rounds: s2, enableXOF: i3 } = this;
    return t || (t = new _Bt(n4, r3, o4, i3, s2)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s2, t.suffix = r3, t.outputLen = o4, t.enableXOF = i3, t.destroyed = this.destroyed, t;
  }
};
var Mo = (e, t, n4) => fn(() => new Bt(t, e, n4));
var Vo = Mo(1, 136, 256 / 8);
function ht(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function Ln(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function F(e, ...t) {
  if (!Ln(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function Bn(e, t = true) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function ss(e, t) {
  F(e);
  const n4 = t.outputLen;
  if (e.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
function jn(e) {
  if (typeof e != "boolean") throw new Error(`boolean expected, not ${e}`);
}
var se = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
var is = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var cs = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!cs) throw new Error("Non little-endian hardware is not supported");
function as(e) {
  if (typeof e != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(e));
}
function pt(e) {
  if (typeof e == "string") e = as(e);
  else if (Ln(e)) e = gt(e);
  else throw new Error("Uint8Array expected, got " + typeof e);
  return e;
}
function us(e, t) {
  if (t == null || typeof t != "object") throw new Error("options must be defined");
  return Object.assign(e, t);
}
function fs(e, t) {
  if (e.length !== t.length) return false;
  let n4 = 0;
  for (let r3 = 0; r3 < e.length; r3++) n4 |= e[r3] ^ t[r3];
  return n4 === 0;
}
var ls = (e, t) => {
  function n4(r3, ...o4) {
    if (F(r3), e.nonceLength !== void 0) {
      const l7 = o4[0];
      if (!l7) throw new Error("nonce / iv required");
      e.varSizeNonce ? F(l7) : F(l7, e.nonceLength);
    }
    const s2 = e.tagLength;
    s2 && o4[1] !== void 0 && F(o4[1]);
    const i3 = t(r3, ...o4), c7 = (l7, f7) => {
      if (f7 !== void 0) {
        if (l7 !== 2) throw new Error("cipher output not supported");
        F(f7);
      }
    };
    let u4 = false;
    return { encrypt(l7, f7) {
      if (u4) throw new Error("cannot encrypt() twice with same key + nonce");
      return u4 = true, F(l7), c7(i3.encrypt.length, f7), i3.encrypt(l7, f7);
    }, decrypt(l7, f7) {
      if (F(l7), s2 && l7.length < s2) throw new Error("invalid ciphertext length: smaller than tagLength=" + s2);
      return c7(i3.decrypt.length, f7), i3.decrypt(l7, f7);
    } };
  }
  return Object.assign(n4, e), n4;
};
function Cn(e, t, n4 = true) {
  if (t === void 0) return new Uint8Array(e);
  if (t.length !== e) throw new Error("invalid output length, expected " + e + ", got: " + t.length);
  if (n4 && !ds(t)) throw new Error("invalid output, must be aligned");
  return t;
}
function kn(e, t, n4, r3) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n4, r3);
  const o4 = BigInt(32), s2 = BigInt(4294967295), i3 = Number(n4 >> o4 & s2), c7 = Number(n4 & s2), u4 = r3 ? 4 : 0, a5 = r3 ? 0 : 4;
  e.setUint32(t + u4, i3, r3), e.setUint32(t + a5, c7, r3);
}
function ds(e) {
  return e.byteOffset % 4 === 0;
}
function gt(e) {
  return Uint8Array.from(e);
}
function Ee(...e) {
  for (let t = 0; t < e.length; t++) e[t].fill(0);
}
var Dn = (e) => Uint8Array.from(e.split("").map((t) => t.charCodeAt(0)));
var hs = Dn("expand 16-byte k");
var ps = Dn("expand 32-byte k");
var gs = se(hs);
var ys = se(ps);
function x2(e, t) {
  return e << t | e >>> 32 - t;
}
function yt(e) {
  return e.byteOffset % 4 === 0;
}
var Ve = 64;
var ms = 16;
var Mn = 2 ** 32 - 1;
var Vn = new Uint32Array();
function bs(e, t, n4, r3, o4, s2, i3, c7) {
  const u4 = o4.length, a5 = new Uint8Array(Ve), l7 = se(a5), f7 = yt(o4) && yt(s2), d6 = f7 ? se(o4) : Vn, g5 = f7 ? se(s2) : Vn;
  for (let y9 = 0; y9 < u4; i3++) {
    if (e(t, n4, r3, l7, i3, c7), i3 >= Mn) throw new Error("arx: counter overflow");
    const h7 = Math.min(Ve, u4 - y9);
    if (f7 && h7 === Ve) {
      const m2 = y9 / 4;
      if (y9 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let B6 = 0, b7; B6 < ms; B6++) b7 = m2 + B6, g5[b7] = d6[b7] ^ l7[B6];
      y9 += Ve;
      continue;
    }
    for (let m2 = 0, B6; m2 < h7; m2++) B6 = y9 + m2, s2[B6] = o4[B6] ^ a5[m2];
    y9 += h7;
  }
}
function ws(e, t) {
  const { allowShortKeys: n4, extendNonceFn: r3, counterLength: o4, counterRight: s2, rounds: i3 } = us({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t);
  if (typeof e != "function") throw new Error("core must be a function");
  return ht(o4), ht(i3), jn(s2), jn(n4), (c7, u4, a5, l7, f7 = 0) => {
    F(c7), F(u4), F(a5);
    const d6 = a5.length;
    if (l7 === void 0 && (l7 = new Uint8Array(d6)), F(l7), ht(f7), f7 < 0 || f7 >= Mn) throw new Error("arx: counter overflow");
    if (l7.length < d6) throw new Error(`arx: output (${l7.length}) is shorter than data (${d6})`);
    const g5 = [];
    let y9 = c7.length, h7, m2;
    if (y9 === 32) g5.push(h7 = gt(c7)), m2 = ys;
    else if (y9 === 16 && n4) h7 = new Uint8Array(32), h7.set(c7), h7.set(c7, 16), m2 = gs, g5.push(h7);
    else throw new Error(`arx: invalid 32-byte key, got length=${y9}`);
    yt(u4) || g5.push(u4 = gt(u4));
    const B6 = se(h7);
    if (r3) {
      if (u4.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r3(m2, B6, se(u4.subarray(0, 16)), B6), u4 = u4.subarray(16);
    }
    const b7 = 16 - o4;
    if (b7 !== u4.length) throw new Error(`arx: nonce must be ${b7} or 16 bytes`);
    if (b7 !== 12) {
      const I6 = new Uint8Array(12);
      I6.set(u4, s2 ? 0 : 12 - u4.length), u4 = I6, g5.push(u4);
    }
    const _6 = se(u4);
    return bs(e, m2, B6, _6, a5, l7, f7, i3), Ee(...g5), l7;
  };
}
var M2 = (e, t) => e[t++] & 255 | (e[t++] & 255) << 8;
var Es = class {
  constructor(t) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, t = pt(t), F(t, 32);
    const n4 = M2(t, 0), r3 = M2(t, 2), o4 = M2(t, 4), s2 = M2(t, 6), i3 = M2(t, 8), c7 = M2(t, 10), u4 = M2(t, 12), a5 = M2(t, 14);
    this.r[0] = n4 & 8191, this.r[1] = (n4 >>> 13 | r3 << 3) & 8191, this.r[2] = (r3 >>> 10 | o4 << 6) & 7939, this.r[3] = (o4 >>> 7 | s2 << 9) & 8191, this.r[4] = (s2 >>> 4 | i3 << 12) & 255, this.r[5] = i3 >>> 1 & 8190, this.r[6] = (i3 >>> 14 | c7 << 2) & 8191, this.r[7] = (c7 >>> 11 | u4 << 5) & 8065, this.r[8] = (u4 >>> 8 | a5 << 8) & 8191, this.r[9] = a5 >>> 5 & 127;
    for (let l7 = 0; l7 < 8; l7++) this.pad[l7] = M2(t, 16 + 2 * l7);
  }
  process(t, n4, r3 = false) {
    const o4 = r3 ? 0 : 2048, { h: s2, r: i3 } = this, c7 = i3[0], u4 = i3[1], a5 = i3[2], l7 = i3[3], f7 = i3[4], d6 = i3[5], g5 = i3[6], y9 = i3[7], h7 = i3[8], m2 = i3[9], B6 = M2(t, n4 + 0), b7 = M2(t, n4 + 2), _6 = M2(t, n4 + 4), I6 = M2(t, n4 + 6), k6 = M2(t, n4 + 8), E6 = M2(t, n4 + 10), L5 = M2(t, n4 + 12), j6 = M2(t, n4 + 14);
    let v7 = s2[0] + (B6 & 8191), O8 = s2[1] + ((B6 >>> 13 | b7 << 3) & 8191), w5 = s2[2] + ((b7 >>> 10 | _6 << 6) & 8191), R6 = s2[3] + ((_6 >>> 7 | I6 << 9) & 8191), A4 = s2[4] + ((I6 >>> 4 | k6 << 12) & 8191), T4 = s2[5] + (k6 >>> 1 & 8191), N5 = s2[6] + ((k6 >>> 14 | E6 << 2) & 8191), S9 = s2[7] + ((E6 >>> 11 | L5 << 5) & 8191), U6 = s2[8] + ((L5 >>> 8 | j6 << 8) & 8191), $7 = s2[9] + (j6 >>> 5 | o4), p5 = 0, C6 = p5 + v7 * c7 + O8 * (5 * m2) + w5 * (5 * h7) + R6 * (5 * y9) + A4 * (5 * g5);
    p5 = C6 >>> 13, C6 &= 8191, C6 += T4 * (5 * d6) + N5 * (5 * f7) + S9 * (5 * l7) + U6 * (5 * a5) + $7 * (5 * u4), p5 += C6 >>> 13, C6 &= 8191;
    let D7 = p5 + v7 * u4 + O8 * c7 + w5 * (5 * m2) + R6 * (5 * h7) + A4 * (5 * y9);
    p5 = D7 >>> 13, D7 &= 8191, D7 += T4 * (5 * g5) + N5 * (5 * d6) + S9 * (5 * f7) + U6 * (5 * l7) + $7 * (5 * a5), p5 += D7 >>> 13, D7 &= 8191;
    let P6 = p5 + v7 * a5 + O8 * u4 + w5 * c7 + R6 * (5 * m2) + A4 * (5 * h7);
    p5 = P6 >>> 13, P6 &= 8191, P6 += T4 * (5 * y9) + N5 * (5 * g5) + S9 * (5 * d6) + U6 * (5 * f7) + $7 * (5 * l7), p5 += P6 >>> 13, P6 &= 8191;
    let G4 = p5 + v7 * l7 + O8 * a5 + w5 * u4 + R6 * c7 + A4 * (5 * m2);
    p5 = G4 >>> 13, G4 &= 8191, G4 += T4 * (5 * h7) + N5 * (5 * y9) + S9 * (5 * g5) + U6 * (5 * d6) + $7 * (5 * f7), p5 += G4 >>> 13, G4 &= 8191;
    let X3 = p5 + v7 * f7 + O8 * l7 + w5 * a5 + R6 * u4 + A4 * c7;
    p5 = X3 >>> 13, X3 &= 8191, X3 += T4 * (5 * m2) + N5 * (5 * h7) + S9 * (5 * y9) + U6 * (5 * g5) + $7 * (5 * d6), p5 += X3 >>> 13, X3 &= 8191;
    let Z6 = p5 + v7 * d6 + O8 * f7 + w5 * l7 + R6 * a5 + A4 * u4;
    p5 = Z6 >>> 13, Z6 &= 8191, Z6 += T4 * c7 + N5 * (5 * m2) + S9 * (5 * h7) + U6 * (5 * y9) + $7 * (5 * g5), p5 += Z6 >>> 13, Z6 &= 8191;
    let he5 = p5 + v7 * g5 + O8 * d6 + w5 * f7 + R6 * l7 + A4 * a5;
    p5 = he5 >>> 13, he5 &= 8191, he5 += T4 * u4 + N5 * c7 + S9 * (5 * m2) + U6 * (5 * h7) + $7 * (5 * y9), p5 += he5 >>> 13, he5 &= 8191;
    let pe4 = p5 + v7 * y9 + O8 * g5 + w5 * d6 + R6 * f7 + A4 * l7;
    p5 = pe4 >>> 13, pe4 &= 8191, pe4 += T4 * a5 + N5 * u4 + S9 * c7 + U6 * (5 * m2) + $7 * (5 * h7), p5 += pe4 >>> 13, pe4 &= 8191;
    let ge3 = p5 + v7 * h7 + O8 * y9 + w5 * g5 + R6 * d6 + A4 * f7;
    p5 = ge3 >>> 13, ge3 &= 8191, ge3 += T4 * l7 + N5 * a5 + S9 * u4 + U6 * c7 + $7 * (5 * m2), p5 += ge3 >>> 13, ge3 &= 8191;
    let ye6 = p5 + v7 * m2 + O8 * h7 + w5 * y9 + R6 * g5 + A4 * d6;
    p5 = ye6 >>> 13, ye6 &= 8191, ye6 += T4 * f7 + N5 * l7 + S9 * a5 + U6 * u4 + $7 * c7, p5 += ye6 >>> 13, ye6 &= 8191, p5 = (p5 << 2) + p5 | 0, p5 = p5 + C6 | 0, C6 = p5 & 8191, p5 = p5 >>> 13, D7 += p5, s2[0] = C6, s2[1] = D7, s2[2] = P6, s2[3] = G4, s2[4] = X3, s2[5] = Z6, s2[6] = he5, s2[7] = pe4, s2[8] = ge3, s2[9] = ye6;
  }
  finalize() {
    const { h: t, pad: n4 } = this, r3 = new Uint16Array(10);
    let o4 = t[1] >>> 13;
    t[1] &= 8191;
    for (let c7 = 2; c7 < 10; c7++) t[c7] += o4, o4 = t[c7] >>> 13, t[c7] &= 8191;
    t[0] += o4 * 5, o4 = t[0] >>> 13, t[0] &= 8191, t[1] += o4, o4 = t[1] >>> 13, t[1] &= 8191, t[2] += o4, r3[0] = t[0] + 5, o4 = r3[0] >>> 13, r3[0] &= 8191;
    for (let c7 = 1; c7 < 10; c7++) r3[c7] = t[c7] + o4, o4 = r3[c7] >>> 13, r3[c7] &= 8191;
    r3[9] -= 8192;
    let s2 = (o4 ^ 1) - 1;
    for (let c7 = 0; c7 < 10; c7++) r3[c7] &= s2;
    s2 = ~s2;
    for (let c7 = 0; c7 < 10; c7++) t[c7] = t[c7] & s2 | r3[c7];
    t[0] = (t[0] | t[1] << 13) & 65535, t[1] = (t[1] >>> 3 | t[2] << 10) & 65535, t[2] = (t[2] >>> 6 | t[3] << 7) & 65535, t[3] = (t[3] >>> 9 | t[4] << 4) & 65535, t[4] = (t[4] >>> 12 | t[5] << 1 | t[6] << 14) & 65535, t[5] = (t[6] >>> 2 | t[7] << 11) & 65535, t[6] = (t[7] >>> 5 | t[8] << 8) & 65535, t[7] = (t[8] >>> 8 | t[9] << 5) & 65535;
    let i3 = t[0] + n4[0];
    t[0] = i3 & 65535;
    for (let c7 = 1; c7 < 8; c7++) i3 = (t[c7] + n4[c7] | 0) + (i3 >>> 16) | 0, t[c7] = i3 & 65535;
    Ee(r3);
  }
  update(t) {
    Bn(this);
    const { buffer: n4, blockLen: r3 } = this;
    t = pt(t);
    const o4 = t.length;
    for (let s2 = 0; s2 < o4; ) {
      const i3 = Math.min(r3 - this.pos, o4 - s2);
      if (i3 === r3) {
        for (; r3 <= o4 - s2; s2 += r3) this.process(t, s2);
        continue;
      }
      n4.set(t.subarray(s2, s2 + i3), this.pos), this.pos += i3, s2 += i3, this.pos === r3 && (this.process(n4, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Ee(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(t) {
    Bn(this), ss(t, this), this.finished = true;
    const { buffer: n4, h: r3 } = this;
    let { pos: o4 } = this;
    if (o4) {
      for (n4[o4++] = 1; o4 < 16; o4++) n4[o4] = 0;
      this.process(n4, 0, true);
    }
    this.finalize();
    let s2 = 0;
    for (let i3 = 0; i3 < 8; i3++) t[s2++] = r3[i3] >>> 0, t[s2++] = r3[i3] >>> 8;
    return t;
  }
  digest() {
    const { buffer: t, outputLen: n4 } = this;
    this.digestInto(t);
    const r3 = t.slice(0, n4);
    return this.destroy(), r3;
  }
};
function vs(e) {
  const t = (r3, o4) => e(o4).update(pt(r3)).digest(), n4 = e(new Uint8Array(32));
  return t.outputLen = n4.outputLen, t.blockLen = n4.blockLen, t.create = (r3) => e(r3), t;
}
var xs = vs((e) => new Es(e));
function Os(e, t, n4, r3, o4, s2 = 20) {
  let i3 = e[0], c7 = e[1], u4 = e[2], a5 = e[3], l7 = t[0], f7 = t[1], d6 = t[2], g5 = t[3], y9 = t[4], h7 = t[5], m2 = t[6], B6 = t[7], b7 = o4, _6 = n4[0], I6 = n4[1], k6 = n4[2], E6 = i3, L5 = c7, j6 = u4, v7 = a5, O8 = l7, w5 = f7, R6 = d6, A4 = g5, T4 = y9, N5 = h7, S9 = m2, U6 = B6, $7 = b7, p5 = _6, C6 = I6, D7 = k6;
  for (let G4 = 0; G4 < s2; G4 += 2) E6 = E6 + O8 | 0, $7 = x2($7 ^ E6, 16), T4 = T4 + $7 | 0, O8 = x2(O8 ^ T4, 12), E6 = E6 + O8 | 0, $7 = x2($7 ^ E6, 8), T4 = T4 + $7 | 0, O8 = x2(O8 ^ T4, 7), L5 = L5 + w5 | 0, p5 = x2(p5 ^ L5, 16), N5 = N5 + p5 | 0, w5 = x2(w5 ^ N5, 12), L5 = L5 + w5 | 0, p5 = x2(p5 ^ L5, 8), N5 = N5 + p5 | 0, w5 = x2(w5 ^ N5, 7), j6 = j6 + R6 | 0, C6 = x2(C6 ^ j6, 16), S9 = S9 + C6 | 0, R6 = x2(R6 ^ S9, 12), j6 = j6 + R6 | 0, C6 = x2(C6 ^ j6, 8), S9 = S9 + C6 | 0, R6 = x2(R6 ^ S9, 7), v7 = v7 + A4 | 0, D7 = x2(D7 ^ v7, 16), U6 = U6 + D7 | 0, A4 = x2(A4 ^ U6, 12), v7 = v7 + A4 | 0, D7 = x2(D7 ^ v7, 8), U6 = U6 + D7 | 0, A4 = x2(A4 ^ U6, 7), E6 = E6 + w5 | 0, D7 = x2(D7 ^ E6, 16), S9 = S9 + D7 | 0, w5 = x2(w5 ^ S9, 12), E6 = E6 + w5 | 0, D7 = x2(D7 ^ E6, 8), S9 = S9 + D7 | 0, w5 = x2(w5 ^ S9, 7), L5 = L5 + R6 | 0, $7 = x2($7 ^ L5, 16), U6 = U6 + $7 | 0, R6 = x2(R6 ^ U6, 12), L5 = L5 + R6 | 0, $7 = x2($7 ^ L5, 8), U6 = U6 + $7 | 0, R6 = x2(R6 ^ U6, 7), j6 = j6 + A4 | 0, p5 = x2(p5 ^ j6, 16), T4 = T4 + p5 | 0, A4 = x2(A4 ^ T4, 12), j6 = j6 + A4 | 0, p5 = x2(p5 ^ j6, 8), T4 = T4 + p5 | 0, A4 = x2(A4 ^ T4, 7), v7 = v7 + O8 | 0, C6 = x2(C6 ^ v7, 16), N5 = N5 + C6 | 0, O8 = x2(O8 ^ N5, 12), v7 = v7 + O8 | 0, C6 = x2(C6 ^ v7, 8), N5 = N5 + C6 | 0, O8 = x2(O8 ^ N5, 7);
  let P6 = 0;
  r3[P6++] = i3 + E6 | 0, r3[P6++] = c7 + L5 | 0, r3[P6++] = u4 + j6 | 0, r3[P6++] = a5 + v7 | 0, r3[P6++] = l7 + O8 | 0, r3[P6++] = f7 + w5 | 0, r3[P6++] = d6 + R6 | 0, r3[P6++] = g5 + A4 | 0, r3[P6++] = y9 + T4 | 0, r3[P6++] = h7 + N5 | 0, r3[P6++] = m2 + S9 | 0, r3[P6++] = B6 + U6 | 0, r3[P6++] = b7 + $7 | 0, r3[P6++] = _6 + p5 | 0, r3[P6++] = I6 + C6 | 0, r3[P6++] = k6 + D7 | 0;
}
var Is = ws(Os, { counterRight: false, counterLength: 4, allowShortKeys: false });
var As = new Uint8Array(16);
var Hn = (e, t) => {
  e.update(t);
  const n4 = t.length % 16;
  n4 && e.update(As.subarray(n4));
};
var Ns = new Uint8Array(32);
function Kn(e, t, n4, r3, o4) {
  const s2 = e(t, n4, Ns), i3 = xs.create(s2);
  o4 && Hn(i3, o4), Hn(i3, r3);
  const c7 = new Uint8Array(16), u4 = is(c7);
  kn(u4, 0, BigInt(o4 ? o4.length : 0), true), kn(u4, 8, BigInt(r3.length), true), i3.update(c7);
  const a5 = i3.digest();
  return Ee(s2, c7), a5;
}
var Ss = (e) => (t, n4, r3) => ({ encrypt(s2, i3) {
  const c7 = s2.length;
  i3 = Cn(c7 + 16, i3, false), i3.set(s2);
  const u4 = i3.subarray(0, -16);
  e(t, n4, u4, u4, 1);
  const a5 = Kn(e, t, n4, u4, r3);
  return i3.set(a5, c7), Ee(a5), i3;
}, decrypt(s2, i3) {
  i3 = Cn(s2.length - 16, i3, false);
  const c7 = s2.subarray(0, -16), u4 = s2.subarray(-16), a5 = Kn(e, t, n4, c7, r3);
  if (!fs(u4, a5)) throw new Error("invalid tag");
  return i3.set(s2.subarray(0, -16)), e(t, n4, i3, i3, 1), Ee(a5), i3;
} });
var Fn = ls({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Ss(Is));
var qn = class extends it {
  constructor(t, n4) {
    super(), this.finished = false, this.destroyed = false, ot(t);
    const r3 = we(n4);
    if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o4 = this.blockLen, s2 = new Uint8Array(o4);
    s2.set(r3.length > o4 ? t.create().update(r3).digest() : r3);
    for (let i3 = 0; i3 < s2.length; i3++) s2[i3] ^= 54;
    this.iHash.update(s2), this.oHash = t.create();
    for (let i3 = 0; i3 < s2.length; i3++) s2[i3] ^= 106;
    this.oHash.update(s2), s2.fill(0);
  }
  update(t) {
    return me(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    me(this), je(t, this.outputLen), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n4, iHash: r3, finished: o4, destroyed: s2, blockLen: i3, outputLen: c7 } = this;
    return t = t, t.finished = o4, t.destroyed = s2, t.blockLen = i3, t.outputLen = c7, t.oHash = n4._cloneInto(t.oHash), t.iHash = r3._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var mt = (e, t, n4) => new qn(e, t).update(n4).digest();
mt.create = (e, t) => new qn(e, t);
function Us(e, t, n4) {
  return ot(e), n4 === void 0 && (n4 = new Uint8Array(e.outputLen)), mt(e, we(n4), we(t));
}
var bt = new Uint8Array([0]);
var Gn = new Uint8Array();
function _s(e, t, n4, r3 = 32) {
  if (ot(e), Ne(r3), r3 > 255 * e.outputLen) throw new Error("Length should be <= 255*HashLen");
  const o4 = Math.ceil(r3 / e.outputLen);
  n4 === void 0 && (n4 = Gn);
  const s2 = new Uint8Array(o4 * e.outputLen), i3 = mt.create(e, t), c7 = i3._cloneInto(), u4 = new Uint8Array(i3.outputLen);
  for (let a5 = 0; a5 < o4; a5++) bt[0] = a5 + 1, c7.update(a5 === 0 ? Gn : u4).update(n4).update(bt).digestInto(u4), s2.set(u4, e.outputLen * a5), i3._cloneInto(c7);
  return i3.destroy(), c7.destroy(), u4.fill(0), bt.fill(0), s2.slice(0, r3);
}
var Ts = (e, t, n4, r3, o4) => _s(e, Us(e, t, n4), r3, o4);
function $s(e, t, n4, r3) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n4, r3);
  const o4 = BigInt(32), s2 = BigInt(4294967295), i3 = Number(n4 >> o4 & s2), c7 = Number(n4 & s2), u4 = r3 ? 4 : 0, a5 = r3 ? 0 : 4;
  e.setUint32(t + u4, i3, r3), e.setUint32(t + a5, c7, r3);
}
function Rs(e, t, n4) {
  return e & t ^ ~e & n4;
}
function Ps(e, t, n4) {
  return e & t ^ e & n4 ^ t & n4;
}
var Ls = class extends it {
  constructor(t, n4, r3, o4) {
    super(), this.blockLen = t, this.outputLen = n4, this.padOffset = r3, this.isLE = o4, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = st(this.buffer);
  }
  update(t) {
    me(this);
    const { view: n4, buffer: r3, blockLen: o4 } = this;
    t = we(t);
    const s2 = t.length;
    for (let i3 = 0; i3 < s2; ) {
      const c7 = Math.min(o4 - this.pos, s2 - i3);
      if (c7 === o4) {
        const u4 = st(t);
        for (; o4 <= s2 - i3; i3 += o4) this.process(u4, i3);
        continue;
      }
      r3.set(t.subarray(i3, i3 + c7), this.pos), this.pos += c7, i3 += c7, this.pos === o4 && (this.process(n4, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    me(this), sn2(t, this), this.finished = true;
    const { buffer: n4, view: r3, blockLen: o4, isLE: s2 } = this;
    let { pos: i3 } = this;
    n4[i3++] = 128, this.buffer.subarray(i3).fill(0), this.padOffset > o4 - i3 && (this.process(r3, 0), i3 = 0);
    for (let f7 = i3; f7 < o4; f7++) n4[f7] = 0;
    $s(r3, o4 - 8, BigInt(this.length * 8), s2), this.process(r3, 0);
    const c7 = st(t), u4 = this.outputLen;
    if (u4 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const a5 = u4 / 4, l7 = this.get();
    if (a5 > l7.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f7 = 0; f7 < a5; f7++) c7.setUint32(4 * f7, l7[f7], s2);
  }
  digest() {
    const { buffer: t, outputLen: n4 } = this;
    this.digestInto(t);
    const r3 = t.slice(0, n4);
    return this.destroy(), r3;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n4, buffer: r3, length: o4, finished: s2, destroyed: i3, pos: c7 } = this;
    return t.length = o4, t.pos = c7, t.finished = s2, t.destroyed = i3, o4 % n4 && t.buffer.set(r3), t;
  }
};
var Bs = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var ie = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var ce = new Uint32Array(64);
var js = class extends Ls {
  constructor() {
    super(64, 32, 8, false), this.A = ie[0] | 0, this.B = ie[1] | 0, this.C = ie[2] | 0, this.D = ie[3] | 0, this.E = ie[4] | 0, this.F = ie[5] | 0, this.G = ie[6] | 0, this.H = ie[7] | 0;
  }
  get() {
    const { A: t, B: n4, C: r3, D: o4, E: s2, F: i3, G: c7, H: u4 } = this;
    return [t, n4, r3, o4, s2, i3, c7, u4];
  }
  set(t, n4, r3, o4, s2, i3, c7, u4) {
    this.A = t | 0, this.B = n4 | 0, this.C = r3 | 0, this.D = o4 | 0, this.E = s2 | 0, this.F = i3 | 0, this.G = c7 | 0, this.H = u4 | 0;
  }
  process(t, n4) {
    for (let f7 = 0; f7 < 16; f7++, n4 += 4) ce[f7] = t.getUint32(n4, false);
    for (let f7 = 16; f7 < 64; f7++) {
      const d6 = ce[f7 - 15], g5 = ce[f7 - 2], y9 = J(d6, 7) ^ J(d6, 18) ^ d6 >>> 3, h7 = J(g5, 17) ^ J(g5, 19) ^ g5 >>> 10;
      ce[f7] = h7 + ce[f7 - 7] + y9 + ce[f7 - 16] | 0;
    }
    let { A: r3, B: o4, C: s2, D: i3, E: c7, F: u4, G: a5, H: l7 } = this;
    for (let f7 = 0; f7 < 64; f7++) {
      const d6 = J(c7, 6) ^ J(c7, 11) ^ J(c7, 25), g5 = l7 + d6 + Rs(c7, u4, a5) + Bs[f7] + ce[f7] | 0, h7 = (J(r3, 2) ^ J(r3, 13) ^ J(r3, 22)) + Ps(r3, o4, s2) | 0;
      l7 = a5, a5 = u4, u4 = c7, c7 = i3 + g5 | 0, i3 = s2, s2 = o4, o4 = r3, r3 = g5 + h7 | 0;
    }
    r3 = r3 + this.A | 0, o4 = o4 + this.B | 0, s2 = s2 + this.C | 0, i3 = i3 + this.D | 0, c7 = c7 + this.E | 0, u4 = u4 + this.F | 0, a5 = a5 + this.G | 0, l7 = l7 + this.H | 0, this.set(r3, o4, s2, i3, c7, u4, a5, l7);
  }
  roundClean() {
    ce.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var He = fn(() => new js());
var Wn = BigInt(0);
function wt(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function zn(e) {
  if (!wt(e)) throw new Error("Uint8Array expected");
}
var Cs = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function ks(e) {
  zn(e);
  let t = "";
  for (let n4 = 0; n4 < e.length; n4++) t += Cs[e[n4]];
  return t;
}
function Ds(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  return e === "" ? Wn : BigInt("0x" + e);
}
var ee = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Jn(e) {
  if (e >= ee._0 && e <= ee._9) return e - ee._0;
  if (e >= ee.A && e <= ee.F) return e - (ee.A - 10);
  if (e >= ee.a && e <= ee.f) return e - (ee.a - 10);
}
function Yn(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  const t = e.length, n4 = t / 2;
  if (t % 2) throw new Error("hex string expected, got unpadded hex of length " + t);
  const r3 = new Uint8Array(n4);
  for (let o4 = 0, s2 = 0; o4 < n4; o4++, s2 += 2) {
    const i3 = Jn(e.charCodeAt(s2)), c7 = Jn(e.charCodeAt(s2 + 1));
    if (i3 === void 0 || c7 === void 0) {
      const u4 = e[s2] + e[s2 + 1];
      throw new Error('hex string expected, got non-hex character "' + u4 + '" at index ' + s2);
    }
    r3[o4] = i3 * 16 + c7;
  }
  return r3;
}
function Xn(e) {
  return zn(e), Ds(ks(Uint8Array.from(e).reverse()));
}
function Ms(e, t) {
  return Yn(e.toString(16).padStart(t * 2, "0"));
}
function Vs(e, t) {
  return Ms(e, t).reverse();
}
function Zn(e, t, n4) {
  let r3;
  if (typeof t == "string") try {
    r3 = Yn(t);
  } catch (s2) {
    throw new Error(e + " must be hex string or Uint8Array, cause: " + s2);
  }
  else if (wt(t)) r3 = Uint8Array.from(t);
  else throw new Error(e + " must be hex string or Uint8Array");
  const o4 = r3.length;
  if (typeof n4 == "number" && o4 !== n4) throw new Error(e + " of length " + n4 + " expected, got " + o4);
  return r3;
}
var Et = (e) => typeof e == "bigint" && Wn <= e;
function Hs(e, t, n4) {
  return Et(e) && Et(t) && Et(n4) && t <= e && e < n4;
}
function Qn(e, t, n4, r3) {
  if (!Hs(t, n4, r3)) throw new Error("expected valid " + e + ": " + n4 + " <= n < " + r3 + ", got " + t);
}
var Ks = { bigint: (e) => typeof e == "bigint", function: (e) => typeof e == "function", boolean: (e) => typeof e == "boolean", string: (e) => typeof e == "string", stringOrUint8Array: (e) => typeof e == "string" || wt(e), isSafeInteger: (e) => Number.isSafeInteger(e), array: (e) => Array.isArray(e), field: (e, t) => t.Fp.isValid(e), hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen) };
function Fs(e, t, n4 = {}) {
  const r3 = (o4, s2, i3) => {
    const c7 = Ks[s2];
    if (typeof c7 != "function") throw new Error("invalid validator function");
    const u4 = e[o4];
    if (!(i3 && u4 === void 0) && !c7(u4, e)) throw new Error("param " + String(o4) + " is invalid. Expected " + s2 + ", got " + u4);
  };
  for (const [o4, s2] of Object.entries(t)) r3(o4, s2, false);
  for (const [o4, s2] of Object.entries(n4)) r3(o4, s2, true);
  return e;
}
var ve = BigInt(0);
var Ke = BigInt(1);
function er(e, t) {
  const n4 = e % t;
  return n4 >= ve ? n4 : t + n4;
}
function qs(e, t, n4) {
  if (t < ve) throw new Error("invalid exponent, negatives unsupported");
  if (n4 <= ve) throw new Error("invalid modulus");
  if (n4 === Ke) return ve;
  let r3 = Ke;
  for (; t > ve; ) t & Ke && (r3 = r3 * e % n4), e = e * e % n4, t >>= Ke;
  return r3;
}
function z2(e, t, n4) {
  let r3 = e;
  for (; t-- > ve; ) r3 *= r3, r3 %= n4;
  return r3;
}
BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var xe = BigInt(0);
var vt = BigInt(1);
function Gs(e) {
  return Fs(e, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e });
}
function Ws(e) {
  const t = Gs(e), { P: n4 } = t, r3 = (b7) => er(b7, n4), o4 = t.montgomeryBits, s2 = Math.ceil(o4 / 8), i3 = t.nByteLength, c7 = t.adjustScalarBytes || ((b7) => b7), u4 = t.powPminus2 || ((b7) => qs(b7, n4 - BigInt(2), n4));
  function a5(b7, _6, I6) {
    const k6 = r3(b7 * (_6 - I6));
    return _6 = r3(_6 - k6), I6 = r3(I6 + k6), [_6, I6];
  }
  const l7 = (t.a - BigInt(2)) / BigInt(4);
  function f7(b7, _6) {
    Qn("u", b7, xe, n4), Qn("scalar", _6, xe, n4);
    const I6 = _6, k6 = b7;
    let E6 = vt, L5 = xe, j6 = b7, v7 = vt, O8 = xe, w5;
    for (let A4 = BigInt(o4 - 1); A4 >= xe; A4--) {
      const T4 = I6 >> A4 & vt;
      O8 ^= T4, w5 = a5(O8, E6, j6), E6 = w5[0], j6 = w5[1], w5 = a5(O8, L5, v7), L5 = w5[0], v7 = w5[1], O8 = T4;
      const N5 = E6 + L5, S9 = r3(N5 * N5), U6 = E6 - L5, $7 = r3(U6 * U6), p5 = S9 - $7, C6 = j6 + v7, D7 = j6 - v7, P6 = r3(D7 * N5), G4 = r3(C6 * U6), X3 = P6 + G4, Z6 = P6 - G4;
      j6 = r3(X3 * X3), v7 = r3(k6 * r3(Z6 * Z6)), E6 = r3(S9 * $7), L5 = r3(p5 * (S9 + r3(l7 * p5)));
    }
    w5 = a5(O8, E6, j6), E6 = w5[0], j6 = w5[1], w5 = a5(O8, L5, v7), L5 = w5[0], v7 = w5[1];
    const R6 = u4(L5);
    return r3(E6 * R6);
  }
  function d6(b7) {
    return Vs(r3(b7), s2);
  }
  function g5(b7) {
    const _6 = Zn("u coordinate", b7, s2);
    return i3 === 32 && (_6[31] &= 127), Xn(_6);
  }
  function y9(b7) {
    const _6 = Zn("scalar", b7), I6 = _6.length;
    if (I6 !== s2 && I6 !== i3) {
      let k6 = "" + s2 + " or " + i3;
      throw new Error("invalid scalar, expected " + k6 + " bytes, got " + I6);
    }
    return Xn(c7(_6));
  }
  function h7(b7, _6) {
    const I6 = g5(_6), k6 = y9(b7), E6 = f7(I6, k6);
    if (E6 === xe) throw new Error("invalid private or public key received");
    return d6(E6);
  }
  const m2 = d6(t.Gu);
  function B6(b7) {
    return h7(b7, m2);
  }
  return { scalarMult: h7, scalarMultBase: B6, getSharedSecret: (b7, _6) => h7(b7, _6), getPublicKey: (b7) => B6(b7), utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) }, GuBytes: m2 };
}
var xt = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var zs = BigInt(1);
var tr = BigInt(2);
var Js = BigInt(3);
var Ys = BigInt(5);
BigInt(8);
function Xs(e) {
  const t = BigInt(10), n4 = BigInt(20), r3 = BigInt(40), o4 = BigInt(80), s2 = xt, c7 = e * e % s2 * e % s2, u4 = z2(c7, tr, s2) * c7 % s2, a5 = z2(u4, zs, s2) * e % s2, l7 = z2(a5, Ys, s2) * a5 % s2, f7 = z2(l7, t, s2) * l7 % s2, d6 = z2(f7, n4, s2) * f7 % s2, g5 = z2(d6, r3, s2) * d6 % s2, y9 = z2(g5, o4, s2) * g5 % s2, h7 = z2(y9, o4, s2) * g5 % s2, m2 = z2(h7, t, s2) * l7 % s2;
  return { pow_p_5_8: z2(m2, tr, s2) * e % s2, b2: c7 };
}
function Zs(e) {
  return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;
}
var Ot = Ws({ P: xt, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e) => {
  const t = xt, { pow_p_5_8: n4, b2: r3 } = Xs(e);
  return er(z2(n4, Js, t) * r3, t);
}, adjustScalarBytes: Zs, randomBytes: Se });
var It = "base10";
var V = "base16";
var At = "base64pad";
var Oe = "utf8";
var Nt = 0;
var Ie = 1;
var _e = 2;
var ei = 0;
var nr = 1;
var Te = 12;
var St = 32;
function ti() {
  const e = Ot.utils.randomPrivateKey(), t = Ot.getPublicKey(e);
  return { privateKey: toString(e, V), publicKey: toString(t, V) };
}
function ni() {
  const e = Se(St);
  return toString(e, V);
}
function ri(e, t) {
  const n4 = Ot.getSharedSecret(fromString(e, V), fromString(t, V)), r3 = Ts(He, n4, void 0, void 0, St);
  return toString(r3, V);
}
function oi(e) {
  const t = He(fromString(e, V));
  return toString(t, V);
}
function si(e) {
  const t = He(fromString(e, Oe));
  return toString(t, V);
}
function Ut(e) {
  return fromString(`${e}`, It);
}
function fe(e) {
  return Number(toString(e, It));
}
function ii(e) {
  const t = Ut(typeof e.type < "u" ? e.type : Nt);
  if (fe(t) === Ie && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n4 = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, V) : void 0, r3 = typeof e.iv < "u" ? fromString(e.iv, V) : Se(Te), o4 = fromString(e.symKey, V), s2 = Fn(o4, r3).encrypt(fromString(e.message, Oe));
  return _t({ type: t, sealed: s2, iv: r3, senderPublicKey: n4, encoding: e.encoding });
}
function ci(e) {
  const t = fromString(e.symKey, V), { sealed: n4, iv: r3 } = Fe(e), o4 = Fn(t, r3).decrypt(n4);
  if (o4 === null) throw new Error("Failed to decrypt");
  return toString(o4, Oe);
}
function ai(e, t) {
  const n4 = Ut(_e), r3 = Se(Te), o4 = fromString(e, Oe);
  return _t({ type: n4, sealed: o4, iv: r3, encoding: t });
}
function ui(e, t) {
  const { sealed: n4 } = Fe({ encoded: e, encoding: t });
  return toString(n4, Oe);
}
function _t(e) {
  const { encoding: t = At } = e;
  if (fe(e.type) === _e) return toString(concat([e.type, e.sealed]), t);
  if (fe(e.type) === Ie) {
    if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), t);
  }
  return toString(concat([e.type, e.iv, e.sealed]), t);
}
function Fe(e) {
  const { encoded: t, encoding: n4 = At } = e, r3 = fromString(t, n4), o4 = r3.slice(ei, nr), s2 = nr;
  if (fe(o4) === Ie) {
    const a5 = s2 + St, l7 = a5 + Te, f7 = r3.slice(s2, a5), d6 = r3.slice(a5, l7), g5 = r3.slice(l7);
    return { type: o4, sealed: g5, iv: d6, senderPublicKey: f7 };
  }
  if (fe(o4) === _e) {
    const a5 = r3.slice(s2), l7 = Se(Te);
    return { type: o4, sealed: a5, iv: l7 };
  }
  const i3 = s2 + Te, c7 = r3.slice(s2, i3), u4 = r3.slice(i3);
  return { type: o4, sealed: u4, iv: c7 };
}
function fi(e, t) {
  const n4 = Fe({ encoded: e, encoding: t == null ? void 0 : t.encoding });
  return rr({ type: fe(n4.type), senderPublicKey: typeof n4.senderPublicKey < "u" ? toString(n4.senderPublicKey, V) : void 0, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey });
}
function rr(e) {
  const t = (e == null ? void 0 : e.type) || Nt;
  if (t === Ie) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: t, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function li(e) {
  return e.type === Ie && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function di(e) {
  return e.type === _e;
}
function or(e) {
  return new import_elliptic.ec("p256").keyFromPublic({ x: Buffer.from(e.x, "base64").toString("hex"), y: Buffer.from(e.y, "base64").toString("hex") }, "hex");
}
function hi(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  const n4 = t.length % 4;
  return n4 > 0 && (t += "=".repeat(4 - n4)), t;
}
function pi(e) {
  return Buffer.from(hi(e), "base64");
}
function gi(e, t) {
  const [n4, r3, o4] = e.split("."), s2 = pi(o4);
  if (s2.length !== 64) throw new Error("Invalid signature length");
  const i3 = s2.slice(0, 32).toString("hex"), c7 = s2.slice(32, 64).toString("hex"), u4 = `${n4}.${r3}`, a5 = He(u4), l7 = or(t), f7 = toString(a5, V);
  if (!l7.verify(f7, { r: i3, s: c7 })) throw new Error("Invalid signature");
  return sn(e).payload;
}
var sr = "irn";
function yi(e) {
  return (e == null ? void 0 : e.relay) || { protocol: sr };
}
function mi(e) {
  const t = C[e];
  if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${e}`);
  return t;
}
function ir(e, t = "-") {
  const n4 = {}, r3 = "relay" + t;
  return Object.keys(e).forEach((o4) => {
    if (o4.startsWith(r3)) {
      const s2 = o4.replace(r3, ""), i3 = e[o4];
      n4[s2] = i3;
    }
  }), n4;
}
function bi(e) {
  if (!e.includes("wc:")) {
    const a5 = rt(e);
    a5 != null && a5.includes("wc:") && (e = a5);
  }
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const t = e.indexOf(":"), n4 = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r3 = e.substring(0, t), o4 = e.substring(t + 1, n4).split("@"), s2 = typeof n4 < "u" ? e.substring(n4) : "", i3 = new URLSearchParams(s2), c7 = {};
  i3.forEach((a5, l7) => {
    c7[l7] = a5;
  });
  const u4 = typeof c7.methods == "string" ? c7.methods.split(",") : void 0;
  return { protocol: r3, topic: cr(o4[0]), version: parseInt(o4[1], 10), symKey: c7.symKey, relay: ir(c7), methods: u4, expiryTimestamp: c7.expiryTimestamp ? parseInt(c7.expiryTimestamp, 10) : void 0 };
}
function cr(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function ar(e, t = "-") {
  const n4 = "relay", r3 = {};
  return Object.keys(e).forEach((o4) => {
    const s2 = n4 + t + o4;
    e[o4] && (r3[s2] = e[o4]);
  }), r3;
}
function wi(e) {
  const t = new URLSearchParams(), n4 = ar(e.relay);
  Object.keys(n4).sort().forEach((o4) => {
    t.set(o4, n4[o4]);
  }), t.set("symKey", e.symKey), e.expiryTimestamp && t.set("expiryTimestamp", e.expiryTimestamp.toString()), e.methods && t.set("methods", e.methods.join(","));
  const r3 = t.toString();
  return `${e.protocol}:${e.topic}@${e.version}?${r3}`;
}
var yr = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var mr = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function te(e, t) {
  const { message: n4, code: r3 } = mr[e];
  return { message: t ? `${n4} ${t}` : n4, code: r3 };
}
function de(e, t) {
  const { message: n4, code: r3 } = yr[e];
  return { message: t ? `${n4} ${t}` : n4, code: r3 };
}
function ae(e) {
  return typeof e > "u";
}
function q(e, t) {
  return t && ae(e) ? true : typeof e == "string" && !!e.trim().length;
}
function Ge(e, t) {
  return t && ae(e) ? true : typeof e == "number" && !isNaN(e);
}
function Ri(e) {
  function t(n4) {
    try {
      return typeof new URL(n4) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (q(e, false)) {
      if (t(e)) return true;
      const n4 = rt(e);
      return t(n4);
    }
  } catch {
  }
  return false;
}
function Pi(e) {
  var t;
  return (t = e == null ? void 0 : e.proposer) == null ? void 0 : t.publicKey;
}
function Li(e) {
  return e == null ? void 0 : e.topic;
}
function Di(e) {
  return typeof e < "u" && typeof e !== null;
}
function Ji(e, t) {
  return Ge(e, false) && e <= t.max && e >= t.min;
}
function Yi() {
  const e = ue();
  return new Promise((t) => {
    switch (e) {
      case H.browser:
        t(Ur());
        break;
      case H.reactNative:
        t(_r());
        break;
      case H.node:
        t(Tr());
        break;
      default:
        t(true);
    }
  });
}
function Ur() {
  return Ae() && (navigator == null ? void 0 : navigator.onLine);
}
async function _r() {
  if (ne() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function Tr() {
  return true;
}
function Xi(e) {
  switch (ue()) {
    case H.browser:
      $r(e);
      break;
    case H.reactNative:
      Rr(e);
      break;
    case H.node:
      break;
  }
}
function $r(e) {
  !ne() && Ae() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function Rr(e) {
  ne() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((t) => e(t == null ? void 0 : t.isConnected)));
}

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_events5 = __toESM(require_events());
var o2 = class extends r {
  constructor(t) {
    super(t), this.events = new import_events5.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  async request(t, e) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), e);
  }
  async requestStrict(t, e) {
    return new Promise(async (i3, s2) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (n4) {
        s2(n4);
      }
      this.events.on(`${t.id}`, (n4) => {
        isJsonRpcError(n4) ? s2(n4.error) : i3(n4.result);
      });
      try {
        await this.connection.send(t, e);
      } catch (n4) {
        s2(n4);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events6 = __toESM(require_events());
var v2 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser2();
var w = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var d2 = (r3) => r3.split("?")[0];
var h3 = 10;
var b2 = v2();
var f2 = class {
  constructor(e) {
    if (this.url = e, this.events = new import_events6.EventEmitter(), this.registering = false, !isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n4) => {
        this.onClose(n4), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n4, s2) => {
        this.events.once("register_error", (o4) => {
          this.resetMaxListeners(), s2(o4);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return s2(new Error("WebSocket connection is missing or invalid"));
          n4(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n4) => {
      const s2 = (0, esm_exports.isReactNative)() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e) }, o4 = new b2(e, [], s2);
      w() ? o4.onerror = (i3) => {
        const a5 = i3;
        n4(this.emitError(a5.error));
      } : o4.on("error", (i3) => {
        n4(this.emitError(i3));
      }), o4.onopen = () => {
        this.onOpen(o4), t(o4);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const t = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n4 = this.parseError(t), s2 = n4.message || n4.toString(), o4 = formatJsonRpcError(e, s2);
    this.events.emit("payload", o4);
  }
  parseError(e, t = this.url) {
    return parseConnectionError(e, d2(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h3 && this.events.setMaxListeners(h3);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${d2(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
var import_window_getters2 = __toESM(require_cjs2());
var xe2 = "wc";
var Oe2 = 2;
var he = "core";
var B = `${xe2}@2:${he}:`;
var bt2 = { name: he, logger: "error" };
var vt2 = { database: ":memory:" };
var ft = "crypto";
var Ae2 = "client_ed25519_seed";
var _t2 = import_time3.ONE_DAY;
var Et2 = "keychain";
var wt2 = "0.3";
var It2 = "messages";
var Tt = "0.3";
var Ne2 = import_time3.SIX_HOURS;
var Ct2 = "publisher";
var Pt = "irn";
var St2 = "error";
var $e = "wss://relay.walletconnect.org";
var Rt = "relayer";
var T = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var xt2 = "_subscription";
var L = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Ot2 = 0.1;
var be2 = "2.18.1";
var Q = { link_mode: "link_mode", relay: "relay" };
var At2 = "0.3";
var Nt2 = "WALLETCONNECT_CLIENT_ID";
var ze2 = "WALLETCONNECT_LINK_MODE_APPS";
var $ = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var $t = "subscription";
var zt2 = "0.3";
var Lt = import_time3.FIVE_SECONDS * 1e3;
var kt2 = "pairing";
var Ut2 = "0.3";
var ie2 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var se2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var F2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Ft2 = "history";
var Mt = "0.3";
var Kt = "expirer";
var M3 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Bt2 = "0.3";
var jt2 = "verify-api";
var js2 = "https://verify.walletconnect.com";
var Vt = "https://verify.walletconnect.org";
var le = Vt;
var qt = `${le}/v3`;
var Gt2 = [js2, Vt];
var Ht = "echo";
var Yt2 = "https://echo.walletconnect.com";
var q2 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var J2 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Jt2 = 0.1;
var Xt = "event-client";
var Wt2 = 86400;
var Zt = "https://pulse.walletconnect.org/batch";
function Js2(n4, e) {
  if (n4.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s2 = 0; s2 < t.length; s2++) t[s2] = 255;
  for (var i3 = 0; i3 < n4.length; i3++) {
    var r3 = n4.charAt(i3), o4 = r3.charCodeAt(0);
    if (t[o4] !== 255) throw new TypeError(r3 + " is ambiguous");
    t[o4] = i3;
  }
  var a5 = n4.length, c7 = n4.charAt(0), h7 = Math.log(a5) / Math.log(256), u4 = Math.log(256) / Math.log(a5);
  function g5(l7) {
    if (l7 instanceof Uint8Array || (ArrayBuffer.isView(l7) ? l7 = new Uint8Array(l7.buffer, l7.byteOffset, l7.byteLength) : Array.isArray(l7) && (l7 = Uint8Array.from(l7))), !(l7 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (l7.length === 0) return "";
    for (var y9 = 0, O8 = 0, w5 = 0, v7 = l7.length; w5 !== v7 && l7[w5] === 0; ) w5++, y9++;
    for (var k6 = (v7 - w5) * u4 + 1 >>> 0, I6 = new Uint8Array(k6); w5 !== v7; ) {
      for (var V6 = l7[w5], X3 = 0, K6 = k6 - 1; (V6 !== 0 || X3 < O8) && K6 !== -1; K6--, X3++) V6 += 256 * I6[K6] >>> 0, I6[K6] = V6 % a5 >>> 0, V6 = V6 / a5 >>> 0;
      if (V6 !== 0) throw new Error("Non-zero carry");
      O8 = X3, w5++;
    }
    for (var Y4 = k6 - O8; Y4 !== k6 && I6[Y4] === 0; ) Y4++;
    for (var ge3 = c7.repeat(y9); Y4 < k6; ++Y4) ge3 += n4.charAt(I6[Y4]);
    return ge3;
  }
  function b7(l7) {
    if (typeof l7 != "string") throw new TypeError("Expected String");
    if (l7.length === 0) return new Uint8Array();
    var y9 = 0;
    if (l7[y9] !== " ") {
      for (var O8 = 0, w5 = 0; l7[y9] === c7; ) O8++, y9++;
      for (var v7 = (l7.length - y9) * h7 + 1 >>> 0, k6 = new Uint8Array(v7); l7[y9]; ) {
        var I6 = t[l7.charCodeAt(y9)];
        if (I6 === 255) return;
        for (var V6 = 0, X3 = v7 - 1; (I6 !== 0 || V6 < w5) && X3 !== -1; X3--, V6++) I6 += a5 * k6[X3] >>> 0, k6[X3] = I6 % 256 >>> 0, I6 = I6 / 256 >>> 0;
        if (I6 !== 0) throw new Error("Non-zero carry");
        w5 = V6, y9++;
      }
      if (l7[y9] !== " ") {
        for (var K6 = v7 - w5; K6 !== v7 && k6[K6] === 0; ) K6++;
        for (var Y4 = new Uint8Array(O8 + (v7 - K6)), ge3 = O8; K6 !== v7; ) Y4[ge3++] = k6[K6++];
        return Y4;
      }
    }
  }
  function A4(l7) {
    var y9 = b7(l7);
    if (y9) return y9;
    throw new Error(`Non-${e} character`);
  }
  return { encode: g5, decodeUnsafe: b7, decode: A4 };
}
var Xs2 = Js2;
var Ws2 = Xs2;
var Qt = (n4) => {
  if (n4 instanceof Uint8Array && n4.constructor.name === "Uint8Array") return n4;
  if (n4 instanceof ArrayBuffer) return new Uint8Array(n4);
  if (ArrayBuffer.isView(n4)) return new Uint8Array(n4.buffer, n4.byteOffset, n4.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Zs2 = (n4) => new TextEncoder().encode(n4);
var Qs = (n4) => new TextDecoder().decode(n4);
var er2 = class {
  constructor(e, t, s2) {
    this.name = e, this.prefix = t, this.baseEncode = s2;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var tr2 = class {
  constructor(e, t, s2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ei2(this, e);
  }
};
var ir2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ei2(this, e);
  }
  decode(e) {
    const t = e[0], s2 = this.decoders[t];
    if (s2) return s2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ei2 = (n4, e) => new ir2({ ...n4.decoders || { [n4.prefix]: n4 }, ...e.decoders || { [e.prefix]: e } });
var sr2 = class {
  constructor(e, t, s2, i3) {
    this.name = e, this.prefix = t, this.baseEncode = s2, this.baseDecode = i3, this.encoder = new er2(e, t, s2), this.decoder = new tr2(e, t, i3);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var ve2 = ({ name: n4, prefix: e, encode: t, decode: s2 }) => new sr2(n4, e, t, s2);
var ue2 = ({ prefix: n4, name: e, alphabet: t }) => {
  const { encode: s2, decode: i3 } = Ws2(t, e);
  return ve2({ prefix: n4, name: e, encode: s2, decode: (r3) => Qt(i3(r3)) });
};
var rr2 = (n4, e, t, s2) => {
  const i3 = {};
  for (let u4 = 0; u4 < e.length; ++u4) i3[e[u4]] = u4;
  let r3 = n4.length;
  for (; n4[r3 - 1] === "="; ) --r3;
  const o4 = new Uint8Array(r3 * t / 8 | 0);
  let a5 = 0, c7 = 0, h7 = 0;
  for (let u4 = 0; u4 < r3; ++u4) {
    const g5 = i3[n4[u4]];
    if (g5 === void 0) throw new SyntaxError(`Non-${s2} character`);
    c7 = c7 << t | g5, a5 += t, a5 >= 8 && (a5 -= 8, o4[h7++] = 255 & c7 >> a5);
  }
  if (a5 >= t || 255 & c7 << 8 - a5) throw new SyntaxError("Unexpected end of data");
  return o4;
};
var nr2 = (n4, e, t) => {
  const s2 = e[e.length - 1] === "=", i3 = (1 << t) - 1;
  let r3 = "", o4 = 0, a5 = 0;
  for (let c7 = 0; c7 < n4.length; ++c7) for (a5 = a5 << 8 | n4[c7], o4 += 8; o4 > t; ) o4 -= t, r3 += e[i3 & a5 >> o4];
  if (o4 && (r3 += e[i3 & a5 << t - o4]), s2) for (; r3.length * t & 7; ) r3 += "=";
  return r3;
};
var C2 = ({ name: n4, prefix: e, bitsPerChar: t, alphabet: s2 }) => ve2({ prefix: e, name: n4, encode(i3) {
  return nr2(i3, s2, t);
}, decode(i3) {
  return rr2(i3, s2, t, n4);
} });
var or2 = ve2({ prefix: "\0", name: "identity", encode: (n4) => Qs(n4), decode: (n4) => Zs2(n4) });
var ar2 = Object.freeze({ __proto__: null, identity: or2 });
var cr2 = C2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var hr = Object.freeze({ __proto__: null, base2: cr2 });
var lr = C2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var ur = Object.freeze({ __proto__: null, base8: lr });
var dr = ue2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var pr = Object.freeze({ __proto__: null, base10: dr });
var gr = C2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var yr2 = C2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var mr2 = Object.freeze({ __proto__: null, base16: gr, base16upper: yr2 });
var Dr = C2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var br = C2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var vr = C2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var fr = C2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var _r2 = C2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Er = C2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var wr = C2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Ir = C2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var Tr2 = C2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Cr = Object.freeze({ __proto__: null, base32: Dr, base32upper: br, base32pad: vr, base32padupper: fr, base32hex: _r2, base32hexupper: Er, base32hexpad: wr, base32hexpadupper: Ir, base32z: Tr2 });
var Pr = ue2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Sr = ue2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Rr2 = Object.freeze({ __proto__: null, base36: Pr, base36upper: Sr });
var xr = ue2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Or = ue2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Ar = Object.freeze({ __proto__: null, base58btc: xr, base58flickr: Or });
var Nr = C2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var $r2 = C2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var zr2 = C2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Lr2 = C2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var kr2 = Object.freeze({ __proto__: null, base64: Nr, base64pad: $r2, base64url: zr2, base64urlpad: Lr2 });
var ti2 = Array.from("");
var Ur2 = ti2.reduce((n4, e, t) => (n4[t] = e, n4), []);
var Fr = ti2.reduce((n4, e, t) => (n4[e.codePointAt(0)] = t, n4), []);
function Mr(n4) {
  return n4.reduce((e, t) => (e += Ur2[t], e), "");
}
function Kr(n4) {
  const e = [];
  for (const t of n4) {
    const s2 = Fr[t.codePointAt(0)];
    if (s2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(s2);
  }
  return new Uint8Array(e);
}
var Br2 = ve2({ prefix: "", name: "base256emoji", encode: Mr, decode: Kr });
var jr = Object.freeze({ __proto__: null, base256emoji: Br2 });
var Vr = si2;
var ii2 = 128;
var qr = 127;
var Gr = ~qr;
var Hr = Math.pow(2, 31);
function si2(n4, e, t) {
  e = e || [], t = t || 0;
  for (var s2 = t; n4 >= Hr; ) e[t++] = n4 & 255 | ii2, n4 /= 128;
  for (; n4 & Gr; ) e[t++] = n4 & 255 | ii2, n4 >>>= 7;
  return e[t] = n4 | 0, si2.bytes = t - s2 + 1, e;
}
var Yr2 = Le;
var Jr2 = 128;
var ri2 = 127;
function Le(n4, s2) {
  var t = 0, s2 = s2 || 0, i3 = 0, r3 = s2, o4, a5 = n4.length;
  do {
    if (r3 >= a5) throw Le.bytes = 0, new RangeError("Could not decode varint");
    o4 = n4[r3++], t += i3 < 28 ? (o4 & ri2) << i3 : (o4 & ri2) * Math.pow(2, i3), i3 += 7;
  } while (o4 >= Jr2);
  return Le.bytes = r3 - s2, t;
}
var Xr = Math.pow(2, 7);
var Wr2 = Math.pow(2, 14);
var Zr2 = Math.pow(2, 21);
var Qr = Math.pow(2, 28);
var en = Math.pow(2, 35);
var tn = Math.pow(2, 42);
var sn3 = Math.pow(2, 49);
var rn = Math.pow(2, 56);
var nn = Math.pow(2, 63);
var on = function(n4) {
  return n4 < Xr ? 1 : n4 < Wr2 ? 2 : n4 < Zr2 ? 3 : n4 < Qr ? 4 : n4 < en ? 5 : n4 < tn ? 6 : n4 < sn3 ? 7 : n4 < rn ? 8 : n4 < nn ? 9 : 10;
};
var an2 = { encode: Vr, decode: Yr2, encodingLength: on };
var ni2 = an2;
var oi2 = (n4, e, t = 0) => (ni2.encode(n4, e, t), e);
var ai2 = (n4) => ni2.encodingLength(n4);
var ke = (n4, e) => {
  const t = e.byteLength, s2 = ai2(n4), i3 = s2 + ai2(t), r3 = new Uint8Array(i3 + t);
  return oi2(n4, r3, 0), oi2(t, r3, s2), r3.set(e, i3), new cn2(n4, t, e, r3);
};
var cn2 = class {
  constructor(e, t, s2, i3) {
    this.code = e, this.size = t, this.digest = s2, this.bytes = i3;
  }
};
var ci2 = ({ name: n4, code: e, encode: t }) => new hn2(n4, e, t);
var hn2 = class {
  constructor(e, t, s2) {
    this.name = e, this.code = t, this.encode = s2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? ke(this.code, t) : t.then((s2) => ke(this.code, s2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var hi2 = (n4) => async (e) => new Uint8Array(await crypto.subtle.digest(n4, e));
var ln2 = ci2({ name: "sha2-256", code: 18, encode: hi2("SHA-256") });
var un2 = ci2({ name: "sha2-512", code: 19, encode: hi2("SHA-512") });
var dn2 = Object.freeze({ __proto__: null, sha256: ln2, sha512: un2 });
var li2 = 0;
var pn2 = "identity";
var ui2 = Qt;
var gn2 = (n4) => ke(li2, ui2(n4));
var yn = { code: li2, name: pn2, encode: ui2, digest: gn2 };
var mn = Object.freeze({ __proto__: null, identity: yn });
new TextEncoder(), new TextDecoder();
var di2 = { ...ar2, ...hr, ...ur, ...pr, ...mr2, ...Cr, ...Rr2, ...Ar, ...kr2, ...jr };
({ ...dn2, ...mn });
function Dn2(n4 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(n4) : new Uint8Array(n4);
}
function pi2(n4, e, t, s2) {
  return { name: n4, prefix: e, encoder: { name: n4, prefix: e, encode: t }, decoder: { decode: s2 } };
}
var gi2 = pi2("utf8", "u", (n4) => "u" + new TextDecoder("utf8").decode(n4), (n4) => new TextEncoder().encode(n4.substring(1)));
var Ue2 = pi2("ascii", "a", (n4) => {
  let e = "a";
  for (let t = 0; t < n4.length; t++) e += String.fromCharCode(n4[t]);
  return e;
}, (n4) => {
  n4 = n4.substring(1);
  const e = Dn2(n4.length);
  for (let t = 0; t < n4.length; t++) e[t] = n4.charCodeAt(t);
  return e;
});
var bn = { utf8: gi2, "utf-8": gi2, hex: di2.base16, latin1: Ue2, ascii: Ue2, binary: Ue2, ...di2 };
function vn(n4, e = "utf8") {
  const t = bn[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n4, "utf8") : t.decoder.decode(`${t.prefix}${n4}`);
}
var fn2 = Object.defineProperty;
var _n = (n4, e, t) => e in n4 ? fn2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var G = (n4, e, t) => _n(n4, typeof e != "symbol" ? e + "" : e, t);
var yi2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, G(this, "keychain", /* @__PURE__ */ new Map()), G(this, "name", Et2), G(this, "version", wt2), G(this, "initialized", false), G(this, "storagePrefix", B), G(this, "init", async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }), G(this, "has", (s2) => (this.isInitialized(), this.keychain.has(s2))), G(this, "set", async (s2, i3) => {
      this.isInitialized(), this.keychain.set(s2, i3), await this.persist();
    }), G(this, "get", (s2) => {
      this.isInitialized();
      const i3 = this.keychain.get(s2);
      if (typeof i3 > "u") {
        const { message: r3 } = te("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i3;
    }), G(this, "del", async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }), this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, no(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ro(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var En = Object.defineProperty;
var wn = (n4, e, t) => e in n4 ? En(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var P2 = (n4, e, t) => wn(n4, typeof e != "symbol" ? e + "" : e, t);
var mi2 = class {
  constructor(e, t, s2) {
    this.core = e, this.logger = t, P2(this, "name", ft), P2(this, "keychain"), P2(this, "randomSessionIdentifier", ni()), P2(this, "initialized", false), P2(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), P2(this, "hasKeys", (i3) => (this.isInitialized(), this.keychain.has(i3))), P2(this, "getClientId", async () => {
      this.isInitialized();
      const i3 = await this.getClientSeed(), r3 = Po(i3);
      return Qe(r3.publicKey);
    }), P2(this, "generateKeyPair", () => {
      this.isInitialized();
      const i3 = ti();
      return this.setPrivateKey(i3.publicKey, i3.privateKey);
    }), P2(this, "signJWT", async (i3) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), o4 = Po(r3), a5 = this.randomSessionIdentifier, c7 = _t2;
      return await Qo(a5, i3, c7, o4);
    }), P2(this, "generateSharedKey", (i3, r3, o4) => {
      this.isInitialized();
      const a5 = this.getPrivateKey(i3), c7 = ri(a5, r3);
      return this.setSymKey(c7, o4);
    }), P2(this, "setSymKey", async (i3, r3) => {
      this.isInitialized();
      const o4 = r3 || oi(i3);
      return await this.keychain.set(o4, i3), o4;
    }), P2(this, "deleteKeyPair", async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }), P2(this, "deleteSymKey", async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }), P2(this, "encode", async (i3, r3, o4) => {
      this.isInitialized();
      const a5 = rr(o4), c7 = safeJsonStringify(r3);
      if (di(a5)) return ai(c7, o4 == null ? void 0 : o4.encoding);
      if (li(a5)) {
        const b7 = a5.senderPublicKey, A4 = a5.receiverPublicKey;
        i3 = await this.generateSharedKey(b7, A4);
      }
      const h7 = this.getSymKey(i3), { type: u4, senderPublicKey: g5 } = a5;
      return ii({ type: u4, symKey: h7, message: c7, senderPublicKey: g5, encoding: o4 == null ? void 0 : o4.encoding });
    }), P2(this, "decode", async (i3, r3, o4) => {
      this.isInitialized();
      const a5 = fi(r3, o4);
      if (di(a5)) {
        const c7 = ui(r3, o4 == null ? void 0 : o4.encoding);
        return safeJsonParse(c7);
      }
      if (li(a5)) {
        const c7 = a5.receiverPublicKey, h7 = a5.senderPublicKey;
        i3 = await this.generateSharedKey(c7, h7);
      }
      try {
        const c7 = this.getSymKey(i3), h7 = ci({ symKey: c7, encoded: r3, encoding: o4 == null ? void 0 : o4.encoding });
        return safeJsonParse(h7);
      } catch (c7) {
        this.logger.error(`Failed to decode message from topic: '${i3}', clientId: '${await this.getClientId()}'`), this.logger.error(c7);
      }
    }), P2(this, "getPayloadType", (i3, r3 = At) => {
      const o4 = Fe({ encoded: i3, encoding: r3 });
      return fe(o4.type);
    }), P2(this, "getPayloadSenderPublicKey", (i3, r3 = At) => {
      const o4 = Fe({ encoded: i3, encoding: r3 });
      return o4.senderPublicKey ? toString(o4.senderPublicKey, V) : void 0;
    }), this.core = e, this.logger = E(t, this.name), this.keychain = s2 || new yi2(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(Ae2);
    } catch {
      e = ni(), await this.keychain.set(Ae2, e);
    }
    return vn(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var In = Object.defineProperty;
var Tn = (n4, e, t) => e in n4 ? In(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var H2 = (n4, e, t) => Tn(n4, typeof e != "symbol" ? e + "" : e, t);
var Di2 = class extends y3 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, H2(this, "messages", /* @__PURE__ */ new Map()), H2(this, "name", It2), H2(this, "version", Tt), H2(this, "initialized", false), H2(this, "storagePrefix", B), H2(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }), H2(this, "set", async (s2, i3) => {
      this.isInitialized();
      const r3 = si(i3);
      let o4 = this.messages.get(s2);
      return typeof o4 > "u" && (o4 = {}), typeof o4[r3] < "u" || (o4[r3] = i3, this.messages.set(s2, o4), await this.persist()), r3;
    }), H2(this, "get", (s2) => {
      this.isInitialized();
      let i3 = this.messages.get(s2);
      return typeof i3 > "u" && (i3 = {}), i3;
    }), H2(this, "has", (s2, i3) => {
      this.isInitialized();
      const r3 = this.get(s2), o4 = si(i3);
      return typeof r3[o4] < "u";
    }), H2(this, "del", async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }), this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, no(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? ro(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Cn2 = Object.defineProperty;
var Pn = Object.defineProperties;
var Sn = Object.getOwnPropertyDescriptors;
var bi2 = Object.getOwnPropertySymbols;
var Rn = Object.prototype.hasOwnProperty;
var xn = Object.prototype.propertyIsEnumerable;
var Fe2 = (n4, e, t) => e in n4 ? Cn2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var fe2 = (n4, e) => {
  for (var t in e || (e = {})) Rn.call(e, t) && Fe2(n4, t, e[t]);
  if (bi2) for (var t of bi2(e)) xn.call(e, t) && Fe2(n4, t, e[t]);
  return n4;
};
var Me = (n4, e) => Pn(n4, Sn(e));
var j2 = (n4, e, t) => Fe2(n4, typeof e != "symbol" ? e + "" : e, t);
var On = class extends m {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, j2(this, "events", new import_events7.EventEmitter()), j2(this, "name", Ct2), j2(this, "queue", /* @__PURE__ */ new Map()), j2(this, "publishTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE)), j2(this, "initialPublishTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), j2(this, "needsTransportRestart", false), j2(this, "publish", async (s2, i3, r3) => {
      var o4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i3, opts: r3 } });
      const a5 = (r3 == null ? void 0 : r3.ttl) || Ne2, c7 = yi(r3), h7 = (r3 == null ? void 0 : r3.prompt) || false, u4 = (r3 == null ? void 0 : r3.tag) || 0, g5 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), b7 = { topic: s2, message: i3, opts: { ttl: a5, relay: c7, prompt: h7, tag: u4, id: g5, attestation: r3 == null ? void 0 : r3.attestation, tvf: r3 == null ? void 0 : r3.tvf } }, A4 = `Failed to publish payload, please try again. id:${g5} tag:${u4}`;
      try {
        const l7 = new Promise(async (y9) => {
          const O8 = ({ id: v7 }) => {
            b7.opts.id === v7 && (this.removeRequestFromQueue(v7), this.relayer.events.removeListener(T.publish, O8), y9(b7));
          };
          this.relayer.events.on(T.publish, O8);
          const w5 = ao(new Promise((v7, k6) => {
            this.rpcPublish({ topic: s2, message: i3, ttl: a5, prompt: h7, tag: u4, id: g5, attestation: r3 == null ? void 0 : r3.attestation, tvf: r3 == null ? void 0 : r3.tvf }).then(v7).catch((I6) => {
              this.logger.warn(I6, I6 == null ? void 0 : I6.message), k6(I6);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${g5} tag:${u4}`);
          try {
            await w5, this.events.removeListener(T.publish, O8);
          } catch (v7) {
            this.queue.set(g5, Me(fe2({}, b7), { attempt: 1 })), this.logger.warn(v7, v7 == null ? void 0 : v7.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: g5, topic: s2, message: i3, opts: r3 } }), await ao(l7, this.publishTimeout, A4);
      } catch (l7) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(l7), (o4 = r3 == null ? void 0 : r3.internal) != null && o4.throwOnFailedPublish) throw l7;
      } finally {
        this.queue.delete(g5);
      }
    }), j2(this, "on", (s2, i3) => {
      this.events.on(s2, i3);
    }), j2(this, "once", (s2, i3) => {
      this.events.once(s2, i3);
    }), j2(this, "off", (s2, i3) => {
      this.events.off(s2, i3);
    }), j2(this, "removeListener", (s2, i3) => {
      this.events.removeListener(s2, i3);
    }), this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  async rpcPublish(e) {
    var t, s2, i3, r3;
    const { topic: o4, message: a5, ttl: c7 = Ne2, prompt: h7, tag: u4, id: g5, attestation: b7, tvf: A4 } = e, l7 = { method: mi(yi().protocol).publish, params: fe2({ topic: o4, message: a5, ttl: c7, prompt: h7, tag: u4, attestation: b7 }, A4), id: g5 };
    ae((t = l7.params) == null ? void 0 : t.prompt) && ((s2 = l7.params) == null || delete s2.prompt), ae((i3 = l7.params) == null ? void 0 : i3.tag) && ((r3 = l7.params) == null || delete r3.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: l7 });
    const y9 = await this.relayer.request(l7);
    return this.relayer.events.emit(T.publish, e), this.logger.debug("Successfully Published Payload"), y9;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      const s2 = e.attempt + 1;
      this.queue.set(t, Me(fe2({}, e), { attempt: s2 }));
      const { topic: i3, message: r3, opts: o4, attestation: a5 } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s2}`), await this.rpcPublish(Me(fe2({}, e), { topic: i3, message: r3, ttl: o4.ttl, prompt: o4.prompt, tag: o4.tag, id: o4.id, attestation: a5, tvf: o4.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(T.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(T.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var An = Object.defineProperty;
var Nn = (n4, e, t) => e in n4 ? An(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var re = (n4, e, t) => Nn(n4, typeof e != "symbol" ? e + "" : e, t);
var $n = class {
  constructor() {
    re(this, "map", /* @__PURE__ */ new Map()), re(this, "set", (e, t) => {
      const s2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...s2, t]);
    }), re(this, "get", (e) => this.map.get(e) || []), re(this, "exists", (e, t) => this.get(e).includes(t)), re(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const s2 = this.get(e);
      if (!this.exists(e, t)) return;
      const i3 = s2.filter((r3) => r3 !== t);
      if (!i3.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i3);
    }), re(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var zn2 = Object.defineProperty;
var Ln2 = Object.defineProperties;
var kn2 = Object.getOwnPropertyDescriptors;
var vi = Object.getOwnPropertySymbols;
var Un = Object.prototype.hasOwnProperty;
var Fn2 = Object.prototype.propertyIsEnumerable;
var Ke2 = (n4, e, t) => e in n4 ? zn2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var de2 = (n4, e) => {
  for (var t in e || (e = {})) Un.call(e, t) && Ke2(n4, t, e[t]);
  if (vi) for (var t of vi(e)) Fn2.call(e, t) && Ke2(n4, t, e[t]);
  return n4;
};
var Be = (n4, e) => Ln2(n4, kn2(e));
var D2 = (n4, e, t) => Ke2(n4, typeof e != "symbol" ? e + "" : e, t);
var fi2 = class extends P {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, D2(this, "subscriptions", /* @__PURE__ */ new Map()), D2(this, "topicMap", new $n()), D2(this, "events", new import_events7.EventEmitter()), D2(this, "name", $t), D2(this, "version", zt2), D2(this, "pending", /* @__PURE__ */ new Map()), D2(this, "cached", []), D2(this, "initialized", false), D2(this, "pendingSubscriptionWatchLabel", "pending_sub_watch_label"), D2(this, "pollingInterval", 20), D2(this, "storagePrefix", B), D2(this, "subscribeTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE)), D2(this, "initialSubscribeTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), D2(this, "clientId"), D2(this, "batchSubscribeTopicsLimit", 500), D2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), D2(this, "subscribe", async (s2, i3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } });
      try {
        const r3 = yi(i3), o4 = { topic: s2, relay: r3, transportType: i3 == null ? void 0 : i3.transportType };
        this.pending.set(s2, o4);
        const a5 = await this.rpcSubscribe(s2, r3, i3);
        return typeof a5 == "string" && (this.onSubscribe(a5, o4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } })), a5;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }), D2(this, "unsubscribe", async (s2, i3) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i3 == null ? void 0 : i3.id) < "u" ? await this.unsubscribeById(s2, i3.id, i3) : await this.unsubscribeByTopic(s2, i3);
    }), D2(this, "isSubscribed", async (s2) => {
      if (this.topics.includes(s2)) return true;
      const i3 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, o4) => {
        const a5 = new import_time3.Watch();
        a5.start(i3);
        const c7 = setInterval(() => {
          (!this.pending.has(s2) && this.topics.includes(s2) || this.cached.some((h7) => h7.topic === s2)) && (clearInterval(c7), a5.stop(i3), r3(true)), a5.elapsed(i3) >= Lt && (clearInterval(c7), a5.stop(i3), o4(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }), D2(this, "on", (s2, i3) => {
      this.events.on(s2, i3);
    }), D2(this, "once", (s2, i3) => {
      this.events.once(s2, i3);
    }), D2(this, "off", (s2, i3) => {
      this.events.off(s2, i3);
    }), D2(this, "removeListener", (s2, i3) => {
      this.events.removeListener(s2, i3);
    }), D2(this, "start", async () => {
      await this.onConnect();
    }), D2(this, "stop", async () => {
      await this.onDisconnect();
    }), D2(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), D2(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const s2 = [];
      this.pending.forEach((i3) => {
        s2.push(i3);
      }), await this.batchSubscribe(s2);
    }), D2(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r2.pulse, async () => {
        await this.checkPending();
      }), this.events.on($.created, async (s2) => {
        const i3 = $.created;
        this.logger.info(`Emitting ${i3}`), this.logger.debug({ type: "event", event: i3, data: s2 }), await this.persist();
      }), this.events.on($.deleted, async (s2) => {
        const i3 = $.deleted;
        this.logger.info(`Emitting ${i3}`), this.logger.debug({ type: "event", event: i3, data: s2 }), await this.persist();
      });
    }), this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return s2;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const s2 = this.topicMap.get(e);
    await Promise.all(s2.map(async (i3) => await this.unsubscribeById(e, i3, t)));
  }
  async unsubscribeById(e, t, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    try {
      const i3 = yi(s2);
      await this.rpcUnsubscribe(e, t, i3);
      const r3 = de("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    } catch (i3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i3), i3;
    }
  }
  async rpcSubscribe(e, t, s2) {
    var i3;
    (s2 == null ? void 0 : s2.transportType) === Q.relay && await this.restartToComplete();
    const r3 = { method: mi(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r3 });
    const o4 = (i3 = s2 == null ? void 0 : s2.internal) == null ? void 0 : i3.throwOnFailedPublish;
    try {
      const a5 = await this.getSubscriptionId(e);
      if ((s2 == null ? void 0 : s2.transportType) === Q.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r3).catch((u4) => this.logger.warn(u4));
      }, (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), a5;
      const c7 = new Promise(async (u4) => {
        const g5 = (b7) => {
          b7.topic === e && (this.events.removeListener($.created, g5), u4(b7.id));
        };
        this.events.on($.created, g5);
        try {
          const b7 = await ao(new Promise((A4, l7) => {
            this.relayer.request(r3).catch((y9) => {
              this.logger.warn(y9, y9 == null ? void 0 : y9.message), l7(y9);
            }).then(A4);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener($.created, g5), u4(b7);
        } catch {
        }
      }), h7 = await ao(c7, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h7 && o4) throw new Error(`Subscribing to ${e} failed, please try again`);
      return h7 ? a5 : null;
    } catch (a5) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(T.connection_stalled), o4) throw a5;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, s2 = { method: mi(t.protocol).batchSubscribe, params: { topics: e.map((i3) => i3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      await await ao(new Promise((i3) => {
        this.relayer.request(s2).catch((r3) => this.logger.warn(r3)).then(i3);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(T.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, s2 = { method: mi(t.protocol).batchFetchMessages, params: { topics: e.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i3;
    try {
      i3 = await await ao(new Promise((r3, o4) => {
        this.relayer.request(s2).catch((a5) => {
          this.logger.warn(a5), o4(a5);
        }).then(r3);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(T.connection_stalled);
    }
    return i3;
  }
  rpcUnsubscribe(e, t, s2) {
    const i3 = { method: mi(s2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 }), this.relayer.request(i3);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, Be(de2({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, de2({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, s2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, de2({}, t)), this.topicMap.set(t.topic, e), this.events.emit($.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: s2 } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const s2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(s2.topic, e), this.events.emit($.deleted, Be(de2({}, s2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let s2 = 0; s2 < t; s2++) {
        const i3 = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit($.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => Be(de2({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await vo((0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen();
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return si(e + await this.getClientId());
  }
};
var Mn2 = Object.defineProperty;
var _i = Object.getOwnPropertySymbols;
var Kn2 = Object.prototype.hasOwnProperty;
var Bn2 = Object.prototype.propertyIsEnumerable;
var je2 = (n4, e, t) => e in n4 ? Mn2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var Ei = (n4, e) => {
  for (var t in e || (e = {})) Kn2.call(e, t) && je2(n4, t, e[t]);
  if (_i) for (var t of _i(e)) Bn2.call(e, t) && je2(n4, t, e[t]);
  return n4;
};
var p2 = (n4, e, t) => je2(n4, typeof e != "symbol" ? e + "" : e, t);
var wi2 = class extends d {
  constructor(e) {
    super(e), p2(this, "protocol", "wc"), p2(this, "version", 2), p2(this, "core"), p2(this, "logger"), p2(this, "events", new import_events7.EventEmitter()), p2(this, "provider"), p2(this, "messages"), p2(this, "subscriber"), p2(this, "publisher"), p2(this, "name", Rt), p2(this, "transportExplicitlyClosed", false), p2(this, "initialized", false), p2(this, "connectionAttemptInProgress", false), p2(this, "relayUrl"), p2(this, "projectId"), p2(this, "packageName"), p2(this, "bundleId"), p2(this, "hasExperiencedNetworkDisruption", false), p2(this, "pingTimeout"), p2(this, "heartBeatTimeout", (0, import_time3.toMiliseconds)(import_time3.THIRTY_SECONDS + import_time3.FIVE_SECONDS)), p2(this, "reconnectTimeout"), p2(this, "connectPromise"), p2(this, "requestsInFlight", []), p2(this, "connectTimeout", (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND * 15)), p2(this, "request", async (t) => {
      var s2, i3;
      this.logger.debug("Publishing Request Payload");
      const r3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: r3, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - publishing...");
        const o4 = `${r3}:${((i3 = t.params) == null ? void 0 : i3.tag) || ""}`;
        this.requestsInFlight.push(o4);
        const a5 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c7) => c7 !== o4), a5;
      } catch (o4) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), o4;
      }
    }), p2(this, "resetPingTimeout", () => {
      if (et()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t, s2, i3;
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (i3 = (s2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s2.socket) == null || i3.terminate();
        }, this.heartBeatTimeout);
      } catch (t) {
        this.logger.warn(t, t == null ? void 0 : t.message);
      }
    }), p2(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), p2(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(T.connect);
    }), p2(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), p2(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(t, `Fatal socket error: ${t == null ? void 0 : t.message}`), this.events.emit(T.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), p2(this, "registerProviderListeners", () => {
      this.provider.on(L.payload, this.onPayloadHandler), this.provider.on(L.connect, this.onConnectHandler), this.provider.on(L.disconnect, this.onDisconnectHandler), this.provider.on(L.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || St2 })), this.messages = new Di2(this.logger, e.core), this.subscriber = new fi2(this, this.logger), this.publisher = new On(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || $e, this.projectId = e.projectId, Wr() ? this.packageName = Jr() : zr() && (this.bundleId = Jr()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e, e == null ? void 0 : e.message);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 1;
  }
  get connecting() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 0;
  }
  async publish(e, t, s2) {
    this.isInitialized(), await this.publisher.publish(e, t, s2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: Q.relay });
  }
  async subscribe(e, t) {
    var s2, i3, r3;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o4 = typeof ((s2 = t == null ? void 0 : t.internal) == null ? void 0 : s2.throwOnFailedPublish) > "u" ? true : (i3 = t == null ? void 0 : t.internal) == null ? void 0 : i3.throwOnFailedPublish;
    let a5 = ((r3 = this.subscriber.topicMap.get(e)) == null ? void 0 : r3[0]) || "", c7;
    const h7 = (u4) => {
      u4.topic === e && (this.subscriber.off($.created, h7), c7());
    };
    return await Promise.all([new Promise((u4) => {
      c7 = u4, this.subscriber.on($.created, h7);
    }), new Promise(async (u4, g5) => {
      a5 = await this.subscriber.subscribe(e, Ei({ internal: { throwOnFailedPublish: o4 } }, t)).catch((b7) => {
        o4 && g5(b7);
      }) || a5, u4();
    })]), a5;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ao(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, s2) => {
      await this.connect(e).then(t).catch(s2).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Yi()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((s2, i3) => s2.publishedAt - i3.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const s2 of t) try {
      await this.onMessageEvent(s2);
    } catch (i3) {
      this.logger.warn(i3, "Error while processing batch message event: " + (i3 == null ? void 0 : i3.message));
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: s2 } = e;
    if (!t.sessionExists) {
      const i3 = ho(import_time3.FIVE_MINUTES), r3 = { topic: s2, expiry: i3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(T.message, e), await this.recordMessageEvent(e);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (s2, i3) => {
          const r3 = () => {
            i3(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(L.disconnect, r3), await ao(new Promise((o4, a5) => {
            this.provider.connect().then(o4).catch(a5);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o4) => {
            i3(o4);
          }).finally(() => {
            this.provider.off(L.disconnect, r3), clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
          }), await new Promise(async (o4, a5) => {
            const c7 = () => {
              a5(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L.disconnect, c7), await this.subscriber.start().then(o4).catch(a5).finally(() => {
              this.provider.off(L.disconnect, c7);
            });
          }), this.hasExperiencedNetworkDisruption = false, s2();
        });
      } catch (s2) {
        await this.subscriber.stop();
        const i3 = s2;
        this.logger.warn({}, i3.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((s2) => setTimeout(s2, (0, import_time3.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, s2, i3, r3;
    if (et()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r3 = (i3 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i3.socket) == null || r3.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o4) {
      this.logger.warn(o4, o4 == null ? void 0 : o4.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o2(new f2(Zr({ sdkVersion: be2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    await this.messages.set(t, s2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    if (!s2 || s2.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t)) return this.logger.warn(`Ignoring message for non-subscribed topic ${t}`), true;
    const i3 = this.messages.has(t, s2);
    return i3 && this.logger.warn(`Ignoring duplicate message: ${s2}`), i3;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(xt2)) return;
      const t = e.params, { topic: s2, message: i3, publishedAt: r3, attestation: o4 } = t.data, a5 = { topic: s2, message: i3, publishedAt: r3, transportType: Q.relay, attestation: o4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ei({ type: "event", event: t.id }, a5)), this.events.emit(t.id, a5), await this.acknowledgePayload(e), await this.onMessageEvent(a5);
    } else isJsonRpcResponse(e) && this.events.emit(T.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(T.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(L.payload, this.onPayloadHandler), this.provider.off(L.connect, this.onConnectHandler), this.provider.off(L.disconnect, this.onDisconnectHandler), this.provider.off(L.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Yi();
    Xi(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((s2) => this.logger.error(s2, s2 == null ? void 0 : s2.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), clearTimeout(this.pingTimeout), this.events.emit(T.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || this.connectPromise || (this.reconnectTimeout = setTimeout(async () => {
      clearTimeout(this.reconnectTimeout), await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message));
    }, (0, import_time3.toMiliseconds)(Ot2))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && await this.transportOpen();
  }
};
var jn2 = Object.defineProperty;
var Ii = Object.getOwnPropertySymbols;
var Vn2 = Object.prototype.hasOwnProperty;
var qn2 = Object.prototype.propertyIsEnumerable;
var Ve2 = (n4, e, t) => e in n4 ? jn2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var Ti = (n4, e) => {
  for (var t in e || (e = {})) Vn2.call(e, t) && Ve2(n4, t, e[t]);
  if (Ii) for (var t of Ii(e)) qn2.call(e, t) && Ve2(n4, t, e[t]);
  return n4;
};
var z3 = (n4, e, t) => Ve2(n4, typeof e != "symbol" ? e + "" : e, t);
var Ci = class extends f {
  constructor(e, t, s2, i3 = B, r3 = void 0) {
    super(e, t, s2, i3), this.core = e, this.logger = t, this.name = s2, z3(this, "map", /* @__PURE__ */ new Map()), z3(this, "version", At2), z3(this, "cached", []), z3(this, "initialized", false), z3(this, "getKey"), z3(this, "storagePrefix", B), z3(this, "recentlyDeleted", []), z3(this, "recentlyDeletedLimit", 200), z3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o4) => {
        this.getKey && o4 !== null && !ae(o4) ? this.map.set(this.getKey(o4), o4) : Pi(o4) ? this.map.set(o4.id, o4) : Li(o4) && this.map.set(o4.topic, o4);
      }), this.cached = [], this.initialized = true);
    }), z3(this, "set", async (o4, a5) => {
      this.isInitialized(), this.map.has(o4) ? await this.update(o4, a5) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o4, value: a5 }), this.map.set(o4, a5), await this.persist());
    }), z3(this, "get", (o4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o4 }), this.getData(o4))), z3(this, "getAll", (o4) => (this.isInitialized(), o4 ? this.values.filter((a5) => Object.keys(o4).every((c7) => (0, import_lodash.default)(a5[c7], o4[c7]))) : this.values)), z3(this, "update", async (o4, a5) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o4, update: a5 });
      const c7 = Ti(Ti({}, this.getData(o4)), a5);
      this.map.set(o4, c7), await this.persist();
    }), z3(this, "delete", async (o4, a5) => {
      this.isInitialized(), this.map.has(o4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o4, reason: a5 }), this.map.delete(o4), this.addToRecentlyDeleted(o4), await this.persist());
    }), this.logger = E(t, this.name), this.storagePrefix = i3, this.getKey = r3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i3 } = te("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i3), new Error(i3);
      }
      const { message: s2 } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Gn2 = Object.defineProperty;
var Hn2 = (n4, e, t) => e in n4 ? Gn2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var d3 = (n4, e, t) => Hn2(n4, typeof e != "symbol" ? e + "" : e, t);
var Pi2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, d3(this, "name", kt2), d3(this, "version", Ut2), d3(this, "events", new import_events7.default()), d3(this, "pairings"), d3(this, "initialized", false), d3(this, "storagePrefix", B), d3(this, "ignoredPayloadTypes", [Ie]), d3(this, "registeredMethods", []), d3(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), d3(this, "register", ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }), d3(this, "create", async (s2) => {
      this.isInitialized();
      const i3 = ni(), r3 = await this.core.crypto.setSymKey(i3), o4 = ho(import_time3.FIVE_MINUTES), a5 = { protocol: Pt }, c7 = { topic: r3, expiry: o4, relay: a5, active: false, methods: s2 == null ? void 0 : s2.methods }, h7 = wi({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i3, relay: a5, expiryTimestamp: o4, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(se2.create, c7), this.core.expirer.set(r3, o4), await this.pairings.set(r3, c7), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: h7 };
    }), d3(this, "pair", async (s2) => {
      this.isInitialized();
      const i3 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [q2.pairing_started] } });
      this.isValidPair(s2, i3);
      const { topic: r3, symKey: o4, relay: a5, expiryTimestamp: c7, methods: h7 } = bi(s2.uri);
      i3.props.properties.topic = r3, i3.addTrace(q2.pairing_uri_validation_success), i3.addTrace(q2.pairing_uri_not_expired);
      let u4;
      if (this.pairings.keys.includes(r3)) {
        if (u4 = this.pairings.get(r3), i3.addTrace(q2.existing_pairing), u4.active) throw i3.setError(J2.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i3.addTrace(q2.pairing_not_expired);
      }
      const g5 = c7 || ho(import_time3.FIVE_MINUTES), b7 = { topic: r3, relay: a5, expiry: g5, active: false, methods: h7 };
      this.core.expirer.set(r3, g5), await this.pairings.set(r3, b7), i3.addTrace(q2.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(se2.create, b7), i3.addTrace(q2.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(o4, r3), i3.addTrace(q2.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i3.setError(J2.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a5 });
      } catch (A4) {
        throw i3.setError(J2.subscribe_pairing_topic_failure), A4;
      }
      return i3.addTrace(q2.subscribe_pairing_topic_success), b7;
    }), d3(this, "activate", async ({ topic: s2 }) => {
      this.isInitialized();
      const i3 = ho(import_time3.FIVE_MINUTES);
      this.core.expirer.set(s2, i3), await this.pairings.update(s2, { active: true, expiry: i3 });
    }), d3(this, "ping", async (s2) => {
      this.isInitialized(), await this.isValidPing(s2), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: i3 } = s2;
      if (this.pairings.keys.includes(i3)) {
        const r3 = await this.sendRequest(i3, "wc_pairingPing", {}), { done: o4, resolve: a5, reject: c7 } = co();
        this.events.once(go("pairing_ping", r3), ({ error: h7 }) => {
          h7 ? c7(h7) : a5();
        }), await o4();
      }
    }), d3(this, "updateExpiry", async ({ topic: s2, expiry: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i3 });
    }), d3(this, "updateMetadata", async ({ topic: s2, metadata: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i3 });
    }), d3(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), d3(this, "disconnect", async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i3 } = s2;
      this.pairings.keys.includes(i3) && (await this.sendRequest(i3, "wc_pairingDelete", de("USER_DISCONNECTED")), await this.deletePairing(i3));
    }), d3(this, "formatUriFromPairing", (s2) => {
      this.isInitialized();
      const { topic: i3, relay: r3, expiry: o4, methods: a5 } = s2, c7 = this.core.crypto.keychain.get(i3);
      return wi({ protocol: this.core.protocol, version: this.core.version, topic: i3, symKey: c7, relay: r3, expiryTimestamp: o4, methods: a5 });
    }), d3(this, "sendRequest", async (s2, i3, r3) => {
      const o4 = formatJsonRpcRequest(i3, r3), a5 = await this.core.crypto.encode(s2, o4), c7 = ie2[i3].req;
      return this.core.history.set(s2, o4), this.core.relayer.publish(s2, a5, c7), o4.id;
    }), d3(this, "sendResult", async (s2, i3, r3) => {
      const o4 = formatJsonRpcResult(s2, r3), a5 = await this.core.crypto.encode(i3, o4), c7 = await this.core.history.get(i3, s2), h7 = ie2[c7.request.method].res;
      await this.core.relayer.publish(i3, a5, h7), await this.core.history.resolve(o4);
    }), d3(this, "sendError", async (s2, i3, r3) => {
      const o4 = formatJsonRpcError(s2, r3), a5 = await this.core.crypto.encode(i3, o4), c7 = await this.core.history.get(i3, s2), h7 = ie2[c7.request.method] ? ie2[c7.request.method].res : ie2.unregistered_method.res;
      await this.core.relayer.publish(i3, a5, h7), await this.core.history.resolve(o4);
    }), d3(this, "deletePairing", async (s2, i3) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, de("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i3 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }), d3(this, "cleanup", async () => {
      const s2 = this.pairings.getAll().filter((i3) => po(i3.expiry));
      await Promise.all(s2.map((i3) => this.deletePairing(i3.topic)));
    }), d3(this, "onRelayEventRequest", (s2) => {
      const { topic: i3, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i3, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i3, r3);
        default:
          return this.onUnknownRpcMethodRequest(i3, r3);
      }
    }), d3(this, "onRelayEventResponse", async (s2) => {
      const { topic: i3, payload: r3 } = s2, o4 = (await this.core.history.get(i3, r3.id)).request.method;
      switch (o4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i3, r3);
        default:
          return this.onUnknownRpcMethodResponse(o4);
      }
    }), d3(this, "onPairingPingRequest", async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(se2.ping, { id: r3, topic: s2 });
      } catch (o4) {
        await this.sendError(r3, s2, o4), this.logger.error(o4);
      }
    }), d3(this, "onPairingPingResponse", (s2, i3) => {
      const { id: r3 } = i3;
      setTimeout(() => {
        isJsonRpcResult(i3) ? this.events.emit(go("pairing_ping", r3), {}) : isJsonRpcError(i3) && this.events.emit(go("pairing_ping", r3), { error: i3.error });
      }, 500);
    }), d3(this, "onPairingDeleteRequest", async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(se2.delete, { id: r3, topic: s2 });
      } catch (o4) {
        await this.sendError(r3, s2, o4), this.logger.error(o4);
      }
    }), d3(this, "onUnknownRpcMethodRequest", async (s2, i3) => {
      const { id: r3, method: o4 } = i3;
      try {
        if (this.registeredMethods.includes(o4)) return;
        const a5 = de("WC_METHOD_UNSUPPORTED", o4);
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      } catch (a5) {
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      }
    }), d3(this, "onUnknownRpcMethodResponse", (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(de("WC_METHOD_UNSUPPORTED", s2));
    }), d3(this, "isValidPair", (s2, i3) => {
      var r3;
      if (!Di(s2)) {
        const { message: a5 } = te("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i3.setError(J2.malformed_pairing_uri), new Error(a5);
      }
      if (!Ri(s2.uri)) {
        const { message: a5 } = te("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i3.setError(J2.malformed_pairing_uri), new Error(a5);
      }
      const o4 = bi(s2 == null ? void 0 : s2.uri);
      if (!((r3 = o4 == null ? void 0 : o4.relay) != null && r3.protocol)) {
        const { message: a5 } = te("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i3.setError(J2.malformed_pairing_uri), new Error(a5);
      }
      if (!(o4 != null && o4.symKey)) {
        const { message: a5 } = te("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i3.setError(J2.malformed_pairing_uri), new Error(a5);
      }
      if (o4 != null && o4.expiryTimestamp && (0, import_time3.toMiliseconds)(o4 == null ? void 0 : o4.expiryTimestamp) < Date.now()) {
        i3.setError(J2.pairing_expired);
        const { message: a5 } = te("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a5);
      }
    }), d3(this, "isValidPing", async (s2) => {
      if (!Di(s2)) {
        const { message: r3 } = te("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }), d3(this, "isValidDisconnect", async (s2) => {
      if (!Di(s2)) {
        const { message: r3 } = te("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }), d3(this, "isValidPairingTopic", async (s2) => {
      if (!q(s2, false)) {
        const { message: i3 } = te("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i3);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i3 } = te("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i3);
      }
      if (po(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i3 } = te("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i3);
      }
    }), this.core = e, this.logger = E(t, this.name), this.pairings = new Ci(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(T.message, async (e) => {
      const { topic: t, message: s2, transportType: i3 } = e;
      if (!this.pairings.keys.includes(t) || i3 === Q.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2))) return;
      const r3 = await this.core.crypto.decode(t, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t, r3), this.onRelayEventRequest({ topic: t, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t, payload: r3 }), this.core.history.delete(t, r3.id));
      } catch (o4) {
        this.logger.error(o4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M3.expired, async (e) => {
      const { topic: t } = lo(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(se2.expire, { topic: t }));
    });
  }
};
var Yn2 = Object.defineProperty;
var Jn2 = (n4, e, t) => e in n4 ? Yn2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var S2 = (n4, e, t) => Jn2(n4, typeof e != "symbol" ? e + "" : e, t);
var Si = class extends I {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, S2(this, "records", /* @__PURE__ */ new Map()), S2(this, "events", new import_events7.EventEmitter()), S2(this, "name", Ft2), S2(this, "version", Mt), S2(this, "cached", []), S2(this, "initialized", false), S2(this, "storagePrefix", B), S2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), S2(this, "set", (s2, i3, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i3, chainId: r3 }), this.records.has(i3.id)) return;
      const o4 = { id: i3.id, topic: s2, request: { method: i3.method, params: i3.params || null }, chainId: r3, expiry: ho(import_time3.THIRTY_DAYS) };
      this.records.set(o4.id, o4), this.persist(), this.events.emit(F2.created, o4);
    }), S2(this, "resolve", async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id)) return;
      const i3 = await this.getRecord(s2.id);
      typeof i3.response > "u" && (i3.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i3.id, i3), this.persist(), this.events.emit(F2.updated, i3));
    }), S2(this, "get", async (s2, i3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i3 }), await this.getRecord(i3))), S2(this, "delete", (s2, i3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i3 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i3 < "u" && r3.id !== i3) return;
          this.records.delete(r3.id), this.events.emit(F2.deleted, r3);
        }
      }), this.persist();
    }), S2(this, "exists", async (s2, i3) => (this.isInitialized(), this.records.has(i3) ? (await this.getRecord(i3)).topic === s2 : false)), S2(this, "on", (s2, i3) => {
      this.events.on(s2, i3);
    }), S2(this, "once", (s2, i3) => {
      this.events.once(s2, i3);
    }), S2(this, "off", (s2, i3) => {
      this.events.off(s2, i3);
    }), S2(this, "removeListener", (s2, i3) => {
      this.events.removeListener(s2, i3);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const s2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(s2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: s2 } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(F2.created, (e) => {
      const t = F2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F2.updated, (e) => {
      const t = F2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F2.deleted, (e) => {
      const t = F2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r2.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time3.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(F2.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Xn2 = Object.defineProperty;
var Wn2 = (n4, e, t) => e in n4 ? Xn2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var x3 = (n4, e, t) => Wn2(n4, typeof e != "symbol" ? e + "" : e, t);
var Ri2 = class extends S {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, x3(this, "expirations", /* @__PURE__ */ new Map()), x3(this, "events", new import_events7.EventEmitter()), x3(this, "name", Kt), x3(this, "version", Bt2), x3(this, "cached", []), x3(this, "initialized", false), x3(this, "storagePrefix", B), x3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), x3(this, "has", (s2) => {
      try {
        const i3 = this.formatTarget(s2);
        return typeof this.getExpiration(i3) < "u";
      } catch {
        return false;
      }
    }), x3(this, "set", (s2, i3) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), o4 = { target: r3, expiry: i3 };
      this.expirations.set(r3, o4), this.checkExpiry(r3, o4), this.events.emit(M3.created, { target: r3, expiration: o4 });
    }), x3(this, "get", (s2) => {
      this.isInitialized();
      const i3 = this.formatTarget(s2);
      return this.getExpiration(i3);
    }), x3(this, "del", (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i3 = this.formatTarget(s2), r3 = this.getExpiration(i3);
        this.expirations.delete(i3), this.events.emit(M3.deleted, { target: i3, expiration: r3 });
      }
    }), x3(this, "on", (s2, i3) => {
      this.events.on(s2, i3);
    }), x3(this, "once", (s2, i3) => {
      this.events.once(s2, i3);
    }), x3(this, "off", (s2, i3) => {
      this.events.off(s2, i3);
    }), x3(this, "removeListener", (s2, i3) => {
      this.events.removeListener(s2, i3);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return uo(e);
    if (typeof e == "number") return fo(e);
    const { message: t } = te("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M3.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = te("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: s2 } = te("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: s2 } = t;
    (0, import_time3.toMiliseconds)(s2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(M3.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r2.pulse, () => this.checkExpirations()), this.events.on(M3.created, (e) => {
      const t = M3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M3.expired, (e) => {
      const t = M3.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M3.deleted, (e) => {
      const t = M3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = te("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Zn2 = Object.defineProperty;
var Qn2 = (n4, e, t) => e in n4 ? Zn2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var _2 = (n4, e, t) => Qn2(n4, typeof e != "symbol" ? e + "" : e, t);
var xi = class extends M {
  constructor(e, t, s2) {
    super(e, t, s2), this.core = e, this.logger = t, this.store = s2, _2(this, "name", jt2), _2(this, "abortController"), _2(this, "isDevEnv"), _2(this, "verifyUrlV3", qt), _2(this, "storagePrefix", B), _2(this, "version", Oe2), _2(this, "publicKey"), _2(this, "fetchPromise"), _2(this, "init", async () => {
      var i3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time3.toMiliseconds)((i3 = this.publicKey) == null ? void 0 : i3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), _2(this, "register", async (i3) => {
      if (!Ae() || this.isDevEnv) return;
      const r3 = window.location.origin, { id: o4, decryptedId: a5 } = i3, c7 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${o4}&decryptedId=${a5}`;
      try {
        const h7 = (0, import_window_getters2.getDocument)(), u4 = this.startAbortTimer(import_time3.ONE_SECOND * 5), g5 = await new Promise((b7, A4) => {
          const l7 = () => {
            window.removeEventListener("message", O8), h7.body.removeChild(y9), A4("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l7);
          const y9 = h7.createElement("iframe");
          y9.src = c7, y9.style.display = "none", y9.addEventListener("error", l7, { signal: this.abortController.signal });
          const O8 = (w5) => {
            if (w5.data && typeof w5.data == "string") try {
              const v7 = JSON.parse(w5.data);
              if (v7.type === "verify_attestation") {
                if (sn(v7.attestation).payload.id !== o4) return;
                clearInterval(u4), h7.body.removeChild(y9), this.abortController.signal.removeEventListener("abort", l7), window.removeEventListener("message", O8), b7(v7.attestation === null ? "" : v7.attestation);
              }
            } catch (v7) {
              this.logger.warn(v7);
            }
          };
          h7.body.appendChild(y9), window.addEventListener("message", O8, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", g5), g5;
      } catch (h7) {
        this.logger.warn(h7);
      }
      return "";
    }), _2(this, "resolve", async (i3) => {
      if (this.isDevEnv) return "";
      const { attestationId: r3, hash: o4, encryptedId: a5 } = i3;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (sn(r3).payload.id !== a5) return;
        const h7 = await this.isValidJwtAttestation(r3);
        if (h7) {
          if (!h7.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h7;
        }
      }
      if (!o4) return;
      const c7 = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      return this.fetchAttestation(o4, c7);
    }), _2(this, "fetchAttestation", async (i3, r3) => {
      this.logger.debug(`resolving attestation: ${i3} from url: ${r3}`);
      const o4 = this.startAbortTimer(import_time3.ONE_SECOND * 5), a5 = await fetch(`${r3}/attestation/${i3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o4), a5.status === 200 ? await a5.json() : void 0;
    }), _2(this, "getVerifyUrl", (i3) => {
      let r3 = i3 || le;
      return Gt2.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${le}`), r3 = le), r3;
    }), _2(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i3 = this.startAbortTimer(import_time3.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i3), await r3.json();
      } catch (i3) {
        this.logger.warn(i3);
      }
    }), _2(this, "persistPublicKey", async (i3) => {
      this.logger.debug("persisting public key to local storage", i3), await this.store.setItem(this.storeKey, i3), this.publicKey = i3;
    }), _2(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), _2(this, "isValidJwtAttestation", async (i3) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3) return this.validateAttestation(i3, r3);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
      const o4 = await this.fetchAndPersistPublicKey();
      try {
        if (o4) return this.validateAttestation(i3, o4);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
    }), _2(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), _2(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const o4 = await this.fetchPublicKey();
        o4 && (await this.persistPublicKey(o4), r3(o4));
      });
      const i3 = await this.fetchPromise;
      return this.fetchPromise = void 0, i3;
    }), _2(this, "validateAttestation", (i3, r3) => {
      const o4 = gi(i3, r3.publicKey), a5 = { hasExpired: (0, import_time3.toMiliseconds)(o4.exp) < Date.now(), payload: o4 };
      if (a5.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a5.payload.origin, isScam: a5.payload.isScam, isVerified: a5.payload.isVerified };
    }), this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Eo(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time3.toMiliseconds)(e));
  }
};
var eo = Object.defineProperty;
var to = (n4, e, t) => e in n4 ? eo(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var Oi = (n4, e, t) => to(n4, typeof e != "symbol" ? e + "" : e, t);
var Ai = class extends O2 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, Oi(this, "context", Ht), Oi(this, "registerDeviceToken", async (s2) => {
      const { clientId: i3, token: r3, notificationType: o4, enableEncrypted: a5 = false } = s2, c7 = `${Yt2}/${this.projectId}/clients`;
      await fetch(c7, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i3, type: o4, token: r3, always_raw: a5 }) });
    }), this.logger = E(t, this.context);
  }
};
var io = Object.defineProperty;
var Ni = Object.getOwnPropertySymbols;
var so = Object.prototype.hasOwnProperty;
var ro2 = Object.prototype.propertyIsEnumerable;
var qe = (n4, e, t) => e in n4 ? io(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var pe = (n4, e) => {
  for (var t in e || (e = {})) so.call(e, t) && qe(n4, t, e[t]);
  if (Ni) for (var t of Ni(e)) ro2.call(e, t) && qe(n4, t, e[t]);
  return n4;
};
var E3 = (n4, e, t) => qe(n4, typeof e != "symbol" ? e + "" : e, t);
var $i = class extends R {
  constructor(e, t, s2 = true) {
    super(e, t, s2), this.core = e, this.logger = t, E3(this, "context", Xt), E3(this, "storagePrefix", B), E3(this, "storageVersion", Jt2), E3(this, "events", /* @__PURE__ */ new Map()), E3(this, "shouldPersist", false), E3(this, "init", async () => {
      if (!Eo()) try {
        const i3 = { eventId: wo(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Yt(this.core.relayer.protocol, this.core.relayer.version, be2) } } };
        await this.sendEvent([i3]);
      } catch (i3) {
        this.logger.warn(i3);
      }
    }), E3(this, "createEvent", (i3) => {
      const { event: r3 = "ERROR", type: o4 = "", properties: { topic: a5, trace: c7 } } = i3, h7 = wo(), u4 = this.core.projectId || "", g5 = Date.now(), b7 = pe({ eventId: h7, timestamp: g5, props: { event: r3, type: o4, properties: { topic: a5, trace: c7 } }, bundleId: u4, domain: this.getAppDomain() }, this.setMethods(h7));
      return this.telemetryEnabled && (this.events.set(h7, b7), this.shouldPersist = true), b7;
    }), E3(this, "getEvent", (i3) => {
      const { eventId: r3, topic: o4 } = i3;
      if (r3) return this.events.get(r3);
      const a5 = Array.from(this.events.values()).find((c7) => c7.props.properties.topic === o4);
      if (a5) return pe(pe({}, a5), this.setMethods(a5.eventId));
    }), E3(this, "deleteEvent", (i3) => {
      const { eventId: r3 } = i3;
      this.events.delete(r3), this.shouldPersist = true;
    }), E3(this, "setEventListeners", () => {
      this.core.heartbeat.on(r2.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i3) => {
          (0, import_time3.fromMiliseconds)(Date.now()) - (0, import_time3.fromMiliseconds)(i3.timestamp) > Wt2 && (this.events.delete(i3.eventId), this.shouldPersist = true);
        });
      });
    }), E3(this, "setMethods", (i3) => ({ addTrace: (r3) => this.addTrace(i3, r3), setError: (r3) => this.setError(i3, r3) })), E3(this, "addTrace", (i3, r3) => {
      const o4 = this.events.get(i3);
      o4 && (o4.props.properties.trace.push(r3), this.events.set(i3, o4), this.shouldPersist = true);
    }), E3(this, "setError", (i3, r3) => {
      const o4 = this.events.get(i3);
      o4 && (o4.props.type = r3, o4.timestamp = Date.now(), this.events.set(i3, o4), this.shouldPersist = true);
    }), E3(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E3(this, "restore", async () => {
      try {
        const i3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i3.length) return;
        i3.forEach((r3) => {
          this.events.set(r3.eventId, pe(pe({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i3) {
        this.logger.warn(i3);
      }
    }), E3(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i3 = [];
      for (const [r3, o4] of this.events) o4.props.type && i3.push(o4);
      if (i3.length !== 0) try {
        if ((await this.sendEvent(i3)).ok) for (const r3 of i3) this.events.delete(r3.eventId), this.shouldPersist = true;
      } catch (r3) {
        this.logger.warn(r3);
      }
    }), E3(this, "sendEvent", async (i3) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Zt}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${be2}${r3}`, { method: "POST", body: JSON.stringify(i3) });
    }), E3(this, "getAppDomain", () => Yr().url), this.logger = E(t, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var no2 = Object.defineProperty;
var zi = Object.getOwnPropertySymbols;
var oo = Object.prototype.hasOwnProperty;
var ao2 = Object.prototype.propertyIsEnumerable;
var Ge2 = (n4, e, t) => e in n4 ? no2(n4, e, { enumerable: true, configurable: true, writable: true, value: t }) : n4[e] = t;
var Li2 = (n4, e) => {
  for (var t in e || (e = {})) oo.call(e, t) && Ge2(n4, t, e[t]);
  if (zi) for (var t of zi(e)) ao2.call(e, t) && Ge2(n4, t, e[t]);
  return n4;
};
var f3 = (n4, e, t) => Ge2(n4, typeof e != "symbol" ? e + "" : e, t);
var _e2 = class __e extends h2 {
  constructor(e) {
    var t;
    super(e), f3(this, "protocol", xe2), f3(this, "version", Oe2), f3(this, "name", he), f3(this, "relayUrl"), f3(this, "projectId"), f3(this, "customStoragePrefix"), f3(this, "events", new import_events7.EventEmitter()), f3(this, "logger"), f3(this, "heartbeat"), f3(this, "relayer"), f3(this, "crypto"), f3(this, "storage"), f3(this, "history"), f3(this, "expirer"), f3(this, "pairing"), f3(this, "verify"), f3(this, "echoClient"), f3(this, "linkModeSupportedApps"), f3(this, "eventClient"), f3(this, "initialized", false), f3(this, "logChunkController"), f3(this, "on", (o4, a5) => this.events.on(o4, a5)), f3(this, "once", (o4, a5) => this.events.once(o4, a5)), f3(this, "off", (o4, a5) => this.events.off(o4, a5)), f3(this, "removeListener", (o4, a5) => this.events.removeListener(o4, a5)), f3(this, "dispatchEnvelope", ({ topic: o4, message: a5, sessionExists: c7 }) => {
      if (!o4 || !a5) return;
      const h7 = { topic: o4, message: a5, publishedAt: Date.now(), transportType: Q.link_mode };
      this.relayer.onLinkMessageEvent(h7, { sessionExists: c7 });
    }), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || $e, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : bt2.logger, name: he }), { logger: i3, chunkLoggerController: r3 } = A({ opts: s2, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = r3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var o4, a5;
      (o4 = this.logChunkController) != null && o4.downloadLogsBlobInBrowser && ((a5 = this.logChunkController) == null || a5.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i3, this.name), this.heartbeat = new i(), this.crypto = new mi2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Si(this, this.logger), this.expirer = new Ri2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(Li2(Li2({}, vt2), e == null ? void 0 : e.storageOptions)), this.relayer = new wi2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Pi2(this, this.logger), this.verify = new xi(this, this.logger, this.storage), this.echoClient = new Ai(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new $i(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const t = new __e(e);
    await t.initialize();
    const s2 = await t.crypto.getClientId();
    return await t.storage.setItem(Nt2, s2), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(ze2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(ze2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var co2 = _e2;

// node_modules/@walletconnect/auth-client/dist/index.es.js
var import_events8 = __toESM(require_events());
var import_time4 = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch = __toESM(require_browser());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var G2 = class {
  constructor(t) {
    this.client = t;
  }
};
var H3 = class {
  constructor(t) {
    this.opts = t;
  }
};
var Y = "https://rpc.walletconnect.com/v1";
var R3 = { wc_authRequest: { req: { ttl: import_time4.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 3001 } } };
var U2 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var $2 = "wc";
var Q2 = 1;
var Z2 = "auth";
var B2 = "authClient";
var F3 = `${$2}@${1}:${Z2}:`;
var x4 = `${F3}:PUB_KEY`;
function z4(r3) {
  return r3 == null ? void 0 : r3.split(":");
}
function Ze(r3) {
  const t = r3 && z4(r3);
  if (t) return t[3];
}
function We2(r3) {
  const t = r3 && z4(r3);
  if (t) return t[2] + ":" + t[3];
}
function W(r3) {
  const t = r3 && z4(r3);
  if (t) return t.pop();
}
async function et2(r3, t, e, i3, n4) {
  switch (e.t) {
    case "eip191":
      return tt2(r3, t, e.s);
    case "eip1271":
      return await rt2(r3, t, e.s, i3, n4);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`);
  }
}
function tt2(r3, t, e) {
  return recoverAddress(hashMessage(t), e).toLowerCase() === r3.toLowerCase();
}
async function rt2(r3, t, e, i3, n4) {
  try {
    const s2 = "0x1626ba7e", o4 = "0000000000000000000000000000000000000000000000000000000000000040", u4 = "0000000000000000000000000000000000000000000000000000000000000041", a5 = e.substring(2), c7 = hashMessage(t).substring(2), h7 = s2 + c7 + o4 + u4 + a5, f7 = await (0, import_isomorphic_unfetch.default)(`${Y}/?chainId=${i3}&projectId=${n4}`, { method: "POST", body: JSON.stringify({ id: it2(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r3, data: h7 }, "latest"] }) }), { result: p5 } = await f7.json();
    return p5 ? p5.slice(0, s2.length).toLowerCase() === s2.toLowerCase() : false;
  } catch (s2) {
    return console.error("isValidEip1271Signature: ", s2), false;
  }
}
function it2() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee3(r3) {
  return r3.getAll().filter((t) => "requester" in t);
}
function te3(r3, t) {
  return ee3(r3).find((e) => e.id === t);
}
function nt(r3) {
  const t = Ri(r3.aud), e = new RegExp(`${r3.domain}`).test(r3.aud), i3 = !!r3.nonce, n4 = r3.type ? r3.type === "eip4361" : true, s2 = r3.expiry;
  if (s2 && !Ji(s2, U2)) {
    const { message: o4 } = te("MISSING_OR_INVALID", `request() expiry: ${s2}. Expiry must be a number (in seconds) between ${U2.min} and ${U2.max}`);
    throw new Error(o4);
  }
  return !!(t && e && i3 && n4);
}
function st2(r3, t) {
  return !!te3(t, r3.id);
}
function ot2(r3 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r3) : new Uint8Array(r3);
}
function ut(r3, t) {
  if (r3.length >= 255) throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), i3 = 0; i3 < e.length; i3++) e[i3] = 255;
  for (var n4 = 0; n4 < r3.length; n4++) {
    var s2 = r3.charAt(n4), o4 = s2.charCodeAt(0);
    if (e[o4] !== 255) throw new TypeError(s2 + " is ambiguous");
    e[o4] = n4;
  }
  var u4 = r3.length, a5 = r3.charAt(0), c7 = Math.log(u4) / Math.log(256), h7 = Math.log(256) / Math.log(u4);
  function f7(D7) {
    if (D7 instanceof Uint8Array || (ArrayBuffer.isView(D7) ? D7 = new Uint8Array(D7.buffer, D7.byteOffset, D7.byteLength) : Array.isArray(D7) && (D7 = Uint8Array.from(D7))), !(D7 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (D7.length === 0) return "";
    for (var l7 = 0, m2 = 0, E6 = 0, y9 = D7.length; E6 !== y9 && D7[E6] === 0; ) E6++, l7++;
    for (var w5 = (y9 - E6) * h7 + 1 >>> 0, g5 = new Uint8Array(w5); E6 !== y9; ) {
      for (var C6 = D7[E6], _6 = 0, b7 = w5 - 1; (C6 !== 0 || _6 < m2) && b7 !== -1; b7--, _6++) C6 += 256 * g5[b7] >>> 0, g5[b7] = C6 % u4 >>> 0, C6 = C6 / u4 >>> 0;
      if (C6 !== 0) throw new Error("Non-zero carry");
      m2 = _6, E6++;
    }
    for (var v7 = w5 - m2; v7 !== w5 && g5[v7] === 0; ) v7++;
    for (var q6 = a5.repeat(l7); v7 < w5; ++v7) q6 += r3.charAt(g5[v7]);
    return q6;
  }
  function p5(D7) {
    if (typeof D7 != "string") throw new TypeError("Expected String");
    if (D7.length === 0) return new Uint8Array();
    var l7 = 0;
    if (D7[l7] !== " ") {
      for (var m2 = 0, E6 = 0; D7[l7] === a5; ) m2++, l7++;
      for (var y9 = (D7.length - l7) * c7 + 1 >>> 0, w5 = new Uint8Array(y9); D7[l7]; ) {
        var g5 = e[D7.charCodeAt(l7)];
        if (g5 === 255) return;
        for (var C6 = 0, _6 = y9 - 1; (g5 !== 0 || C6 < E6) && _6 !== -1; _6--, C6++) g5 += u4 * w5[_6] >>> 0, w5[_6] = g5 % 256 >>> 0, g5 = g5 / 256 >>> 0;
        if (g5 !== 0) throw new Error("Non-zero carry");
        E6 = C6, l7++;
      }
      if (D7[l7] !== " ") {
        for (var b7 = y9 - E6; b7 !== y9 && w5[b7] === 0; ) b7++;
        for (var v7 = new Uint8Array(m2 + (y9 - b7)), q6 = m2; b7 !== y9; ) v7[q6++] = w5[b7++];
        return v7;
      }
    }
  }
  function A4(D7) {
    var l7 = p5(D7);
    if (l7) return l7;
    throw new Error(`Non-${t} character`);
  }
  return { encode: f7, decodeUnsafe: p5, decode: A4 };
}
var at = ut;
var Dt = at;
var re2 = (r3) => {
  if (r3 instanceof Uint8Array && r3.constructor.name === "Uint8Array") return r3;
  if (r3 instanceof ArrayBuffer) return new Uint8Array(r3);
  if (ArrayBuffer.isView(r3)) return new Uint8Array(r3.buffer, r3.byteOffset, r3.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ct = (r3) => new TextEncoder().encode(r3);
var ht2 = (r3) => new TextDecoder().decode(r3);
var lt = class {
  constructor(t, e, i3) {
    this.name = t, this.prefix = e, this.baseEncode = i3;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var dt = class {
  constructor(t, e, i3) {
    if (this.name = t, this.prefix = e, e.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = e.codePointAt(0), this.baseDecode = i3;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie3(this, t);
  }
};
var pt2 = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie3(this, t);
  }
  decode(t) {
    const e = t[0], i3 = this.decoders[e];
    if (i3) return i3.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ie3 = (r3, t) => new pt2({ ...r3.decoders || { [r3.prefix]: r3 }, ...t.decoders || { [t.prefix]: t } });
var ft2 = class {
  constructor(t, e, i3, n4) {
    this.name = t, this.prefix = e, this.baseEncode = i3, this.baseDecode = n4, this.encoder = new lt(t, e, i3), this.decoder = new dt(t, e, n4);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var O3 = ({ name: r3, prefix: t, encode: e, decode: i3 }) => new ft2(r3, t, e, i3);
var T2 = ({ prefix: r3, name: t, alphabet: e }) => {
  const { encode: i3, decode: n4 } = Dt(e, t);
  return O3({ prefix: r3, name: t, encode: i3, decode: (s2) => re2(n4(s2)) });
};
var gt2 = (r3, t, e, i3) => {
  const n4 = {};
  for (let h7 = 0; h7 < t.length; ++h7) n4[t[h7]] = h7;
  let s2 = r3.length;
  for (; r3[s2 - 1] === "="; ) --s2;
  const o4 = new Uint8Array(s2 * e / 8 | 0);
  let u4 = 0, a5 = 0, c7 = 0;
  for (let h7 = 0; h7 < s2; ++h7) {
    const f7 = n4[r3[h7]];
    if (f7 === void 0) throw new SyntaxError(`Non-${i3} character`);
    a5 = a5 << e | f7, u4 += e, u4 >= 8 && (u4 -= 8, o4[c7++] = 255 & a5 >> u4);
  }
  if (u4 >= e || 255 & a5 << 8 - u4) throw new SyntaxError("Unexpected end of data");
  return o4;
};
var Et3 = (r3, t, e) => {
  const i3 = t[t.length - 1] === "=", n4 = (1 << e) - 1;
  let s2 = "", o4 = 0, u4 = 0;
  for (let a5 = 0; a5 < r3.length; ++a5) for (u4 = u4 << 8 | r3[a5], o4 += 8; o4 > e; ) o4 -= e, s2 += t[n4 & u4 >> o4];
  if (o4 && (s2 += t[n4 & u4 << e - o4]), i3) for (; s2.length * e & 7; ) s2 += "=";
  return s2;
};
var d4 = ({ name: r3, prefix: t, bitsPerChar: e, alphabet: i3 }) => O3({ prefix: t, name: r3, encode(n4) {
  return Et3(n4, i3, e);
}, decode(n4) {
  return gt2(n4, i3, e, r3);
} });
var bt3 = O3({ prefix: "\0", name: "identity", encode: (r3) => ht2(r3), decode: (r3) => ct(r3) });
var yt2 = Object.freeze({ __proto__: null, identity: bt3 });
var wt3 = d4({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct3 = Object.freeze({ __proto__: null, base2: wt3 });
var mt2 = d4({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt3 = Object.freeze({ __proto__: null, base8: mt2 });
var At3 = T2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t3 = Object.freeze({ __proto__: null, base10: At3 });
var xt3 = d4({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Rt2 = d4({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft3 = Object.freeze({ __proto__: null, base16: xt3, base16upper: Rt2 });
var Tt2 = d4({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var It3 = d4({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var qt2 = d4({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Ut3 = d4({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ot3 = d4({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var St3 = d4({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Pt2 = d4({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nt3 = d4({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $t2 = d4({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt3 = Object.freeze({ __proto__: null, base32: Tt2, base32upper: It3, base32pad: qt2, base32padupper: Ut3, base32hex: Ot3, base32hexupper: St3, base32hexpad: Pt2, base32hexpadupper: Nt3, base32z: $t2 });
var zt3 = T2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jt3 = T2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt2 = Object.freeze({ __proto__: null, base36: zt3, base36upper: jt3 });
var Lt2 = T2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Kt2 = T2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt2 = Object.freeze({ __proto__: null, base58btc: Lt2, base58flickr: Kt2 });
var kt3 = d4({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Jt3 = d4({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Xt2 = d4({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gt3 = d4({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht2 = Object.freeze({ __proto__: null, base64: kt3, base64pad: Jt3, base64url: Xt2, base64urlpad: Gt3 });
var ne2 = Array.from("");
var Yt3 = ne2.reduce((r3, t, e) => (r3[e] = t, r3), []);
var Qt2 = ne2.reduce((r3, t, e) => (r3[t.codePointAt(0)] = e, r3), []);
function Zt2(r3) {
  return r3.reduce((t, e) => (t += Yt3[e], t), "");
}
function Wt3(r3) {
  const t = [];
  for (const e of r3) {
    const i3 = Qt2[e.codePointAt(0)];
    if (i3 === void 0) throw new Error(`Non-base256emoji character: ${e}`);
    t.push(i3);
  }
  return new Uint8Array(t);
}
var er3 = O3({ prefix: "", name: "base256emoji", encode: Zt2, decode: Wt3 });
var tr3 = Object.freeze({ __proto__: null, base256emoji: er3 });
var rr3 = oe;
var se3 = 128;
var ir3 = 127;
var nr3 = ~ir3;
var sr3 = Math.pow(2, 31);
function oe(r3, t, e) {
  t = t || [], e = e || 0;
  for (var i3 = e; r3 >= sr3; ) t[e++] = r3 & 255 | se3, r3 /= 128;
  for (; r3 & nr3; ) t[e++] = r3 & 255 | se3, r3 >>>= 7;
  return t[e] = r3 | 0, oe.bytes = e - i3 + 1, t;
}
var or3 = j3;
var ur2 = 128;
var ue3 = 127;
function j3(r3, i3) {
  var e = 0, i3 = i3 || 0, n4 = 0, s2 = i3, o4, u4 = r3.length;
  do {
    if (s2 >= u4) throw j3.bytes = 0, new RangeError("Could not decode varint");
    o4 = r3[s2++], e += n4 < 28 ? (o4 & ue3) << n4 : (o4 & ue3) * Math.pow(2, n4), n4 += 7;
  } while (o4 >= ur2);
  return j3.bytes = s2 - i3, e;
}
var ar3 = Math.pow(2, 7);
var Dr2 = Math.pow(2, 14);
var cr3 = Math.pow(2, 21);
var hr2 = Math.pow(2, 28);
var lr2 = Math.pow(2, 35);
var dr2 = Math.pow(2, 42);
var pr2 = Math.pow(2, 49);
var fr2 = Math.pow(2, 56);
var gr2 = Math.pow(2, 63);
var Er2 = function(r3) {
  return r3 < ar3 ? 1 : r3 < Dr2 ? 2 : r3 < cr3 ? 3 : r3 < hr2 ? 4 : r3 < lr2 ? 5 : r3 < dr2 ? 6 : r3 < pr2 ? 7 : r3 < fr2 ? 8 : r3 < gr2 ? 9 : 10;
};
var br2 = { encode: rr3, decode: or3, encodingLength: Er2 };
var ae2 = br2;
var De = (r3, t, e = 0) => (ae2.encode(r3, t, e), t);
var ce2 = (r3) => ae2.encodingLength(r3);
var M4 = (r3, t) => {
  const e = t.byteLength, i3 = ce2(r3), n4 = i3 + ce2(e), s2 = new Uint8Array(n4 + e);
  return De(r3, s2, 0), De(e, s2, i3), s2.set(t, n4), new yr3(r3, e, t, s2);
};
var yr3 = class {
  constructor(t, e, i3, n4) {
    this.code = t, this.size = e, this.digest = i3, this.bytes = n4;
  }
};
var he2 = ({ name: r3, code: t, encode: e }) => new wr2(r3, t, e);
var wr2 = class {
  constructor(t, e, i3) {
    this.name = t, this.code = e, this.encode = i3;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e = this.encode(t);
      return e instanceof Uint8Array ? M4(this.code, e) : e.then((i3) => M4(this.code, i3));
    } else throw Error("Unknown type, must be binary type");
  }
};
var le2 = (r3) => async (t) => new Uint8Array(await crypto.subtle.digest(r3, t));
var Cr2 = he2({ name: "sha2-256", code: 18, encode: le2("SHA-256") });
var mr3 = he2({ name: "sha2-512", code: 19, encode: le2("SHA-512") });
var vr2 = Object.freeze({ __proto__: null, sha256: Cr2, sha512: mr3 });
var de3 = 0;
var Ar2 = "identity";
var pe2 = re2;
var _r3 = (r3) => M4(de3, pe2(r3));
var xr2 = { code: de3, name: Ar2, encode: pe2, digest: _r3 };
var Rr3 = Object.freeze({ __proto__: null, identity: xr2 });
new TextEncoder(), new TextDecoder();
var fe3 = { ...yt2, ...Ct3, ...vt3, ..._t3, ...Ft3, ...Bt3, ...Mt2, ...Vt2, ...Ht2, ...tr3 };
({ ...vr2, ...Rr3 });
function ge(r3, t, e, i3) {
  return { name: r3, prefix: t, encoder: { name: r3, prefix: t, encode: e }, decoder: { decode: i3 } };
}
var Ee3 = ge("utf8", "u", (r3) => "u" + new TextDecoder("utf8").decode(r3), (r3) => new TextEncoder().encode(r3.substring(1)));
var L2 = ge("ascii", "a", (r3) => {
  let t = "a";
  for (let e = 0; e < r3.length; e++) t += String.fromCharCode(r3[e]);
  return t;
}, (r3) => {
  r3 = r3.substring(1);
  const t = ot2(r3.length);
  for (let e = 0; e < r3.length; e++) t[e] = r3.charCodeAt(e);
  return t;
});
var be3 = { utf8: Ee3, "utf-8": Ee3, hex: fe3.base16, latin1: L2, ascii: L2, binary: L2, ...fe3 };
function Fr2(r3, t = "utf8") {
  const e = be3[t];
  if (!e) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r3, "utf8") : e.decoder.decode(`${e.prefix}${r3}`);
}
function Tr3(r3, t = "utf8") {
  const e = be3[t];
  if (!e) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r3.buffer, r3.byteOffset, r3.byteLength).toString("utf8") : e.encoder.encode(r3).substring(1);
}
var ye2 = "base16";
var we3 = "utf8";
function K2(r3) {
  const t = (0, import_sha256.hash)(Fr2(r3, we3));
  return Tr3(t, ye2);
}
var Or2 = Object.defineProperty;
var Sr2 = Object.defineProperties;
var Pr2 = Object.getOwnPropertyDescriptors;
var Ce2 = Object.getOwnPropertySymbols;
var Nr2 = Object.prototype.hasOwnProperty;
var $r3 = Object.prototype.propertyIsEnumerable;
var me2 = (r3, t, e) => t in r3 ? Or2(r3, t, { enumerable: true, configurable: true, writable: true, value: e }) : r3[t] = e;
var I2 = (r3, t) => {
  for (var e in t || (t = {})) Nr2.call(t, e) && me2(r3, e, t[e]);
  if (Ce2) for (var e of Ce2(t)) $r3.call(t, e) && me2(r3, e, t[e]);
  return r3;
};
var V2 = (r3, t) => Sr2(r3, Pr2(t));
var Br3 = class extends G2 {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R3) }), this.initialized = true);
    }, this.request = async (e, i3) => {
      if (this.isInitialized(), !nt(e)) throw new Error("Invalid request");
      if (i3 != null && i3.topic) return await this.requestOnKnownPairing(i3.topic, e);
      const { chainId: n4, statement: s2, aud: o4, domain: u4, nonce: a5, type: c7, exp: h7, nbf: f7 } = e, { topic: p5, uri: A4 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: p5, uri: A4 } });
      const D7 = await this.client.core.crypto.generateKeyPair(), l7 = oi(D7);
      await this.client.authKeys.set(x4, { responseTopic: l7, publicKey: D7 }), await this.client.pairingTopics.set(l7, { topic: l7, pairingTopic: p5 }), await this.client.core.relayer.subscribe(l7), this.client.logger.info(`sending request to new pairing topic: ${p5}`);
      const m2 = await this.sendRequest(p5, "wc_authRequest", { payloadParams: { type: c7 ?? "eip4361", chainId: n4, statement: s2, aud: o4, domain: u4, version: "1", nonce: a5, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: h7, nbf: f7 }, requester: { publicKey: D7, metadata: this.client.metadata } }, {}, e.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${p5}`), { uri: A4, id: m2 };
    }, this.respond = async (e, i3) => {
      if (this.isInitialized(), !st2(e, this.client.requests)) throw new Error("Invalid response");
      const n4 = te3(this.client.requests, e.id);
      if (!n4) throw new Error(`Could not find pending auth request with id ${e.id}`);
      const s2 = n4.requester.publicKey, o4 = await this.client.core.crypto.generateKeyPair(), u4 = oi(s2), a5 = { type: Ie, receiverPublicKey: s2, senderPublicKey: o4 };
      if ("error" in e) {
        await this.sendError(n4.id, u4, e, a5);
        return;
      }
      const c7 = { h: { t: "eip4361" }, p: V2(I2({}, n4.cacaoPayload), { iss: i3 }), s: e.signature };
      await this.sendResult(n4.id, u4, c7, a5), await this.client.core.pairing.activate({ topic: n4.pairingTopic }), await this.client.requests.update(n4.id, I2({}, c7));
    }, this.getPendingRequests = () => ee3(this.client.requests), this.formatMessage = (e, i3) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);
      const n4 = `${e.domain} wants you to sign in with your Ethereum account:`, s2 = W(i3), o4 = e.statement, u4 = `URI: ${e.aud}`, a5 = `Version: ${e.version}`, c7 = `Chain ID: ${Ze(i3)}`, h7 = `Nonce: ${e.nonce}`, f7 = `Issued At: ${e.iat}`, p5 = e.exp ? `Expiry: ${e.exp}` : void 0, A4 = e.resources && e.resources.length > 0 ? `Resources:
${e.resources.map((D7) => `- ${D7}`).join(`
`)}` : void 0;
      return [n4, s2, "", o4, "", u4, a5, c7, h7, f7, p5, A4].filter((D7) => D7 != null).join(`
`);
    }, this.setExpiry = async (e, i3) => {
      this.client.core.pairing.pairings.keys.includes(e) && await this.client.core.pairing.updateExpiry({ topic: e, expiry: i3 }), this.client.core.expirer.set(e, i3);
    }, this.sendRequest = async (e, i3, n4, s2, o4) => {
      const u4 = formatJsonRpcRequest(i3, n4), a5 = await this.client.core.crypto.encode(e, u4, s2), c7 = R3[i3].req;
      if (o4 && (c7.ttl = o4), this.client.core.history.set(e, u4), Ae()) {
        const h7 = K2(JSON.stringify(u4));
        this.client.core.verify.register({ attestationId: h7 });
      }
      return await this.client.core.relayer.publish(e, a5, V2(I2({}, c7), { internal: { throwOnFailedPublish: true } })), u4.id;
    }, this.sendResult = async (e, i3, n4, s2) => {
      const o4 = formatJsonRpcResult(e, n4), u4 = await this.client.core.crypto.encode(i3, o4, s2), a5 = await this.client.core.history.get(i3, e), c7 = R3[a5.request.method].res;
      return await this.client.core.relayer.publish(i3, u4, V2(I2({}, c7), { internal: { throwOnFailedPublish: true } })), await this.client.core.history.resolve(o4), o4.id;
    }, this.sendError = async (e, i3, n4, s2) => {
      const o4 = formatJsonRpcError(e, n4.error), u4 = await this.client.core.crypto.encode(i3, o4, s2), a5 = await this.client.core.history.get(i3, e), c7 = R3[a5.request.method].res;
      return await this.client.core.relayer.publish(i3, u4, c7), await this.client.core.history.resolve(o4), o4.id;
    }, this.requestOnKnownPairing = async (e, i3) => {
      const n4 = this.client.core.pairing.pairings.getAll({ active: true }).find((A4) => A4.topic === e);
      if (!n4) throw new Error(`Could not find pairing for provided topic ${e}`);
      const { publicKey: s2 } = this.client.authKeys.get(x4), { chainId: o4, statement: u4, aud: a5, domain: c7, nonce: h7, type: f7 } = i3, p5 = await this.sendRequest(n4.topic, "wc_authRequest", { payloadParams: { type: f7 ?? "eip4361", chainId: o4, statement: u4, aud: a5, domain: c7, version: "1", nonce: h7, iat: (/* @__PURE__ */ new Date()).toISOString() }, requester: { publicKey: s2, metadata: this.client.metadata } }, {}, i3.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n4.topic}`), { id: p5 };
    }, this.onPairingCreated = (e) => {
      const i3 = this.getPendingRequests();
      if (i3) {
        const n4 = Object.values(i3).find((s2) => s2.pairingTopic === e.topic);
        n4 && this.handleAuthRequest(n4);
      }
    }, this.onRelayEventRequest = (e) => {
      const { topic: i3, payload: n4 } = e, s2 = n4.method;
      switch (s2) {
        case "wc_authRequest":
          return this.onAuthRequest(i3, n4);
        default:
          return this.client.logger.info(`Unsupported request method ${s2}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: i3, payload: n4 } = e, s2 = (await this.client.core.history.get(i3, n4.id)).request.method;
      switch (s2) {
        case "wc_authRequest":
          return this.onAuthResponse(i3, n4);
        default:
          return this.client.logger.info(`Unsupported response method ${s2}`);
      }
    }, this.onAuthRequest = async (e, i3) => {
      const { requester: n4, payloadParams: s2 } = i3.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e, payload: i3 });
      const o4 = K2(JSON.stringify(i3)), u4 = await this.getVerifyContext(o4, this.client.metadata), a5 = { requester: n4, pairingTopic: e, id: i3.id, cacaoPayload: s2, verifyContext: u4 };
      await this.client.requests.set(i3.id, a5), this.handleAuthRequest(a5);
    }, this.handleAuthRequest = async (e) => {
      const { id: i3, pairingTopic: n4, requester: s2, cacaoPayload: o4, verifyContext: u4 } = e;
      try {
        this.client.emit("auth_request", { id: i3, topic: n4, params: { requester: s2, cacaoPayload: o4 }, verifyContext: u4 });
      } catch (a5) {
        await this.sendError(e.id, e.pairingTopic, a5), this.client.logger.error(a5);
      }
    }, this.onAuthResponse = async (e, i3) => {
      const { id: n4 } = i3;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e, response: i3 }), isJsonRpcResult(i3)) {
        const { pairingTopic: s2 } = this.client.pairingTopics.get(e);
        await this.client.core.pairing.activate({ topic: s2 });
        const { s: o4, p: u4 } = i3.result;
        await this.client.requests.set(n4, I2({ id: n4, pairingTopic: s2 }, i3.result));
        const a5 = this.formatMessage(u4, u4.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a5)), this.client.logger.debug("payload.iss:", u4.iss), this.client.logger.debug("signature:", o4);
        const c7 = W(u4.iss), h7 = We2(u4.iss);
        if (!c7) throw new Error("Could not derive address from `payload.iss`");
        if (!h7) throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", c7), await et2(c7, a5, o4, h7, this.client.projectId) ? this.client.emit("auth_response", { id: n4, topic: e, params: i3 }) : this.client.emit("auth_response", { id: n4, topic: e, params: { message: "Invalid signature", code: -1 } });
      } else isJsonRpcError(i3) && this.client.emit("auth_response", { id: n4, topic: e, params: i3 });
    }, this.getVerifyContext = async (e, i3) => {
      const n4 = { verified: { verifyUrl: i3.verifyUrl || "", validation: "UNKNOWN", origin: i3.url || "" } };
      try {
        const s2 = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: i3.verifyUrl });
        s2 && (n4.verified.origin = s2.origin, n4.verified.isScam = s2.isScam, n4.verified.validation = origin === new URL(i3.url).origin ? "VALID" : "INVALID");
      } catch (s2) {
        this.client.logger.error(s2);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n4)}`), n4;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = te("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(T.message, async (t) => {
      const { topic: e, message: i3 } = t, { responseTopic: n4, publicKey: s2 } = this.client.authKeys.keys.includes(x4) ? this.client.authKeys.get(x4) : { responseTopic: void 0, publicKey: void 0 };
      if (n4 && e !== n4) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e);
        return;
      }
      const o4 = await this.client.core.crypto.decode(e, i3, { receiverPublicKey: s2 });
      isJsonRpcRequest(o4) ? (this.client.core.history.set(e, o4), this.onRelayEventRequest({ topic: e, payload: o4 })) : isJsonRpcResponse(o4) && (await this.client.core.history.resolve(o4), this.onRelayEventResponse({ topic: e, payload: o4 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(se2.create, (t) => this.onPairingCreated(t));
  }
};
var S3 = class _S extends H3 {
  constructor(t) {
    super(t), this.protocol = $2, this.version = Q2, this.name = B2, this.events = new import_events8.EventEmitter(), this.emit = (i3, n4) => this.events.emit(i3, n4), this.on = (i3, n4) => this.events.on(i3, n4), this.once = (i3, n4) => this.events.once(i3, n4), this.off = (i3, n4) => this.events.off(i3, n4), this.removeListener = (i3, n4) => this.events.removeListener(i3, n4), this.request = async (i3, n4) => {
      try {
        return await this.engine.request(i3, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (i3, n4) => {
      try {
        return await this.engine.respond(i3, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatMessage = (i3, n4) => {
      try {
        return this.engine.formatMessage(i3, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    };
    const e = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_pino.default)(k({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B2, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new co2(t), this.logger = E(e, this.name), this.authKeys = new Ci(this.core, this.logger, "authKeys", F3, () => x4), this.pairingTopics = new Ci(this.core, this.logger, "pairingTopics", F3), this.requests = new Ci(this.core, this.logger, "requests", F3, (i3) => i3.id), this.engine = new Br3(this);
  }
  static async init(t) {
    const e = new _S(t);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var zr3 = S3;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_events12 = __toESM(require_events());

// node_modules/@walletconnect/web3wallet/node_modules/unstorage/dist/shared/unstorage.mNKHTF5Y.mjs
function wrapToPromise2(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall2(function_, ...arguments_) {
  try {
    return wrapToPromise2(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive2(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject2(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify2(value) {
  if (isPrimitive2(value)) {
    return String(value);
  }
  if (isPureObject2(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify2(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX2 = "base64:";
function serializeRaw2(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX2 + base64Encode2(value);
}
function deserializeRaw2(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX2)) {
    return value;
  }
  return base64Decode2(value.slice(BASE64_PREFIX2.length));
}
function base64Decode2(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c7) => c7.codePointAt(0)
  );
}
function base64Encode2(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey2(key) {
  var _a;
  if (!key) {
    return "";
  }
  return ((_a = key.split("?")[0]) == null ? void 0 : _a.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys2(...keys2) {
  return normalizeKey2(keys2.join(":"));
}
function normalizeBaseKey2(base) {
  base = normalizeKey2(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth2(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase2(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@walletconnect/web3wallet/node_modules/unstorage/dist/index.mjs
function defineDriver2(factory) {
  return factory;
}
var DRIVER_NAME2 = "memory";
var memory2 = defineDriver2(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME2,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage2(options = {}) {
  const context = {
    mounts: { "": options.driver || memory2() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey2(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch2(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey2(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r3) => r3.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall2(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall2(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall2(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r3) => r3.map((item) => ({
              key: joinKeys2(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall2(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall2(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall2(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw2(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall2(driver.setItem, relativeKey, stringify2(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall2(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify2(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall2(
              batch.driver.setItem,
              item.relativeKey,
              stringify2(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall2(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall2(driver.setItem, relativeKey, serializeRaw2(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall2(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall2(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey2(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall2(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall2(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      var _a;
      base = normalizeBaseKey2(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a = mount.driver.flags) == null ? void 0 : _a.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall2(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey2(key);
          if (!maskedMounts.some((p5) => fullKey.startsWith(p5))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p5) => !p5.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth2(key, opts.maxDepth)) && filterKeyByBase2(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey2(base);
      await Promise.all(
        getMounts(base, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall2(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m2.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose2(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey2(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a5, b7) => b7.length - a5.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch2(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      var _a, _b;
      base = normalizeBaseKey2(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        (_b = (_a = context.unwatch)[base]) == null ? void 0 : _b.call(_a);
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose2(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey2(key) + ":";
      const m2 = getMount(key);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey2(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch2(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose2(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall2(driver.dispose);
  }
}

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x5 = "idb-keyval";
var z5 = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e = (s2) => t + s2;
  let n4;
  return i3.dbName && i3.storeName && (n4 = createStore(i3.dbName, i3.storeName)), { name: x5, options: i3, async hasItem(s2) {
    return !(typeof await get(e(s2), n4) > "u");
  }, async getItem(s2) {
    return await get(e(s2), n4) ?? null;
  }, setItem(s2, a5) {
    return set(e(s2), a5, n4);
  }, removeItem(s2) {
    return del(e(s2), n4);
  }, getKeys() {
    return keys(n4);
  }, clear() {
    return clear(n4);
  } };
};
var D3 = "WALLET_CONNECT_V2_INDEXED_DB";
var E4 = "keyvaluestorage";
var _3 = class {
  constructor() {
    this.indexedDb = createStorage2({ driver: z5({ dbName: D3, storeName: E4 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null) return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l5 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c4 = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i3.prototype.setItem = function(e, n4) {
    this[e] = String(n4);
  }, i3.prototype.removeItem = function(e) {
    delete this[e];
  }, i3.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n4) {
      e[n4] = void 0, delete e[n4];
    });
  }, i3.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l5 < "u" && l5.localStorage ? c4.exports = l5.localStorage : typeof window < "u" && window.localStorage ? c4.exports = window.localStorage : c4.exports = new t();
})();
function k3(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K3 = class {
  constructor() {
    this.localStorage = c4.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k3);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null) return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N3 = "wc_storage_version";
var y4 = 1;
var O4 = async (i3, t, e) => {
  const n4 = N3, s2 = await t.getItem(n4);
  if (s2 && s2 >= y4) {
    e(t);
    return;
  }
  const a5 = await i3.getKeys();
  if (!a5.length) {
    e(t);
    return;
  }
  const m2 = [];
  for (; a5.length; ) {
    const r3 = a5.shift();
    if (!r3) continue;
    const o4 = r3.toLowerCase();
    if (o4.includes("wc@") || o4.includes("walletconnect") || o4.includes("wc_") || o4.includes("wallet_connect")) {
      const f7 = await i3.getItem(r3);
      await t.setItem(r3, f7), m2.push(r3);
    }
  }
  await t.setItem(n4, y4), e(t), j4(i3, m2);
};
var j4 = async (i3, t) => {
  t.length && t.forEach(async (e) => {
    await i3.removeItem(e);
  });
};
var h4 = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K3();
    this.storage = t;
    try {
      const e = new _3();
      O4(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/types/dist/index.es.js
init_esm();
var import_events10 = __toESM(require_events());
var n3 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var h5 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a3 = class {
  constructor(s2, t) {
    this.logger = s2, this.core = t;
  }
};
var g2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var u2 = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var p3 = class {
  constructor(s2, t, e, f7) {
    this.core = s2, this.logger = t, this.name = e;
  }
};
var d5 = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var x6 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t;
  }
};
var y5 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.store = e;
  }
};
var v3 = class {
  constructor(s2, t) {
    this.projectId = s2, this.logger = t;
  }
};
var C3 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.telemetryEnabled = e;
  }
};
var S4 = class {
  constructor(s2) {
    this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var M5 = class {
  constructor(s2) {
    this.client = s2;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_time7 = __toESM(require_cjs());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/api.js
var ed25519 = __toESM(require_ed25519());
var import_random2 = __toESM(require_random());
var import_time5 = __toESM(require_cjs());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/constants.js
var JWT_IRIDIUM_ALG = "EdDSA";
var JWT_IRIDIUM_TYP = "JWT";
var JWT_DELIMITER = ".";
var JWT_ENCODING = "base64url";
var JSON_ENCODING = "utf8";
var DATA_ENCODING = "utf8";
var DID_DELIMITER = ":";
var DID_PREFIX = "did";
var DID_METHOD = "key";
var MULTICODEC_ED25519_ENCODING = "base58btc";
var MULTICODEC_ED25519_BASE = "z";
var MULTICODEC_ED25519_HEADER = "K36";
var KEY_PAIR_SEED_LENGTH = 32;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/utils.js
init_concat();
init_to_string();
init_from_string();
function decodeJSON(str) {
  return safeJsonParse(toString(fromString(str, JWT_ENCODING), JSON_ENCODING));
}
function encodeJSON(val) {
  return toString(fromString(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(publicKey) {
  const header = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
  const multicodec = MULTICODEC_ED25519_BASE + toString(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
}
function encodeSig(bytes) {
  return toString(bytes, JWT_ENCODING);
}
function decodeSig(encoded) {
  return fromString(encoded, JWT_ENCODING);
}
function encodeData(params) {
  return fromString([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(params) {
  return [
    encodeJSON(params.header),
    encodeJSON(params.payload),
    encodeSig(params.signature)
  ].join(JWT_DELIMITER);
}
function decodeJWT(jwt) {
  const params = jwt.split(JWT_DELIMITER);
  const header = decodeJSON(params[0]);
  const payload = decodeJSON(params[1]);
  const signature = decodeSig(params[2]);
  const data = fromString(params.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);
  return { header, payload, signature, data };
}

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/relay-auth/dist/esm/api.js
function generateKeyPair(seed = (0, import_random2.randomBytes)(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(seed);
}
async function signJWT(sub, aud, ttl, keyPair, iat = (0, import_time5.fromMiliseconds)(Date.now())) {
  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
  const iss = encodeIss(keyPair.publicKey);
  const exp = iat + ttl;
  const payload = { iss, sub, aud, iat, exp };
  const data = encodeData({ header, payload });
  const signature = ed25519.sign(keyPair.secretKey, data);
  return encodeJWT({ header, payload, signature });
}

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/utils/dist/index.es.js
var import_time6 = __toESM(require_cjs());
var import_window_getters3 = __toESM(require_cjs2());
var import_window_metadata2 = __toESM(require_cjs3());
var q3 = __toESM(require_query_string());
init_lib();
init_lib2();
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random3 = __toESM(require_random());
var import_sha2562 = __toESM(require_sha256());
var _e3 = __toESM(require_x25519());
var import_elliptic2 = __toESM(require_elliptic2());
var H4 = ":";
function re3(e) {
  const [n4, t] = e.split(H4);
  return { namespace: n4, reference: t };
}
function W2(e, n4) {
  return e.includes(":") ? [e] : n4.chains || [];
}
var gt3 = Object.defineProperty;
var Ke4 = Object.getOwnPropertySymbols;
var vt4 = Object.prototype.hasOwnProperty;
var bt4 = Object.prototype.propertyIsEnumerable;
var Le3 = (e, n4, t) => n4 in e ? gt3(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var Fe3 = (e, n4) => {
  for (var t in n4 || (n4 = {})) vt4.call(n4, t) && Le3(e, t, n4[t]);
  if (Ke4) for (var t of Ke4(n4)) bt4.call(n4, t) && Le3(e, t, n4[t]);
  return e;
};
var qe2 = "ReactNative";
var y6 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var He2 = "js";
function ce3() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function _4() {
  return !(0, import_window_getters3.getDocument)() && !!(0, import_window_getters3.getNavigator)() && navigator.product === qe2;
}
function V3() {
  return !ce3() && !!(0, import_window_getters3.getNavigator)() && !!(0, import_window_getters3.getDocument)();
}
function P3() {
  return _4() ? y6.reactNative : ce3() ? y6.node : V3() ? y6.browser : y6.unknown;
}
function Ot4() {
  var e;
  try {
    return _4() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function We3(e, n4) {
  let t = q3.parse(e);
  return t = Fe3(Fe3({}, t), n4), e = q3.stringify(t), e;
}
function Nt4() {
  return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function Je3() {
  if (P3() === y6.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: r3 } = global.Platform;
    return [t, r3].join("-");
  }
  const e = detect();
  if (e === null) return "unknown";
  const n4 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n4, e.name, e.version].join("-") : [n4, e.version].join("-");
}
function ze3() {
  var e;
  const n4 = P3();
  return n4 === y6.browser ? [n4, ((e = (0, import_window_getters3.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n4;
}
function Ge3(e, n4, t) {
  const r3 = Je3(), o4 = ze3();
  return [[e, n4].join("-"), [He2, t].join("-"), r3, o4].join("/");
}
function $t3({ protocol: e, version: n4, relayUrl: t, sdkVersion: r3, auth: o4, projectId: s2, useOnCloseEvent: i3, bundleId: u4 }) {
  const l7 = t.split("?"), c7 = Ge3(e, n4, r3), d6 = { auth: o4, ua: c7, projectId: s2, useOnCloseEvent: i3 || void 0, origin: u4 || void 0 }, a5 = We3(l7[1] || "", d6);
  return l7[0] + "?" + a5;
}
function $3(e, n4) {
  return e.filter((t) => n4.includes(t)).length === e.length;
}
function Tt3(e) {
  return Object.fromEntries(e.entries());
}
function Pt3(e) {
  return new Map(Object.entries(e));
}
function _t4(e = import_time6.FIVE_MINUTES, n4) {
  const t = (0, import_time6.toMiliseconds)(e || import_time6.FIVE_MINUTES);
  let r3, o4, s2;
  return { resolve: (i3) => {
    s2 && r3 && (clearTimeout(s2), r3(i3));
  }, reject: (i3) => {
    s2 && o4 && (clearTimeout(s2), o4(i3));
  }, done: () => new Promise((i3, u4) => {
    s2 = setTimeout(() => {
      u4(new Error(n4));
    }, t), r3 = i3, o4 = u4;
  }) };
}
function kt4(e, n4, t) {
  return new Promise(async (r3, o4) => {
    const s2 = setTimeout(() => o4(new Error(t)), n4);
    try {
      const i3 = await e;
      r3(i3);
    } catch (i3) {
      o4(i3);
    }
    clearTimeout(s2);
  });
}
function ae3(e, n4) {
  if (typeof n4 == "string" && n4.startsWith(`${e}:`)) return n4;
  if (e.toLowerCase() === "topic") {
    if (typeof n4 != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n4}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n4 != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n4}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function Dt2(e) {
  return ae3("topic", e);
}
function xt4(e) {
  return ae3("id", e);
}
function Vt3(e) {
  const [n4, t] = e.split(":"), r3 = { id: void 0, topic: void 0 };
  if (n4 === "topic" && typeof t == "string") r3.topic = t;
  else if (n4 === "id" && Number.isInteger(Number(t))) r3.id = Number(t);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${n4}:${t}`);
  return r3;
}
function Mt3(e, n4) {
  return (0, import_time6.fromMiliseconds)((n4 || Date.now()) + (0, import_time6.toMiliseconds)(e));
}
function Kt3(e) {
  return Date.now() >= (0, import_time6.toMiliseconds)(e);
}
function Lt3(e, n4) {
  return `${e}${n4 ? `:${n4}` : ""}`;
}
function N4(e = [], n4 = []) {
  return [.../* @__PURE__ */ new Set([...e, ...n4])];
}
async function Ft4({ id: e, topic: n4, wcDeepLink: t }) {
  var r3;
  try {
    if (!t) return;
    const o4 = typeof t == "string" ? JSON.parse(t) : t, s2 = o4 == null ? void 0 : o4.href;
    if (typeof s2 != "string") return;
    const i3 = Xe2(s2, e, n4), u4 = P3();
    if (u4 === y6.browser) {
      if (!((r3 = (0, import_window_getters3.getDocument)()) != null && r3.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      i3.startsWith("https://") || i3.startsWith("http://") ? window.open(i3, "_blank", "noreferrer noopener") : window.open(i3, en2() ? "_blank" : "_self", "noreferrer noopener");
    } else u4 === y6.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i3);
  } catch (o4) {
    console.error(o4);
  }
}
function Xe2(e, n4, t) {
  const r3 = `requestId=${n4}&sessionTopic=${t}`;
  e.endsWith("/") && (e = e.slice(0, -1));
  let o4 = `${e}`;
  if (e.startsWith("https://t.me")) {
    const s2 = e.includes("?") ? "&startapp=" : "?startapp=";
    o4 = `${o4}${s2}${nn2(r3, true)}`;
  } else o4 = `${o4}/wc?${r3}`;
  return o4;
}
async function qt3(e, n4) {
  let t = "";
  try {
    if (V3() && (t = localStorage.getItem(n4), t)) return t;
    t = await e.getItem(n4);
  } catch (r3) {
    console.error(r3);
  }
  return t;
}
function Bt4(e, n4) {
  if (!e.includes(n4)) return null;
  const t = e.split(/([&,?,=])/), r3 = t.indexOf(n4);
  return t[r3 + 2];
}
function Ht3() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
    const n4 = Math.random() * 16 | 0;
    return (e === "x" ? n4 : n4 & 3 | 8).toString(16);
  });
}
function Wt4() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function en2() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function nn2(e, n4 = false) {
  const t = Buffer.from(e).toString("base64");
  return n4 ? t.replace(/[=]/g, "") : t;
}
function le3(e) {
  return Buffer.from(e, "base64").toString("utf-8");
}
var Jt4 = "https://rpc.walletconnect.org/v1";
async function tn2(e, n4, t, r3, o4, s2) {
  switch (t.t) {
    case "eip191":
      return rn2(e, n4, t.s);
    case "eip1271":
      return await on2(e, n4, t.s, r3, o4, s2);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`);
  }
}
function rn2(e, n4, t) {
  return recoverAddress(hashMessage(n4), t).toLowerCase() === e.toLowerCase();
}
async function on2(e, n4, t, r3, o4, s2) {
  const i3 = re3(r3);
  if (!i3.namespace || !i3.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r3}`);
  try {
    const u4 = "0x1626ba7e", l7 = "0000000000000000000000000000000000000000000000000000000000000040", c7 = "0000000000000000000000000000000000000000000000000000000000000041", d6 = t.substring(2), a5 = hashMessage(n4).substring(2), f7 = u4 + a5 + l7 + c7 + d6, h7 = await fetch(`${s2 || Jt4}/?chainId=${r3}&projectId=${o4}`, { method: "POST", body: JSON.stringify({ id: zt4(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e, data: f7 }, "latest"] }) }), { result: p5 } = await h7.json();
    return p5 ? p5.slice(0, u4.length).toLowerCase() === u4.toLowerCase() : false;
  } catch (u4) {
    return console.error("isValidEip1271Signature: ", u4), false;
  }
}
function zt4() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Gt4 = Object.defineProperty;
var Yt4 = Object.defineProperties;
var Qt3 = Object.getOwnPropertyDescriptors;
var sn4 = Object.getOwnPropertySymbols;
var Zt3 = Object.prototype.hasOwnProperty;
var Xt3 = Object.prototype.propertyIsEnumerable;
var cn3 = (e, n4, t) => n4 in e ? Gt4(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var de4 = (e, n4) => {
  for (var t in n4 || (n4 = {})) Zt3.call(n4, t) && cn3(e, t, n4[t]);
  if (sn4) for (var t of sn4(n4)) Xt3.call(n4, t) && cn3(e, t, n4[t]);
  return e;
};
var an3 = (e, n4) => Yt4(e, Qt3(n4));
var er4 = "did:pkh:";
var z6 = (e) => e == null ? void 0 : e.split(":");
var un3 = (e) => {
  const n4 = e && z6(e);
  if (n4) return e.includes(er4) ? n4[3] : n4[1];
};
var ln3 = (e) => {
  const n4 = e && z6(e);
  if (n4) return n4[2] + ":" + n4[3];
};
var fe4 = (e) => {
  const n4 = e && z6(e);
  if (n4) return n4.pop();
};
async function nr4(e) {
  const { cacao: n4, projectId: t } = e, { s: r3, p: o4 } = n4, s2 = dn3(o4, o4.iss), i3 = fe4(o4.iss);
  return await tn2(i3, s2, r3, ln3(o4.iss), t);
}
var dn3 = (e, n4) => {
  const t = `${e.domain} wants you to sign in with your Ethereum account:`, r3 = fe4(n4);
  if (!e.aud && !e.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o4 = e.statement || void 0;
  const s2 = `URI: ${e.aud || e.uri}`, i3 = `Version: ${e.version}`, u4 = `Chain ID: ${un3(n4)}`, l7 = `Nonce: ${e.nonce}`, c7 = `Issued At: ${e.iat}`, d6 = e.exp ? `Expiration Time: ${e.exp}` : void 0, a5 = e.nbf ? `Not Before: ${e.nbf}` : void 0, f7 = e.requestId ? `Request ID: ${e.requestId}` : void 0, h7 = e.resources ? `Resources:${e.resources.map((m2) => `
- ${m2}`).join("")}` : void 0, p5 = Y2(e.resources);
  if (p5) {
    const m2 = R4(p5);
    o4 = he3(o4, m2);
  }
  return [t, r3, "", o4, "", s2, i3, u4, l7, c7, d6, a5, f7, h7].filter((m2) => m2 != null).join(`
`);
};
function hn3(e) {
  return Buffer.from(JSON.stringify(e)).toString("base64");
}
function yn2(e) {
  return JSON.parse(Buffer.from(e, "base64").toString("utf-8"));
}
function O5(e) {
  if (!e) throw new Error("No recap provided, value is undefined");
  if (!e.att) throw new Error("No `att` property found");
  const n4 = Object.keys(e.att);
  if (!(n4 != null && n4.length)) throw new Error("No resources found in `att` property");
  n4.forEach((t) => {
    const r3 = e.att[t];
    if (Array.isArray(r3)) throw new Error(`Resource must be an object: ${t}`);
    if (typeof r3 != "object") throw new Error(`Resource must be an object: ${t}`);
    if (!Object.keys(r3).length) throw new Error(`Resource object is empty: ${t}`);
    Object.keys(r3).forEach((o4) => {
      const s2 = r3[o4];
      if (!Array.isArray(s2)) throw new Error(`Ability limits ${o4} must be an array of objects, found: ${s2}`);
      if (!s2.length) throw new Error(`Value of ${o4} is empty array, must be an array with objects`);
      s2.forEach((i3) => {
        if (typeof i3 != "object") throw new Error(`Ability limits (${o4}) must be an array of objects, found: ${i3}`);
      });
    });
  });
}
function gn3(e, n4, t, r3 = {}) {
  return t == null ? void 0 : t.sort((o4, s2) => o4.localeCompare(s2)), { att: { [e]: pe3(n4, t, r3) } };
}
function pe3(e, n4, t = {}) {
  n4 = n4 == null ? void 0 : n4.sort((o4, s2) => o4.localeCompare(s2));
  const r3 = n4.map((o4) => ({ [`${e}/${o4}`]: [t] }));
  return Object.assign({}, ...r3);
}
function G3(e) {
  return O5(e), `urn:recap:${hn3(e).replace(/=/g, "")}`;
}
function R4(e) {
  const n4 = yn2(e.replace("urn:recap:", ""));
  return O5(n4), n4;
}
function ir4(e, n4, t) {
  const r3 = gn3(e, n4, t);
  return G3(r3);
}
function me3(e) {
  return e && e.includes("urn:recap:");
}
function cr4(e, n4) {
  const t = R4(e), r3 = R4(n4), o4 = bn2(t, r3);
  return G3(o4);
}
function bn2(e, n4) {
  O5(e), O5(n4);
  const t = Object.keys(e.att).concat(Object.keys(n4.att)).sort((o4, s2) => o4.localeCompare(s2)), r3 = { att: {} };
  return t.forEach((o4) => {
    var s2, i3;
    Object.keys(((s2 = e.att) == null ? void 0 : s2[o4]) || {}).concat(Object.keys(((i3 = n4.att) == null ? void 0 : i3[o4]) || {})).sort((u4, l7) => u4.localeCompare(l7)).forEach((u4) => {
      var l7, c7;
      r3.att[o4] = an3(de4({}, r3.att[o4]), { [u4]: ((l7 = e.att[o4]) == null ? void 0 : l7[u4]) || ((c7 = n4.att[o4]) == null ? void 0 : c7[u4]) });
    });
  }), r3;
}
function he3(e = "", n4) {
  O5(n4);
  const t = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (e.includes(t)) return e;
  const r3 = [];
  let o4 = 0;
  Object.keys(n4.att).forEach((u4) => {
    const l7 = Object.keys(n4.att[u4]).map((a5) => ({ ability: a5.split("/")[0], action: a5.split("/")[1] }));
    l7.sort((a5, f7) => a5.action.localeCompare(f7.action));
    const c7 = {};
    l7.forEach((a5) => {
      c7[a5.ability] || (c7[a5.ability] = []), c7[a5.ability].push(a5.action);
    });
    const d6 = Object.keys(c7).map((a5) => (o4++, `(${o4}) '${a5}': '${c7[a5].join("', '")}' for '${u4}'.`));
    r3.push(d6.join(", ").replace(".,", "."));
  });
  const s2 = r3.join(" "), i3 = `${t}${s2}`;
  return `${e ? e + " " : ""}${i3}`;
}
function ar4(e) {
  var n4;
  const t = R4(e);
  O5(t);
  const r3 = (n4 = t.att) == null ? void 0 : n4.eip155;
  return r3 ? Object.keys(r3).map((o4) => o4.split("/")[1]) : [];
}
function ur3(e) {
  const n4 = R4(e);
  O5(n4);
  const t = [];
  return Object.values(n4.att).forEach((r3) => {
    Object.values(r3).forEach((o4) => {
      var s2;
      (s2 = o4 == null ? void 0 : o4[0]) != null && s2.chains && t.push(o4[0].chains);
    });
  }), [...new Set(t.flat())];
}
function Y2(e) {
  if (!e) return;
  const n4 = e == null ? void 0 : e[e.length - 1];
  return me3(n4) ? n4 : void 0;
}
var ye3 = "base10";
var g3 = "base16";
var ge2 = "base64pad";
var lr3 = "base64url";
var k4 = "utf8";
var ve3 = 0;
var D4 = 1;
var M6 = 2;
var dr3 = 0;
var wn2 = 1;
var K4 = 12;
var be4 = 32;
function fr3() {
  const e = _e3.generateKeyPair();
  return { privateKey: toString(e.secretKey, g3), publicKey: toString(e.publicKey, g3) };
}
function pr3() {
  const e = (0, import_random3.randomBytes)(be4);
  return toString(e, g3);
}
function mr4(e, n4) {
  const t = _e3.sharedKey(fromString(e, g3), fromString(n4, g3), true), r3 = new import_hkdf.HKDF(import_sha2562.SHA256, t).expand(be4);
  return toString(r3, g3);
}
function hr3(e) {
  const n4 = (0, import_sha2562.hash)(fromString(e, g3));
  return toString(n4, g3);
}
function yr4(e) {
  const n4 = (0, import_sha2562.hash)(fromString(e, k4));
  return toString(n4, g3);
}
function Ee4(e) {
  return fromString(`${e}`, ye3);
}
function A2(e) {
  return Number(toString(e, ye3));
}
function gr3(e) {
  const n4 = Ee4(typeof e.type < "u" ? e.type : ve3);
  if (A2(n4) === D4 && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, g3) : void 0, r3 = typeof e.iv < "u" ? fromString(e.iv, g3) : (0, import_random3.randomBytes)(K4), o4 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, g3)).seal(r3, fromString(e.message, k4));
  return we4({ type: n4, sealed: o4, iv: r3, senderPublicKey: t, encoding: e.encoding });
}
function vr3(e, n4) {
  const t = Ee4(M6), r3 = (0, import_random3.randomBytes)(K4), o4 = fromString(e, k4);
  return we4({ type: t, sealed: o4, iv: r3, encoding: n4 });
}
function br3(e) {
  const n4 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, g3)), { sealed: t, iv: r3 } = Q3({ encoded: e.encoded, encoding: e == null ? void 0 : e.encoding }), o4 = n4.open(r3, t);
  if (o4 === null) throw new Error("Failed to decrypt");
  return toString(o4, k4);
}
function Er3(e, n4) {
  const { sealed: t } = Q3({ encoded: e, encoding: n4 });
  return toString(t, k4);
}
function we4(e) {
  const { encoding: n4 = ge2 } = e;
  if (A2(e.type) === M6) return toString(concat([e.type, e.sealed]), n4);
  if (A2(e.type) === D4) {
    if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), n4);
  }
  return toString(concat([e.type, e.iv, e.sealed]), n4);
}
function Q3(e) {
  const { encoded: n4, encoding: t = ge2 } = e, r3 = fromString(n4, t), o4 = r3.slice(dr3, wn2), s2 = wn2;
  if (A2(o4) === D4) {
    const c7 = s2 + be4, d6 = c7 + K4, a5 = r3.slice(s2, c7), f7 = r3.slice(c7, d6), h7 = r3.slice(d6);
    return { type: o4, sealed: h7, iv: f7, senderPublicKey: a5 };
  }
  if (A2(o4) === M6) {
    const c7 = r3.slice(s2), d6 = (0, import_random3.randomBytes)(K4);
    return { type: o4, sealed: c7, iv: d6 };
  }
  const i3 = s2 + K4, u4 = r3.slice(s2, i3), l7 = r3.slice(i3);
  return { type: o4, sealed: l7, iv: u4 };
}
function wr3(e, n4) {
  const t = Q3({ encoded: e, encoding: n4 == null ? void 0 : n4.encoding });
  return On2({ type: A2(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, g3) : void 0, receiverPublicKey: n4 == null ? void 0 : n4.receiverPublicKey });
}
function On2(e) {
  const n4 = (e == null ? void 0 : e.type) || ve3;
  if (n4 === D4) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: n4, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Or3(e) {
  return e.type === D4 && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function Nr3(e) {
  return e.type === M6;
}
function Nn2(e) {
  return new import_elliptic2.ec("p256").keyFromPublic({ x: Buffer.from(e.x, "base64").toString("hex"), y: Buffer.from(e.y, "base64").toString("hex") }, "hex");
}
function Sr3(e) {
  let n4 = e.replace(/-/g, "+").replace(/_/g, "/");
  const t = n4.length % 4;
  return t > 0 && (n4 += "=".repeat(4 - t)), n4;
}
function $r4(e) {
  return Buffer.from(Sr3(e), "base64");
}
function Rr4(e, n4) {
  const [t, r3, o4] = e.split("."), s2 = $r4(o4);
  if (s2.length !== 64) throw new Error("Invalid signature length");
  const i3 = s2.slice(0, 32).toString("hex"), u4 = s2.slice(32, 64).toString("hex"), l7 = `${t}.${r3}`, c7 = new import_sha2562.SHA256().update(Buffer.from(l7)).digest(), d6 = Nn2(n4), a5 = Buffer.from(c7).toString("hex");
  if (!d6.verify(a5, { r: i3, s: u4 })) throw new Error("Invalid signature");
  return decodeJWT(e).payload;
}
var Sn2 = "irn";
function Ir2(e) {
  return (e == null ? void 0 : e.relay) || { protocol: Sn2 };
}
function jr2(e) {
  const n4 = C[e];
  if (typeof n4 > "u") throw new Error(`Relay Protocol not supported: ${e}`);
  return n4;
}
var Tr4 = Object.defineProperty;
var Pr3 = Object.defineProperties;
var Ar3 = Object.getOwnPropertyDescriptors;
var $n2 = Object.getOwnPropertySymbols;
var Cr3 = Object.prototype.hasOwnProperty;
var Ur3 = Object.prototype.propertyIsEnumerable;
var Rn2 = (e, n4, t) => n4 in e ? Tr4(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var In2 = (e, n4) => {
  for (var t in n4 || (n4 = {})) Cr3.call(n4, t) && Rn2(e, t, n4[t]);
  if ($n2) for (var t of $n2(n4)) Ur3.call(n4, t) && Rn2(e, t, n4[t]);
  return e;
};
var _r4 = (e, n4) => Pr3(e, Ar3(n4));
function jn3(e, n4 = "-") {
  const t = {}, r3 = "relay" + n4;
  return Object.keys(e).forEach((o4) => {
    if (o4.startsWith(r3)) {
      const s2 = o4.replace(r3, ""), i3 = e[o4];
      t[s2] = i3;
    }
  }), t;
}
function kr3(e) {
  if (!e.includes("wc:")) {
    const l7 = le3(e);
    l7 != null && l7.includes("wc:") && (e = l7);
  }
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const n4 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r3 = e.substring(0, n4), o4 = e.substring(n4 + 1, t).split("@"), s2 = typeof t < "u" ? e.substring(t) : "", i3 = q3.parse(s2), u4 = typeof i3.methods == "string" ? i3.methods.split(",") : void 0;
  return { protocol: r3, topic: Tn2(o4[0]), version: parseInt(o4[1], 10), symKey: i3.symKey, relay: jn3(i3), methods: u4, expiryTimestamp: i3.expiryTimestamp ? parseInt(i3.expiryTimestamp, 10) : void 0 };
}
function Tn2(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function Pn2(e, n4 = "-") {
  const t = "relay", r3 = {};
  return Object.keys(e).forEach((o4) => {
    const s2 = t + n4 + o4;
    e[o4] && (r3[s2] = e[o4]);
  }), r3;
}
function Dr3(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + q3.stringify(In2(_r4(In2({ symKey: e.symKey }, Pn2(e.relay)), { expiryTimestamp: e.expiryTimestamp }), e.methods ? { methods: e.methods.join(",") } : {}));
}
function xr3(e, n4, t) {
  return `${e}?wc_ev=${t}&topic=${n4}`;
}
function C4(e) {
  const n4 = [];
  return e.forEach((t) => {
    const [r3, o4] = t.split(":");
    n4.push(`${r3}:${o4}`);
  }), n4;
}
function Un2(e) {
  const n4 = [];
  return Object.values(e).forEach((t) => {
    n4.push(...C4(t.accounts));
  }), n4;
}
function _n2(e, n4) {
  const t = [];
  return Object.values(e).forEach((r3) => {
    C4(r3.accounts).includes(n4) && t.push(...r3.methods);
  }), t;
}
function kn3(e, n4) {
  const t = [];
  return Object.values(e).forEach((r3) => {
    C4(r3.accounts).includes(n4) && t.push(...r3.events);
  }), t;
}
function xn2(e) {
  const n4 = {};
  return e == null ? void 0 : e.forEach((t) => {
    const [r3, o4] = t.split(":");
    n4[r3] || (n4[r3] = { accounts: [], chains: [], events: [] }), n4[r3].accounts.push(t), n4[r3].chains.push(`${r3}:${o4}`);
  }), n4;
}
function Jr3(e, n4) {
  n4 = n4.map((r3) => r3.replace("did:pkh:", ""));
  const t = xn2(n4);
  for (const [r3, o4] of Object.entries(t)) o4.methods ? o4.methods = N4(o4.methods, e) : o4.methods = e, o4.events = ["chainChanged", "accountsChanged"];
  return t;
}
var Vn3 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Mn3 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function S5(e, n4) {
  const { message: t, code: r3 } = Mn3[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r3 };
}
function U3(e, n4) {
  const { message: t, code: r3 } = Vn3[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r3 };
}
function L3(e, n4) {
  return Array.isArray(e) ? typeof n4 < "u" && e.length ? e.every(n4) : true : false;
}
function Z3(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function I3(e) {
  return typeof e > "u";
}
function b3(e, n4) {
  return n4 && I3(e) ? true : typeof e == "string" && !!e.trim().length;
}
function X(e, n4) {
  return n4 && I3(e) ? true : typeof e == "number" && !isNaN(e);
}
function zr4(e, n4) {
  const { requiredNamespaces: t } = n4, r3 = Object.keys(e.namespaces), o4 = Object.keys(t);
  let s2 = true;
  return $3(o4, r3) ? (r3.forEach((i3) => {
    const { accounts: u4, methods: l7, events: c7 } = e.namespaces[i3], d6 = C4(u4), a5 = t[i3];
    (!$3(W2(i3, a5), d6) || !$3(a5.methods, l7) || !$3(a5.events, c7)) && (s2 = false);
  }), s2) : false;
}
function F4(e) {
  return b3(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function Kn3(e) {
  if (b3(e, false) && e.includes(":")) {
    const n4 = e.split(":");
    if (n4.length === 3) {
      const t = n4[0] + ":" + n4[1];
      return !!n4[2] && F4(t);
    }
  }
  return false;
}
function Gr2(e) {
  function n4(t) {
    try {
      return typeof new URL(t) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (b3(e, false)) {
      if (n4(e)) return true;
      const t = le3(e);
      return n4(t);
    }
  } catch {
  }
  return false;
}
function Yr3(e) {
  var n4;
  return (n4 = e == null ? void 0 : e.proposer) == null ? void 0 : n4.publicKey;
}
function Qr2(e) {
  return e == null ? void 0 : e.topic;
}
function Zr3(e, n4) {
  let t = null;
  return b3(e == null ? void 0 : e.publicKey, false) || (t = S5("MISSING_OR_INVALID", `${n4} controller public key should be a string`)), t;
}
function Se2(e) {
  let n4 = true;
  return L3(e) ? e.length && (n4 = e.every((t) => b3(t, false))) : n4 = false, n4;
}
function Ln3(e, n4, t) {
  let r3 = null;
  return L3(n4) && n4.length ? n4.forEach((o4) => {
    r3 || F4(o4) || (r3 = U3("UNSUPPORTED_CHAINS", `${t}, chain ${o4} should be a string and conform to "namespace:chainId" format`));
  }) : F4(e) || (r3 = U3("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r3;
}
function Fn3(e, n4, t) {
  let r3 = null;
  return Object.entries(e).forEach(([o4, s2]) => {
    if (r3) return;
    const i3 = Ln3(o4, W2(o4, s2), `${n4} ${t}`);
    i3 && (r3 = i3);
  }), r3;
}
function qn3(e, n4) {
  let t = null;
  return L3(e) ? e.forEach((r3) => {
    t || Kn3(r3) || (t = U3("UNSUPPORTED_ACCOUNTS", `${n4}, account ${r3} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = U3("UNSUPPORTED_ACCOUNTS", `${n4}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function Bn3(e, n4) {
  let t = null;
  return Object.values(e).forEach((r3) => {
    if (t) return;
    const o4 = qn3(r3 == null ? void 0 : r3.accounts, `${n4} namespace`);
    o4 && (t = o4);
  }), t;
}
function Hn3(e, n4) {
  let t = null;
  return Se2(e == null ? void 0 : e.methods) ? Se2(e == null ? void 0 : e.events) || (t = U3("UNSUPPORTED_EVENTS", `${n4}, events should be an array of strings or empty array for no events`)) : t = U3("UNSUPPORTED_METHODS", `${n4}, methods should be an array of strings or empty array for no methods`), t;
}
function $e2(e, n4) {
  let t = null;
  return Object.values(e).forEach((r3) => {
    if (t) return;
    const o4 = Hn3(r3, `${n4}, namespace`);
    o4 && (t = o4);
  }), t;
}
function Xr2(e, n4, t) {
  let r3 = null;
  if (e && Z3(e)) {
    const o4 = $e2(e, n4);
    o4 && (r3 = o4);
    const s2 = Fn3(e, n4, t);
    s2 && (r3 = s2);
  } else r3 = S5("MISSING_OR_INVALID", `${n4}, ${t} should be an object with data`);
  return r3;
}
function Wn3(e, n4) {
  let t = null;
  if (e && Z3(e)) {
    const r3 = $e2(e, n4);
    r3 && (t = r3);
    const o4 = Bn3(e, n4);
    o4 && (t = o4);
  } else t = S5("MISSING_OR_INVALID", `${n4}, namespaces should be an object with data`);
  return t;
}
function Jn3(e) {
  return b3(e.protocol, true);
}
function eo2(e, n4) {
  let t = false;
  return n4 && !e ? t = true : e && L3(e) && e.length && e.forEach((r3) => {
    t = Jn3(r3);
  }), t;
}
function no3(e) {
  return typeof e == "number";
}
function to2(e) {
  return typeof e < "u" && typeof e !== null;
}
function ro3(e) {
  return !(!e || typeof e != "object" || !e.code || !X(e.code, false) || !e.message || !b3(e.message, false));
}
function oo2(e) {
  return !(I3(e) || !b3(e.method, false));
}
function so2(e) {
  return !(I3(e) || I3(e.result) && I3(e.error) || !X(e.id, false) || !b3(e.jsonrpc, false));
}
function io2(e) {
  return !(I3(e) || !b3(e.name, false));
}
function co3(e, n4) {
  return !(!F4(n4) || !Un2(e).includes(n4));
}
function ao3(e, n4, t) {
  return b3(t, false) ? _n2(e, n4).includes(t) : false;
}
function uo2(e, n4, t) {
  return b3(t, false) ? kn3(e, n4).includes(t) : false;
}
function zn3(e, n4, t) {
  let r3 = null;
  const o4 = lo2(e), s2 = fo2(n4), i3 = Object.keys(o4), u4 = Object.keys(s2), l7 = Gn3(Object.keys(e)), c7 = Gn3(Object.keys(n4)), d6 = l7.filter((a5) => !c7.includes(a5));
  return d6.length && (r3 = S5("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d6.toString()}
      Received: ${Object.keys(n4).toString()}`)), $3(i3, u4) || (r3 = S5("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${i3.toString()}
      Approved: ${u4.toString()}`)), Object.keys(n4).forEach((a5) => {
    if (!a5.includes(":") || r3) return;
    const f7 = C4(n4[a5].accounts);
    f7.includes(a5) || (r3 = S5("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a5}
        Required: ${a5}
        Approved: ${f7.toString()}`));
  }), i3.forEach((a5) => {
    r3 || ($3(o4[a5].methods, s2[a5].methods) ? $3(o4[a5].events, s2[a5].events) || (r3 = S5("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a5}`)) : r3 = S5("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a5}`));
  }), r3;
}
function lo2(e) {
  const n4 = {};
  return Object.keys(e).forEach((t) => {
    var r3;
    t.includes(":") ? n4[t] = e[t] : (r3 = e[t].chains) == null || r3.forEach((o4) => {
      n4[o4] = { methods: e[t].methods, events: e[t].events };
    });
  }), n4;
}
function Gn3(e) {
  return [...new Set(e.map((n4) => n4.includes(":") ? n4.split(":")[0] : n4))];
}
function fo2(e) {
  const n4 = {};
  return Object.keys(e).forEach((t) => {
    if (t.includes(":")) n4[t] = e[t];
    else {
      const r3 = C4(e[t].accounts);
      r3 == null ? void 0 : r3.forEach((o4) => {
        n4[o4] = { accounts: e[t].accounts.filter((s2) => s2.includes(`${o4}:`)), methods: e[t].methods, events: e[t].events };
      });
    }
  }), n4;
}
function po2(e, n4) {
  return X(e, false) && e <= n4.max && e >= n4.min;
}
function mo() {
  const e = P3();
  return new Promise((n4) => {
    switch (e) {
      case y6.browser:
        n4(Yn3());
        break;
      case y6.reactNative:
        n4(Qn3());
        break;
      case y6.node:
        n4(Zn3());
        break;
      default:
        n4(true);
    }
  });
}
function Yn3() {
  return V3() && (navigator == null ? void 0 : navigator.onLine);
}
async function Qn3() {
  if (_4() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function Zn3() {
  return true;
}
function ho2(e) {
  switch (P3()) {
    case y6.browser:
      Xn3(e);
      break;
    case y6.reactNative:
      et3(e);
      break;
    case y6.node:
      break;
  }
}
function Xn3(e) {
  !_4() && V3() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function et3(e) {
  _4() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n4) => e(n4 == null ? void 0 : n4.isConnected)));
}
var Re = {};
var yo = class {
  static get(n4) {
    return Re[n4];
  }
  static set(n4, t) {
    Re[n4] = t;
  }
  static delete(n4) {
    delete Re[n4];
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events11 = __toESM(require_events());
var w2 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser3();
var b4 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var a4 = (c7) => c7.split("?")[0];
var h6 = 10;
var S6 = w2();
var f4 = class {
  constructor(e) {
    if (this.url = e, this.events = new import_events11.EventEmitter(), this.registering = false, !isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n4) => {
        this.onClose(n4), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n4, o4) => {
        this.events.once("register_error", (s2) => {
          this.resetMaxListeners(), o4(s2);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return o4(new Error("WebSocket connection is missing or invalid"));
          n4(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n4) => {
      const o4 = new URLSearchParams(e).get("origin"), s2 = (0, esm_exports.isReactNative)() ? { headers: { origin: o4 } } : { rejectUnauthorized: !isLocalhostUrl(e) }, i3 = new S6(e, [], s2);
      b4() ? i3.onerror = (r3) => {
        const l7 = r3;
        n4(this.emitError(l7.error));
      } : i3.on("error", (r3) => {
        n4(this.emitError(r3));
      }), i3.onopen = () => {
        this.onOpen(i3), t(i3);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const t = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n4 = this.parseError(t), o4 = n4.message || n4.toString(), s2 = formatJsonRpcError(e, o4);
    this.events.emit("payload", s2);
  }
  parseError(e, t = this.url) {
    return parseConnectionError(e, a4(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h6 && this.events.setMaxListeners(h6);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${a4(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_lodash2 = __toESM(require_lodash());
var import_window_getters4 = __toESM(require_cjs2());
var ye4 = "wc";
var De2 = 2;
var ie4 = "core";
var x7 = `${ye4}@2:${ie4}:`;
var Ye2 = { name: ie4, logger: "error" };
var Je4 = { database: ":memory:" };
var Xe3 = "crypto";
var me4 = "client_ed25519_seed";
var We4 = import_time7.ONE_DAY;
var Ze2 = "keychain";
var Qe2 = "0.3";
var et4 = "messages";
var tt3 = "0.3";
var it4 = import_time7.SIX_HOURS;
var st4 = "publisher";
var rt3 = "irn";
var nt2 = "error";
var be5 = "wss://relay.walletconnect.org";
var ot3 = "relayer";
var v4 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var at3 = "_subscription";
var I4 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ht3 = 0.1;
var se4 = "2.17.1";
var M7 = { link_mode: "link_mode", relay: "relay" };
var ct2 = "0.3";
var lt2 = "WALLETCONNECT_CLIENT_ID";
var fe5 = "WALLETCONNECT_LINK_MODE_APPS";
var O6 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var ut3 = "subscription";
var dt2 = "0.3";
var pt3 = import_time7.FIVE_SECONDS * 1e3;
var gt4 = "pairing";
var yt3 = "0.3";
var B4 = { wc_pairingDelete: { req: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time7.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time7.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time7.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time7.ONE_DAY, prompt: false, tag: 0 } } };
var V4 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var P4 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Dt3 = "history";
var mt3 = "0.3";
var bt5 = "expirer";
var S7 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var ft3 = "0.3";
var _t5 = "verify-api";
var vs2 = "https://verify.walletconnect.com";
var Et4 = "https://verify.walletconnect.org";
var J3 = Et4;
var vt5 = `${J3}/v3`;
var wt4 = [vs2, Et4];
var It4 = "echo";
var Tt4 = "https://echo.walletconnect.com";
var z7 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var $4 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Is2 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var Ts2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var Cs2 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var Ps2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Ct4 = 0.1;
var Pt4 = "event-client";
var St4 = 86400;
var Rt3 = "https://pulse.walletconnect.org/batch";
function Ss2(o4, e) {
  if (o4.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s2 = 0; s2 < t.length; s2++) t[s2] = 255;
  for (var i3 = 0; i3 < o4.length; i3++) {
    var r3 = o4.charAt(i3), n4 = r3.charCodeAt(0);
    if (t[n4] !== 255) throw new TypeError(r3 + " is ambiguous");
    t[n4] = i3;
  }
  var a5 = o4.length, h7 = o4.charAt(0), c7 = Math.log(a5) / Math.log(256), l7 = Math.log(256) / Math.log(a5);
  function p5(u4) {
    if (u4 instanceof Uint8Array || (ArrayBuffer.isView(u4) ? u4 = new Uint8Array(u4.buffer, u4.byteOffset, u4.byteLength) : Array.isArray(u4) && (u4 = Uint8Array.from(u4))), !(u4 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u4.length === 0) return "";
    for (var g5 = 0, _6 = 0, y9 = 0, b7 = u4.length; y9 !== b7 && u4[y9] === 0; ) y9++, g5++;
    for (var A4 = (b7 - y9) * l7 + 1 >>> 0, T4 = new Uint8Array(A4); y9 !== b7; ) {
      for (var N5 = u4[y9], k6 = 0, R6 = A4 - 1; (N5 !== 0 || k6 < _6) && R6 !== -1; R6--, k6++) N5 += 256 * T4[R6] >>> 0, T4[R6] = N5 % a5 >>> 0, N5 = N5 / a5 >>> 0;
      if (N5 !== 0) throw new Error("Non-zero carry");
      _6 = k6, y9++;
    }
    for (var L5 = A4 - _6; L5 !== A4 && T4[L5] === 0; ) L5++;
    for (var Q5 = h7.repeat(g5); L5 < A4; ++L5) Q5 += o4.charAt(T4[L5]);
    return Q5;
  }
  function D7(u4) {
    if (typeof u4 != "string") throw new TypeError("Expected String");
    if (u4.length === 0) return new Uint8Array();
    var g5 = 0;
    if (u4[g5] !== " ") {
      for (var _6 = 0, y9 = 0; u4[g5] === h7; ) _6++, g5++;
      for (var b7 = (u4.length - g5) * c7 + 1 >>> 0, A4 = new Uint8Array(b7); u4[g5]; ) {
        var T4 = t[u4.charCodeAt(g5)];
        if (T4 === 255) return;
        for (var N5 = 0, k6 = b7 - 1; (T4 !== 0 || N5 < y9) && k6 !== -1; k6--, N5++) T4 += a5 * A4[k6] >>> 0, A4[k6] = T4 % 256 >>> 0, T4 = T4 / 256 >>> 0;
        if (T4 !== 0) throw new Error("Non-zero carry");
        y9 = N5, g5++;
      }
      if (u4[g5] !== " ") {
        for (var R6 = b7 - y9; R6 !== b7 && A4[R6] === 0; ) R6++;
        for (var L5 = new Uint8Array(_6 + (b7 - R6)), Q5 = _6; R6 !== b7; ) L5[Q5++] = A4[R6++];
        return L5;
      }
    }
  }
  function m2(u4) {
    var g5 = D7(u4);
    if (g5) return g5;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p5, decodeUnsafe: D7, decode: m2 };
}
var Rs2 = Ss2;
var xs2 = Rs2;
var xt5 = (o4) => {
  if (o4 instanceof Uint8Array && o4.constructor.name === "Uint8Array") return o4;
  if (o4 instanceof ArrayBuffer) return new Uint8Array(o4);
  if (ArrayBuffer.isView(o4)) return new Uint8Array(o4.buffer, o4.byteOffset, o4.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Os2 = (o4) => new TextEncoder().encode(o4);
var As2 = (o4) => new TextDecoder().decode(o4);
var Ns2 = class {
  constructor(e, t, s2) {
    this.name = e, this.prefix = t, this.baseEncode = s2;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var zs2 = class {
  constructor(e, t, s2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ot5(this, e);
  }
};
var Ls3 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ot5(this, e);
  }
  decode(e) {
    const t = e[0], s2 = this.decoders[t];
    if (s2) return s2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ot5 = (o4, e) => new Ls3({ ...o4.decoders || { [o4.prefix]: o4 }, ...e.decoders || { [e.prefix]: e } });
var $s2 = class {
  constructor(e, t, s2, i3) {
    this.name = e, this.prefix = t, this.baseEncode = s2, this.baseDecode = i3, this.encoder = new Ns2(e, t, s2), this.decoder = new zs2(e, t, i3);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var re4 = ({ name: o4, prefix: e, encode: t, decode: s2 }) => new $s2(o4, e, t, s2);
var X2 = ({ prefix: o4, name: e, alphabet: t }) => {
  const { encode: s2, decode: i3 } = xs2(t, e);
  return re4({ prefix: o4, name: e, encode: s2, decode: (r3) => xt5(i3(r3)) });
};
var ks3 = (o4, e, t, s2) => {
  const i3 = {};
  for (let l7 = 0; l7 < e.length; ++l7) i3[e[l7]] = l7;
  let r3 = o4.length;
  for (; o4[r3 - 1] === "="; ) --r3;
  const n4 = new Uint8Array(r3 * t / 8 | 0);
  let a5 = 0, h7 = 0, c7 = 0;
  for (let l7 = 0; l7 < r3; ++l7) {
    const p5 = i3[o4[l7]];
    if (p5 === void 0) throw new SyntaxError(`Non-${s2} character`);
    h7 = h7 << t | p5, a5 += t, a5 >= 8 && (a5 -= 8, n4[c7++] = 255 & h7 >> a5);
  }
  if (a5 >= t || 255 & h7 << 8 - a5) throw new SyntaxError("Unexpected end of data");
  return n4;
};
var Ms2 = (o4, e, t) => {
  const s2 = e[e.length - 1] === "=", i3 = (1 << t) - 1;
  let r3 = "", n4 = 0, a5 = 0;
  for (let h7 = 0; h7 < o4.length; ++h7) for (a5 = a5 << 8 | o4[h7], n4 += 8; n4 > t; ) n4 -= t, r3 += e[i3 & a5 >> n4];
  if (n4 && (r3 += e[i3 & a5 << t - n4]), s2) for (; r3.length * t & 7; ) r3 += "=";
  return r3;
};
var f5 = ({ name: o4, prefix: e, bitsPerChar: t, alphabet: s2 }) => re4({ prefix: e, name: o4, encode(i3) {
  return Ms2(i3, s2, t);
}, decode(i3) {
  return ks3(i3, s2, t, o4);
} });
var Us2 = re4({ prefix: "\0", name: "identity", encode: (o4) => As2(o4), decode: (o4) => Os2(o4) });
var Fs2 = Object.freeze({ __proto__: null, identity: Us2 });
var Ks2 = f5({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Bs2 = Object.freeze({ __proto__: null, base2: Ks2 });
var Vs2 = f5({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var js3 = Object.freeze({ __proto__: null, base8: Vs2 });
var qs2 = X2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Gs2 = Object.freeze({ __proto__: null, base10: qs2 });
var Hs2 = f5({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Ys2 = f5({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Js3 = Object.freeze({ __proto__: null, base16: Hs2, base16upper: Ys2 });
var Xs3 = f5({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Ws3 = f5({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Zs3 = f5({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Qs2 = f5({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var er5 = f5({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var tr4 = f5({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ir5 = f5({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var sr4 = f5({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var rr4 = f5({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var nr5 = Object.freeze({ __proto__: null, base32: Xs3, base32upper: Ws3, base32pad: Zs3, base32padupper: Qs2, base32hex: er5, base32hexupper: tr4, base32hexpad: ir5, base32hexpadupper: sr4, base32z: rr4 });
var or4 = X2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var ar5 = X2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var hr4 = Object.freeze({ __proto__: null, base36: or4, base36upper: ar5 });
var cr5 = X2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var lr4 = X2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ur4 = Object.freeze({ __proto__: null, base58btc: cr5, base58flickr: lr4 });
var dr4 = f5({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var pr4 = f5({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var gr4 = f5({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var yr5 = f5({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Dr4 = Object.freeze({ __proto__: null, base64: dr4, base64pad: pr4, base64url: gr4, base64urlpad: yr5 });
var At4 = Array.from("");
var mr5 = At4.reduce((o4, e, t) => (o4[t] = e, o4), []);
var br4 = At4.reduce((o4, e, t) => (o4[e.codePointAt(0)] = t, o4), []);
function fr4(o4) {
  return o4.reduce((e, t) => (e += mr5[t], e), "");
}
function _r5(o4) {
  const e = [];
  for (const t of o4) {
    const s2 = br4[t.codePointAt(0)];
    if (s2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(s2);
  }
  return new Uint8Array(e);
}
var Er4 = re4({ prefix: "", name: "base256emoji", encode: fr4, decode: _r5 });
var vr4 = Object.freeze({ __proto__: null, base256emoji: Er4 });
var wr4 = zt5;
var Nt5 = 128;
var Ir3 = 127;
var Tr5 = ~Ir3;
var Cr4 = Math.pow(2, 31);
function zt5(o4, e, t) {
  e = e || [], t = t || 0;
  for (var s2 = t; o4 >= Cr4; ) e[t++] = o4 & 255 | Nt5, o4 /= 128;
  for (; o4 & Tr5; ) e[t++] = o4 & 255 | Nt5, o4 >>>= 7;
  return e[t] = o4 | 0, zt5.bytes = t - s2 + 1, e;
}
var Pr4 = _e4;
var Sr4 = 128;
var Lt4 = 127;
function _e4(o4, s2) {
  var t = 0, s2 = s2 || 0, i3 = 0, r3 = s2, n4, a5 = o4.length;
  do {
    if (r3 >= a5) throw _e4.bytes = 0, new RangeError("Could not decode varint");
    n4 = o4[r3++], t += i3 < 28 ? (n4 & Lt4) << i3 : (n4 & Lt4) * Math.pow(2, i3), i3 += 7;
  } while (n4 >= Sr4);
  return _e4.bytes = r3 - s2, t;
}
var Rr5 = Math.pow(2, 7);
var xr4 = Math.pow(2, 14);
var Or4 = Math.pow(2, 21);
var Ar4 = Math.pow(2, 28);
var Nr4 = Math.pow(2, 35);
var zr5 = Math.pow(2, 42);
var Lr3 = Math.pow(2, 49);
var $r5 = Math.pow(2, 56);
var kr4 = Math.pow(2, 63);
var Mr2 = function(o4) {
  return o4 < Rr5 ? 1 : o4 < xr4 ? 2 : o4 < Or4 ? 3 : o4 < Ar4 ? 4 : o4 < Nr4 ? 5 : o4 < zr5 ? 6 : o4 < Lr3 ? 7 : o4 < $r5 ? 8 : o4 < kr4 ? 9 : 10;
};
var Ur4 = { encode: wr4, decode: Pr4, encodingLength: Mr2 };
var $t4 = Ur4;
var kt5 = (o4, e, t = 0) => ($t4.encode(o4, e, t), e);
var Mt4 = (o4) => $t4.encodingLength(o4);
var Ee5 = (o4, e) => {
  const t = e.byteLength, s2 = Mt4(o4), i3 = s2 + Mt4(t), r3 = new Uint8Array(i3 + t);
  return kt5(o4, r3, 0), kt5(t, r3, s2), r3.set(e, i3), new Fr3(o4, t, e, r3);
};
var Fr3 = class {
  constructor(e, t, s2, i3) {
    this.code = e, this.size = t, this.digest = s2, this.bytes = i3;
  }
};
var Ut4 = ({ name: o4, code: e, encode: t }) => new Kr2(o4, e, t);
var Kr2 = class {
  constructor(e, t, s2) {
    this.name = e, this.code = t, this.encode = s2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ee5(this.code, t) : t.then((s2) => Ee5(this.code, s2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Ft5 = (o4) => async (e) => new Uint8Array(await crypto.subtle.digest(o4, e));
var Br4 = Ut4({ name: "sha2-256", code: 18, encode: Ft5("SHA-256") });
var Vr2 = Ut4({ name: "sha2-512", code: 19, encode: Ft5("SHA-512") });
var jr3 = Object.freeze({ __proto__: null, sha256: Br4, sha512: Vr2 });
var Kt4 = 0;
var qr2 = "identity";
var Bt5 = xt5;
var Gr3 = (o4) => Ee5(Kt4, Bt5(o4));
var Hr2 = { code: Kt4, name: qr2, encode: Bt5, digest: Gr3 };
var Yr4 = Object.freeze({ __proto__: null, identity: Hr2 });
new TextEncoder(), new TextDecoder();
var Vt4 = { ...Fs2, ...Bs2, ...js3, ...Gs2, ...Js3, ...nr5, ...hr4, ...ur4, ...Dr4, ...vr4 };
({ ...jr3, ...Yr4 });
function Jr4(o4 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o4) : new Uint8Array(o4);
}
function jt4(o4, e, t, s2) {
  return { name: o4, prefix: e, encoder: { name: o4, prefix: e, encode: t }, decoder: { decode: s2 } };
}
var qt4 = jt4("utf8", "u", (o4) => "u" + new TextDecoder("utf8").decode(o4), (o4) => new TextEncoder().encode(o4.substring(1)));
var ve4 = jt4("ascii", "a", (o4) => {
  let e = "a";
  for (let t = 0; t < o4.length; t++) e += String.fromCharCode(o4[t]);
  return e;
}, (o4) => {
  o4 = o4.substring(1);
  const e = Jr4(o4.length);
  for (let t = 0; t < o4.length; t++) e[t] = o4.charCodeAt(t);
  return e;
});
var Xr3 = { utf8: qt4, "utf-8": qt4, hex: Vt4.base16, latin1: ve4, ascii: ve4, binary: ve4, ...Vt4 };
function Wr3(o4, e = "utf8") {
  const t = Xr3[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o4, "utf8") : t.decoder.decode(`${t.prefix}${o4}`);
}
var Gt5 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = Ze2, this.version = Qe2, this.initialized = false, this.storagePrefix = x7, this.init = async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }, this.has = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.set = async (s2, i3) => {
      this.isInitialized(), this.keychain.set(s2, i3), await this.persist();
    }, this.get = (s2) => {
      this.isInitialized();
      const i3 = this.keychain.get(s2);
      if (typeof i3 > "u") {
        const { message: r3 } = S5("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i3;
    }, this.del = async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }, this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Tt3(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Pt3(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Ht4 = class {
  constructor(e, t, s2) {
    this.core = e, this.logger = t, this.name = Xe3, this.randomSessionIdentifier = pr3(), this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.getClientId = async () => {
      this.isInitialized();
      const i3 = await this.getClientSeed(), r3 = generateKeyPair(i3);
      return encodeIss(r3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i3 = fr3();
      return this.setPrivateKey(i3.publicKey, i3.privateKey);
    }, this.signJWT = async (i3) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), n4 = generateKeyPair(r3), a5 = this.randomSessionIdentifier, h7 = We4;
      return await signJWT(a5, i3, h7, n4);
    }, this.generateSharedKey = (i3, r3, n4) => {
      this.isInitialized();
      const a5 = this.getPrivateKey(i3), h7 = mr4(a5, r3);
      return this.setSymKey(h7, n4);
    }, this.setSymKey = async (i3, r3) => {
      this.isInitialized();
      const n4 = r3 || hr3(i3);
      return await this.keychain.set(n4, i3), n4;
    }, this.deleteKeyPair = async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }, this.deleteSymKey = async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }, this.encode = async (i3, r3, n4) => {
      this.isInitialized();
      const a5 = On2(n4), h7 = safeJsonStringify(r3);
      if (Nr3(a5)) return vr3(h7, n4 == null ? void 0 : n4.encoding);
      if (Or3(a5)) {
        const D7 = a5.senderPublicKey, m2 = a5.receiverPublicKey;
        i3 = await this.generateSharedKey(D7, m2);
      }
      const c7 = this.getSymKey(i3), { type: l7, senderPublicKey: p5 } = a5;
      return gr3({ type: l7, symKey: c7, message: h7, senderPublicKey: p5, encoding: n4 == null ? void 0 : n4.encoding });
    }, this.decode = async (i3, r3, n4) => {
      this.isInitialized();
      const a5 = wr3(r3, n4);
      if (Nr3(a5)) {
        const h7 = Er3(r3, n4 == null ? void 0 : n4.encoding);
        return safeJsonParse(h7);
      }
      if (Or3(a5)) {
        const h7 = a5.receiverPublicKey, c7 = a5.senderPublicKey;
        i3 = await this.generateSharedKey(h7, c7);
      }
      try {
        const h7 = this.getSymKey(i3), c7 = br3({ symKey: h7, encoded: r3, encoding: n4 == null ? void 0 : n4.encoding });
        return safeJsonParse(c7);
      } catch (h7) {
        this.logger.error(`Failed to decode message from topic: '${i3}', clientId: '${await this.getClientId()}'`), this.logger.error(h7);
      }
    }, this.getPayloadType = (i3, r3 = ge2) => {
      const n4 = Q3({ encoded: i3, encoding: r3 });
      return A2(n4.type);
    }, this.getPayloadSenderPublicKey = (i3, r3 = ge2) => {
      const n4 = Q3({ encoded: i3, encoding: r3 });
      return n4.senderPublicKey ? toString(n4.senderPublicKey, g3) : void 0;
    }, this.core = e, this.logger = E(t, this.name), this.keychain = s2 || new Gt5(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(me4);
    } catch {
      e = pr3(), await this.keychain.set(me4, e);
    }
    return Wr3(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Yt5 = class extends a3 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = et4, this.version = tt3, this.initialized = false, this.storagePrefix = x7, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (s2, i3) => {
      this.isInitialized();
      const r3 = yr4(i3);
      let n4 = this.messages.get(s2);
      return typeof n4 > "u" && (n4 = {}), typeof n4[r3] < "u" || (n4[r3] = i3, this.messages.set(s2, n4), await this.persist()), r3;
    }, this.get = (s2) => {
      this.isInitialized();
      let i3 = this.messages.get(s2);
      return typeof i3 > "u" && (i3 = {}), i3;
    }, this.has = (s2, i3) => {
      this.isInitialized();
      const r3 = this.get(s2), n4 = yr4(i3);
      return typeof r3[n4] < "u";
    }, this.del = async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }, this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Tt3(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Pt3(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Zr4 = class extends g2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events12.EventEmitter(), this.name = st4, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time7.toMiliseconds)(import_time7.ONE_MINUTE), this.failedPublishTimeout = (0, import_time7.toMiliseconds)(import_time7.ONE_SECOND), this.needsTransportRestart = false, this.publish = async (s2, i3, r3) => {
      var n4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i3, opts: r3 } });
      const a5 = (r3 == null ? void 0 : r3.ttl) || it4, h7 = Ir2(r3), c7 = (r3 == null ? void 0 : r3.prompt) || false, l7 = (r3 == null ? void 0 : r3.tag) || 0, p5 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), D7 = { topic: s2, message: i3, opts: { ttl: a5, relay: h7, prompt: c7, tag: l7, id: p5, attestation: r3 == null ? void 0 : r3.attestation } }, m2 = `Failed to publish payload, please try again. id:${p5} tag:${l7}`, u4 = Date.now();
      let g5, _6 = 1;
      try {
        for (; g5 === void 0; ) {
          if (Date.now() - u4 > this.publishTimeout) throw new Error(m2);
          this.logger.trace({ id: p5, attempts: _6 }, `publisher.publish - attempt ${_6}`), g5 = await await kt4(this.rpcPublish(s2, i3, a5, h7, c7, l7, p5, r3 == null ? void 0 : r3.attestation).catch((y9) => this.logger.warn(y9)), this.publishTimeout, m2), _6++, g5 || await new Promise((y9) => setTimeout(y9, this.failedPublishTimeout));
        }
        this.relayer.events.emit(v4.publish, D7), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: p5, topic: s2, message: i3, opts: r3 } });
      } catch (y9) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(y9), (n4 = r3 == null ? void 0 : r3.internal) != null && n4.throwOnFailedPublish) throw y9;
        this.queue.set(p5, D7);
      }
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  rpcPublish(e, t, s2, i3, r3, n4, a5, h7) {
    var c7, l7, p5, D7;
    const m2 = { method: jr2(i3.protocol).publish, params: { topic: e, message: t, ttl: s2, prompt: r3, tag: n4, attestation: h7 }, id: a5 };
    return I3((c7 = m2.params) == null ? void 0 : c7.prompt) && ((l7 = m2.params) == null || delete l7.prompt), I3((p5 = m2.params) == null ? void 0 : p5.tag) && ((D7 = m2.params) == null || delete D7.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: m2 }), this.relayer.request(m2);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: s2, opts: i3 } = e;
      await this.publish(t, s2, i3);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(v4.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v4.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Qr3 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const s2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...s2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const s2 = this.get(e);
      if (!this.exists(e, t)) return;
      const i3 = s2.filter((r3) => r3 !== t);
      if (!i3.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i3);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var en3 = Object.defineProperty;
var tn3 = Object.defineProperties;
var sn5 = Object.getOwnPropertyDescriptors;
var Jt5 = Object.getOwnPropertySymbols;
var rn3 = Object.prototype.hasOwnProperty;
var nn3 = Object.prototype.propertyIsEnumerable;
var Xt4 = (o4, e, t) => e in o4 ? en3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var W3 = (o4, e) => {
  for (var t in e || (e = {})) rn3.call(e, t) && Xt4(o4, t, e[t]);
  if (Jt5) for (var t of Jt5(e)) nn3.call(e, t) && Xt4(o4, t, e[t]);
  return o4;
};
var we5 = (o4, e) => tn3(o4, sn5(e));
var Wt5 = class extends d5 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Qr3(), this.events = new import_events12.EventEmitter(), this.name = ut3, this.version = dt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x7, this.subscribeTimeout = (0, import_time7.toMiliseconds)(import_time7.ONE_MINUTE), this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = true;
    }, this.subscribe = async (s2, i3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } });
      try {
        const r3 = Ir2(i3), n4 = { topic: s2, relay: r3, transportType: i3 == null ? void 0 : i3.transportType };
        this.pending.set(s2, n4);
        const a5 = await this.rpcSubscribe(s2, r3, i3);
        return typeof a5 == "string" && (this.onSubscribe(a5, n4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } })), a5;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }, this.unsubscribe = async (s2, i3) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i3 == null ? void 0 : i3.id) < "u" ? await this.unsubscribeById(s2, i3.id, i3) : await this.unsubscribeByTopic(s2, i3);
    }, this.isSubscribed = async (s2) => {
      if (this.topics.includes(s2)) return true;
      const i3 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, n4) => {
        const a5 = new import_time7.Watch();
        a5.start(i3);
        const h7 = setInterval(() => {
          !this.pending.has(s2) && this.topics.includes(s2) && (clearInterval(h7), a5.stop(i3), r3(true)), a5.elapsed(i3) >= pt3 && (clearInterval(h7), a5.stop(i3), n4(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return s2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const s2 = this.topicMap.get(e);
    await Promise.all(s2.map(async (i3) => await this.unsubscribeById(e, i3, t)));
  }
  async unsubscribeById(e, t, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    try {
      const i3 = Ir2(s2);
      await this.rpcUnsubscribe(e, t, i3);
      const r3 = U3("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    } catch (i3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i3), i3;
    }
  }
  async rpcSubscribe(e, t, s2) {
    var i3;
    (s2 == null ? void 0 : s2.transportType) === M7.relay && await this.restartToComplete();
    const r3 = { method: jr2(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r3 });
    const n4 = (i3 = s2 == null ? void 0 : s2.internal) == null ? void 0 : i3.throwOnFailedPublish;
    try {
      const a5 = yr4(e + this.clientId);
      if ((s2 == null ? void 0 : s2.transportType) === M7.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r3).catch((c7) => this.logger.warn(c7));
      }, (0, import_time7.toMiliseconds)(import_time7.ONE_SECOND)), a5;
      const h7 = await kt4(this.relayer.request(r3).catch((c7) => this.logger.warn(c7)), this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h7 && n4) throw new Error(`Subscribing to ${e} failed, please try again`);
      return h7 ? a5 : null;
    } catch (a5) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v4.connection_stalled), n4) throw a5;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, s2 = { method: jr2(t.protocol).batchSubscribe, params: { topics: e.map((i3) => i3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      return await await kt4(this.relayer.request(s2).catch((i3) => this.logger.warn(i3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v4.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, s2 = { method: jr2(t.protocol).batchFetchMessages, params: { topics: e.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i3;
    try {
      i3 = await await kt4(this.relayer.request(s2).catch((r3) => this.logger.warn(r3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v4.connection_stalled);
    }
    return i3;
  }
  rpcUnsubscribe(e, t, s2) {
    const i3 = { method: jr2(s2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 }), this.relayer.request(i3);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, we5(W3({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, W3({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, s2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, W3({}, t)), this.topicMap.set(t.topic, e), this.events.emit(O6.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: s2 } = S5("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const s2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(s2.topic, e), this.events.emit(O6.deleted, we5(W3({}, s2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(O6.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const s2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(s2), await this.batchSubscribe(s2);
      }
    }
    this.events.emit(O6.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = S5("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length) return;
    const t = await this.rpcBatchSubscribe(e);
    L3(t) && this.onBatchSubscribe(t.map((s2, i3) => we5(W3({}, e[i3]), { id: s2 })));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(t.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, async () => {
      await this.checkPending();
    }), this.events.on(O6.created, async (e) => {
      const t = O6.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(O6.deleted, async (e) => {
      const t = O6.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var on3 = Object.defineProperty;
var Zt4 = Object.getOwnPropertySymbols;
var an4 = Object.prototype.hasOwnProperty;
var hn4 = Object.prototype.propertyIsEnumerable;
var Qt4 = (o4, e, t) => e in o4 ? on3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var ei3 = (o4, e) => {
  for (var t in e || (e = {})) an4.call(e, t) && Qt4(o4, t, e[t]);
  if (Zt4) for (var t of Zt4(e)) hn4.call(e, t) && Qt4(o4, t, e[t]);
  return o4;
};
var ti3 = class extends u2 {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events12.EventEmitter(), this.name = ot3, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = (0, import_time7.toMiliseconds)(import_time7.THIRTY_SECONDS + import_time7.ONE_SECOND), this.request = async (t) => {
      var s2, i3;
      this.logger.debug("Publishing Request Payload");
      const r3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const n4 = this.provider.request(t);
        this.requestsInFlight.set(r3, { promise: n4, request: t }), this.logger.trace({ id: r3, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - attempt to publish...");
        const a5 = await new Promise(async (h7, c7) => {
          const l7 = () => {
            c7(new Error(`relayer.request - publish interrupted, id: ${r3}`));
          };
          this.provider.on(I4.disconnect, l7);
          const p5 = await n4;
          this.provider.off(I4.disconnect, l7), h7(p5);
        });
        return this.logger.trace({ id: r3, method: t.method, topic: (i3 = t.params) == null ? void 0 : i3.topic }, "relayer.request - published"), a5;
      } catch (n4) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), n4;
      } finally {
        this.requestsInFlight.delete(r3);
      }
    }, this.resetPingTimeout = () => {
      if (ce3()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t, s2, i3;
          (i3 = (s2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s2.socket) == null || i3.terminate();
        }, this.heartBeatTimeout);
      } catch (t) {
        this.logger.warn(t);
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(v4.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(v4.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(I4.payload, this.onPayloadHandler), this.provider.on(I4.connect, this.onConnectHandler), this.provider.on(I4.disconnect, this.onDisconnectHandler), this.provider.on(I4.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || nt2 })), this.messages = new Yt5(this.logger, e.core), this.subscriber = new Wt5(this, this.logger), this.publisher = new Zr4(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || be5, this.projectId = e.projectId, this.bundleId = Ot4(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 1;
  }
  get connecting() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 0;
  }
  async publish(e, t, s2) {
    this.isInitialized(), await this.publisher.publish(e, t, s2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: M7.relay });
  }
  async subscribe(e, t) {
    var s2, i3, r3;
    this.isInitialized(), (t == null ? void 0 : t.transportType) === "relay" && await this.toEstablishConnection();
    const n4 = typeof ((s2 = t == null ? void 0 : t.internal) == null ? void 0 : s2.throwOnFailedPublish) > "u" ? true : (i3 = t == null ? void 0 : t.internal) == null ? void 0 : i3.throwOnFailedPublish;
    let a5 = ((r3 = this.subscriber.topicMap.get(e)) == null ? void 0 : r3[0]) || "", h7;
    const c7 = (l7) => {
      l7.topic === e && (this.subscriber.off(O6.created, c7), h7());
    };
    return await Promise.all([new Promise((l7) => {
      h7 = l7, this.subscriber.on(O6.created, c7);
    }), new Promise(async (l7, p5) => {
      a5 = await this.subscriber.subscribe(e, ei3({ internal: { throwOnFailedPublish: n4 } }, t)).catch((D7) => {
        n4 && p5(D7);
      }) || a5, l7();
    })]), a5;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e) => e.promise));
    } catch (e) {
      this.logger.warn(e);
    }
    this.hasExperiencedNetworkDisruption || this.connected ? await kt4(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    try {
      await new Promise(async (t, s2) => {
        const i3 = () => {
          this.provider.off(I4.disconnect, i3), s2(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(I4.disconnect, i3), await kt4(this.provider.connect(), (0, import_time7.toMiliseconds)(import_time7.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((r3) => {
          s2(r3);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((r3) => {
          this.logger.error(r3), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = false, t();
      });
    } catch (t) {
      this.logger.error(t);
      const s2 = t;
      if (this.hasExperiencedNetworkDisruption = true, !this.isConnectionStalled(s2.message)) throw t;
    } finally {
      this.connectionAttemptInProgress = false;
    }
  }
  async restartTransport(e) {
    this.connectionAttemptInProgress || (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await mo()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((s2, i3) => s2.publishedAt - i3.publishedAt);
    this.logger.trace(`Batch of ${t.length} message events sorted`);
    for (const s2 of t) try {
      await this.onMessageEvent(s2);
    } catch (i3) {
      this.logger.warn(i3);
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: s2 } = e;
    if (!t.sessionExists) {
      const i3 = Mt3(import_time7.FIVE_MINUTES), r3 = { topic: s2, expiry: i3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(v4.message, e), await this.recordMessageEvent(e);
  }
  startPingTimeout() {
    var e, t, s2, i3, r3;
    if (ce3()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r3 = (i3 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i3.socket) == null || r3.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (n4) {
      this.logger.warn(n4);
    }
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o2(new f4($t3({ sdkVersion: se4, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    await this.messages.set(t, s2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    if (!s2 || s2.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t)) return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const i3 = this.messages.has(t, s2);
    return i3 && this.logger.debug(`Ignoring duplicate message: ${s2}`), i3;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(at3)) return;
      const t = e.params, { topic: s2, message: i3, publishedAt: r3, attestation: n4 } = t.data, a5 = { topic: s2, message: i3, publishedAt: r3, transportType: M7.relay, attestation: n4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ei3({ type: "event", event: t.id }, a5)), this.events.emit(t.id, a5), await this.acknowledgePayload(e), await this.onMessageEvent(a5);
    } else isJsonRpcResponse(e) && this.events.emit(v4.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(v4.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(I4.payload, this.onPayloadHandler), this.provider.off(I4.connect, this.onConnectHandler), this.provider.off(I4.disconnect, this.onDisconnectHandler), this.provider.off(I4.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await mo();
    ho2(async (t) => {
      e !== t && (e = t, t ? await this.restartTransport().catch((s2) => this.logger.error(s2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(v4.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e));
    }, (0, import_time7.toMiliseconds)(ht3))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.connected && (clearInterval(t), e());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
};
var cn4 = Object.defineProperty;
var ii3 = Object.getOwnPropertySymbols;
var ln4 = Object.prototype.hasOwnProperty;
var un4 = Object.prototype.propertyIsEnumerable;
var si3 = (o4, e, t) => e in o4 ? cn4(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var ri3 = (o4, e) => {
  for (var t in e || (e = {})) ln4.call(e, t) && si3(o4, t, e[t]);
  if (ii3) for (var t of ii3(e)) un4.call(e, t) && si3(o4, t, e[t]);
  return o4;
};
var ni3 = class extends p3 {
  constructor(e, t, s2, i3 = x7, r3 = void 0) {
    super(e, t, s2, i3), this.core = e, this.logger = t, this.name = s2, this.map = /* @__PURE__ */ new Map(), this.version = ct2, this.cached = [], this.initialized = false, this.storagePrefix = x7, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n4) => {
        this.getKey && n4 !== null && !I3(n4) ? this.map.set(this.getKey(n4), n4) : Yr3(n4) ? this.map.set(n4.id, n4) : Qr2(n4) && this.map.set(n4.topic, n4);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (n4, a5) => {
      this.isInitialized(), this.map.has(n4) ? await this.update(n4, a5) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: n4, value: a5 }), this.map.set(n4, a5), await this.persist());
    }, this.get = (n4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: n4 }), this.getData(n4)), this.getAll = (n4) => (this.isInitialized(), n4 ? this.values.filter((a5) => Object.keys(n4).every((h7) => (0, import_lodash2.default)(a5[h7], n4[h7]))) : this.values), this.update = async (n4, a5) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: n4, update: a5 });
      const h7 = ri3(ri3({}, this.getData(n4)), a5);
      this.map.set(n4, h7), await this.persist();
    }, this.delete = async (n4, a5) => {
      this.isInitialized(), this.map.has(n4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: n4, reason: a5 }), this.map.delete(n4), this.addToRecentlyDeleted(n4), await this.persist());
    }, this.logger = E(t, this.name), this.storagePrefix = i3, this.getKey = r3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i3 } = S5("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i3), new Error(i3);
      }
      const { message: s2 } = S5("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = S5("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var oi3 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = gt4, this.version = yt3, this.events = new import_events12.default(), this.initialized = false, this.storagePrefix = x7, this.ignoredPayloadTypes = [D4], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }, this.create = async (s2) => {
      this.isInitialized();
      const i3 = pr3(), r3 = await this.core.crypto.setSymKey(i3), n4 = Mt3(import_time7.FIVE_MINUTES), a5 = { protocol: rt3 }, h7 = { topic: r3, expiry: n4, relay: a5, active: false, methods: s2 == null ? void 0 : s2.methods }, c7 = Dr3({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i3, relay: a5, expiryTimestamp: n4, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(V4.create, h7), this.core.expirer.set(r3, n4), await this.pairings.set(r3, h7), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: c7 };
    }, this.pair = async (s2) => {
      this.isInitialized();
      const i3 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [z7.pairing_started] } });
      this.isValidPair(s2, i3);
      const { topic: r3, symKey: n4, relay: a5, expiryTimestamp: h7, methods: c7 } = kr3(s2.uri);
      i3.props.properties.topic = r3, i3.addTrace(z7.pairing_uri_validation_success), i3.addTrace(z7.pairing_uri_not_expired);
      let l7;
      if (this.pairings.keys.includes(r3)) {
        if (l7 = this.pairings.get(r3), i3.addTrace(z7.existing_pairing), l7.active) throw i3.setError($4.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i3.addTrace(z7.pairing_not_expired);
      }
      const p5 = h7 || Mt3(import_time7.FIVE_MINUTES), D7 = { topic: r3, relay: a5, expiry: p5, active: false, methods: c7 };
      this.core.expirer.set(r3, p5), await this.pairings.set(r3, D7), i3.addTrace(z7.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(V4.create, D7), i3.addTrace(z7.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(n4, r3), i3.addTrace(z7.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i3.setError($4.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a5 });
      } catch (m2) {
        throw i3.setError($4.subscribe_pairing_topic_failure), m2;
      }
      return i3.addTrace(z7.subscribe_pairing_topic_success), D7;
    }, this.activate = async ({ topic: s2 }) => {
      this.isInitialized();
      const i3 = Mt3(import_time7.THIRTY_DAYS);
      this.core.expirer.set(s2, i3), await this.pairings.update(s2, { active: true, expiry: i3 });
    }, this.ping = async (s2) => {
      this.isInitialized(), await this.isValidPing(s2);
      const { topic: i3 } = s2;
      if (this.pairings.keys.includes(i3)) {
        const r3 = await this.sendRequest(i3, "wc_pairingPing", {}), { done: n4, resolve: a5, reject: h7 } = _t4();
        this.events.once(Lt3("pairing_ping", r3), ({ error: c7 }) => {
          c7 ? h7(c7) : a5();
        }), await n4();
      }
    }, this.updateExpiry = async ({ topic: s2, expiry: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i3 });
    }, this.updateMetadata = async ({ topic: s2, metadata: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i3 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i3 } = s2;
      this.pairings.keys.includes(i3) && (await this.sendRequest(i3, "wc_pairingDelete", U3("USER_DISCONNECTED")), await this.deletePairing(i3));
    }, this.formatUriFromPairing = (s2) => {
      this.isInitialized();
      const { topic: i3, relay: r3, expiry: n4, methods: a5 } = s2, h7 = this.core.crypto.keychain.get(i3);
      return Dr3({ protocol: this.core.protocol, version: this.core.version, topic: i3, symKey: h7, relay: r3, expiryTimestamp: n4, methods: a5 });
    }, this.sendRequest = async (s2, i3, r3) => {
      const n4 = formatJsonRpcRequest(i3, r3), a5 = await this.core.crypto.encode(s2, n4), h7 = B4[i3].req;
      return this.core.history.set(s2, n4), this.core.relayer.publish(s2, a5, h7), n4.id;
    }, this.sendResult = async (s2, i3, r3) => {
      const n4 = formatJsonRpcResult(s2, r3), a5 = await this.core.crypto.encode(i3, n4), h7 = await this.core.history.get(i3, s2), c7 = B4[h7.request.method].res;
      await this.core.relayer.publish(i3, a5, c7), await this.core.history.resolve(n4);
    }, this.sendError = async (s2, i3, r3) => {
      const n4 = formatJsonRpcError(s2, r3), a5 = await this.core.crypto.encode(i3, n4), h7 = await this.core.history.get(i3, s2), c7 = B4[h7.request.method] ? B4[h7.request.method].res : B4.unregistered_method.res;
      await this.core.relayer.publish(i3, a5, c7), await this.core.history.resolve(n4);
    }, this.deletePairing = async (s2, i3) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, U3("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i3 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }, this.cleanup = async () => {
      const s2 = this.pairings.getAll().filter((i3) => Kt3(i3.expiry));
      await Promise.all(s2.map((i3) => this.deletePairing(i3.topic)));
    }, this.onRelayEventRequest = (s2) => {
      const { topic: i3, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i3, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i3, r3);
        default:
          return this.onUnknownRpcMethodRequest(i3, r3);
      }
    }, this.onRelayEventResponse = async (s2) => {
      const { topic: i3, payload: r3 } = s2, n4 = (await this.core.history.get(i3, r3.id)).request.method;
      switch (n4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i3, r3);
        default:
          return this.onUnknownRpcMethodResponse(n4);
      }
    }, this.onPairingPingRequest = async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(V4.ping, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onPairingPingResponse = (s2, i3) => {
      const { id: r3 } = i3;
      setTimeout(() => {
        isJsonRpcResult(i3) ? this.events.emit(Lt3("pairing_ping", r3), {}) : isJsonRpcError(i3) && this.events.emit(Lt3("pairing_ping", r3), { error: i3.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(V4.delete, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onUnknownRpcMethodRequest = async (s2, i3) => {
      const { id: r3, method: n4 } = i3;
      try {
        if (this.registeredMethods.includes(n4)) return;
        const a5 = U3("WC_METHOD_UNSUPPORTED", n4);
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      } catch (a5) {
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      }
    }, this.onUnknownRpcMethodResponse = (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(U3("WC_METHOD_UNSUPPORTED", s2));
    }, this.isValidPair = (s2, i3) => {
      var r3;
      if (!to2(s2)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i3.setError($4.malformed_pairing_uri), new Error(a5);
      }
      if (!Gr2(s2.uri)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i3.setError($4.malformed_pairing_uri), new Error(a5);
      }
      const n4 = kr3(s2 == null ? void 0 : s2.uri);
      if (!((r3 = n4 == null ? void 0 : n4.relay) != null && r3.protocol)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i3.setError($4.malformed_pairing_uri), new Error(a5);
      }
      if (!(n4 != null && n4.symKey)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i3.setError($4.malformed_pairing_uri), new Error(a5);
      }
      if (n4 != null && n4.expiryTimestamp && (0, import_time7.toMiliseconds)(n4 == null ? void 0 : n4.expiryTimestamp) < Date.now()) {
        i3.setError($4.pairing_expired);
        const { message: a5 } = S5("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a5);
      }
    }, this.isValidPing = async (s2) => {
      if (!to2(s2)) {
        const { message: r3 } = S5("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }, this.isValidDisconnect = async (s2) => {
      if (!to2(s2)) {
        const { message: r3 } = S5("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }, this.isValidPairingTopic = async (s2) => {
      if (!b3(s2, false)) {
        const { message: i3 } = S5("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i3);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i3 } = S5("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i3);
      }
      if (Kt3(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i3 } = S5("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i3);
      }
    }, this.core = e, this.logger = E(t, this.name), this.pairings = new ni3(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v4.message, async (e) => {
      const { topic: t, message: s2, transportType: i3 } = e;
      if (!this.pairings.keys.includes(t) || i3 === M7.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2))) return;
      const r3 = await this.core.crypto.decode(t, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t, r3), this.onRelayEventRequest({ topic: t, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t, payload: r3 }), this.core.history.delete(t, r3.id));
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(S7.expired, async (e) => {
      const { topic: t } = Vt3(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(V4.expire, { topic: t }));
    });
  }
};
var ai3 = class extends h5 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events12.EventEmitter(), this.name = Dt3, this.version = mt3, this.cached = [], this.initialized = false, this.storagePrefix = x7, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (s2, i3, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i3, chainId: r3 }), this.records.has(i3.id)) return;
      const n4 = { id: i3.id, topic: s2, request: { method: i3.method, params: i3.params || null }, chainId: r3, expiry: Mt3(import_time7.THIRTY_DAYS) };
      this.records.set(n4.id, n4), this.persist(), this.events.emit(P4.created, n4);
    }, this.resolve = async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id)) return;
      const i3 = await this.getRecord(s2.id);
      typeof i3.response > "u" && (i3.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i3.id, i3), this.persist(), this.events.emit(P4.updated, i3));
    }, this.get = async (s2, i3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i3 }), await this.getRecord(i3)), this.delete = (s2, i3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i3 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i3 < "u" && r3.id !== i3) return;
          this.records.delete(r3.id), this.events.emit(P4.deleted, r3);
        }
      }), this.persist();
    }, this.exists = async (s2, i3) => (this.isInitialized(), this.records.has(i3) ? (await this.getRecord(i3)).topic === s2 : false), this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const s2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(s2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: s2 } = S5("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P4.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = S5("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(P4.created, (e) => {
      const t = P4.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(P4.updated, (e) => {
      const t = P4.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(P4.deleted, (e) => {
      const t = P4.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r2.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time7.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(P4.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var hi3 = class extends x6 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events12.EventEmitter(), this.name = bt5, this.version = ft3, this.cached = [], this.initialized = false, this.storagePrefix = x7, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (s2) => {
      try {
        const i3 = this.formatTarget(s2);
        return typeof this.getExpiration(i3) < "u";
      } catch {
        return false;
      }
    }, this.set = (s2, i3) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), n4 = { target: r3, expiry: i3 };
      this.expirations.set(r3, n4), this.checkExpiry(r3, n4), this.events.emit(S7.created, { target: r3, expiration: n4 });
    }, this.get = (s2) => {
      this.isInitialized();
      const i3 = this.formatTarget(s2);
      return this.getExpiration(i3);
    }, this.del = (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i3 = this.formatTarget(s2), r3 = this.getExpiration(i3);
        this.expirations.delete(i3), this.events.emit(S7.deleted, { target: i3, expiration: r3 });
      }
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return Dt2(e);
    if (typeof e == "number") return xt4(e);
    const { message: t } = S5("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(S7.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = S5("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: s2 } = S5("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: s2 } = t;
    (0, import_time7.toMiliseconds)(s2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(S7.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r2.pulse, () => this.checkExpirations()), this.events.on(S7.created, (e) => {
      const t = S7.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(S7.expired, (e) => {
      const t = S7.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(S7.deleted, (e) => {
      const t = S7.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var ci3 = class extends y5 {
  constructor(e, t, s2) {
    super(e, t, s2), this.core = e, this.logger = t, this.store = s2, this.name = _t5, this.verifyUrlV3 = vt5, this.storagePrefix = x7, this.version = De2, this.init = async () => {
      var i3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time7.toMiliseconds)((i3 = this.publicKey) == null ? void 0 : i3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i3) => {
      if (!V3() || this.isDevEnv) return;
      const r3 = window.location.origin, { id: n4, decryptedId: a5 } = i3, h7 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${n4}&decryptedId=${a5}`;
      try {
        const c7 = (0, import_window_getters4.getDocument)(), l7 = this.startAbortTimer(import_time7.ONE_SECOND * 5), p5 = await new Promise((D7, m2) => {
          const u4 = () => {
            window.removeEventListener("message", _6), c7.body.removeChild(g5), m2("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u4);
          const g5 = c7.createElement("iframe");
          g5.src = h7, g5.style.display = "none", g5.addEventListener("error", u4, { signal: this.abortController.signal });
          const _6 = (y9) => {
            if (y9.data && typeof y9.data == "string") try {
              const b7 = JSON.parse(y9.data);
              if (b7.type === "verify_attestation") {
                if (decodeJWT(b7.attestation).payload.id !== n4) return;
                clearInterval(l7), c7.body.removeChild(g5), this.abortController.signal.removeEventListener("abort", u4), window.removeEventListener("message", _6), D7(b7.attestation === null ? "" : b7.attestation);
              }
            } catch (b7) {
              this.logger.warn(b7);
            }
          };
          c7.body.appendChild(g5), window.addEventListener("message", _6, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", p5), p5;
      } catch (c7) {
        this.logger.warn(c7);
      }
      return "";
    }, this.resolve = async (i3) => {
      if (this.isDevEnv) return "";
      const { attestationId: r3, hash: n4, encryptedId: a5 } = i3;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (decodeJWT(r3).payload.id !== a5) return;
        const c7 = await this.isValidJwtAttestation(r3);
        if (c7) {
          if (!c7.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return c7;
        }
      }
      if (!n4) return;
      const h7 = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      return this.fetchAttestation(n4, h7);
    }, this.fetchAttestation = async (i3, r3) => {
      this.logger.debug(`resolving attestation: ${i3} from url: ${r3}`);
      const n4 = this.startAbortTimer(import_time7.ONE_SECOND * 5), a5 = await fetch(`${r3}/attestation/${i3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(n4), a5.status === 200 ? await a5.json() : void 0;
    }, this.getVerifyUrl = (i3) => {
      let r3 = i3 || J3;
      return wt4.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${J3}`), r3 = J3), r3;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i3 = this.startAbortTimer(import_time7.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i3), await r3.json();
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.persistPublicKey = async (i3) => {
      this.logger.debug("persisting public key to local storage", i3), await this.store.setItem(this.storeKey, i3), this.publicKey = i3;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i3) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3) return this.validateAttestation(i3, r3);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
      const n4 = await this.fetchAndPersistPublicKey();
      try {
        if (n4) return this.validateAttestation(i3, n4);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const n4 = await this.fetchPublicKey();
        n4 && (await this.persistPublicKey(n4), r3(n4));
      });
      const i3 = await this.fetchPromise;
      return this.fetchPromise = void 0, i3;
    }, this.validateAttestation = (i3, r3) => {
      const n4 = Rr4(i3, r3.publicKey), a5 = { hasExpired: (0, import_time7.toMiliseconds)(n4.exp) < Date.now(), payload: n4 };
      if (a5.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a5.payload.origin, isScam: a5.payload.isScam, isVerified: a5.payload.isVerified };
    }, this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Wt4(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time7.toMiliseconds)(e));
  }
};
var li3 = class extends v3 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.context = It4, this.registerDeviceToken = async (s2) => {
      const { clientId: i3, token: r3, notificationType: n4, enableEncrypted: a5 = false } = s2, h7 = `${Tt4}/${this.projectId}/clients`;
      await fetch(h7, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i3, type: n4, token: r3, always_raw: a5 }) });
    }, this.logger = E(t, this.context);
  }
};
var dn4 = Object.defineProperty;
var ui3 = Object.getOwnPropertySymbols;
var pn3 = Object.prototype.hasOwnProperty;
var gn4 = Object.prototype.propertyIsEnumerable;
var di3 = (o4, e, t) => e in o4 ? dn4(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Z4 = (o4, e) => {
  for (var t in e || (e = {})) pn3.call(e, t) && di3(o4, t, e[t]);
  if (ui3) for (var t of ui3(e)) gn4.call(e, t) && di3(o4, t, e[t]);
  return o4;
};
var pi3 = class extends C3 {
  constructor(e, t, s2 = true) {
    super(e, t, s2), this.core = e, this.logger = t, this.context = Pt4, this.storagePrefix = x7, this.storageVersion = Ct4, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = false, this.init = async () => {
      if (!Wt4()) try {
        const i3 = { eventId: Ht3(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Ge3(this.core.relayer.protocol, this.core.relayer.version, se4) } } };
        await this.sendEvent([i3]);
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.createEvent = (i3) => {
      const { event: r3 = "ERROR", type: n4 = "", properties: { topic: a5, trace: h7 } } = i3, c7 = Ht3(), l7 = this.core.projectId || "", p5 = Date.now(), D7 = Z4({ eventId: c7, timestamp: p5, props: { event: r3, type: n4, properties: { topic: a5, trace: h7 } }, bundleId: l7, domain: this.getAppDomain() }, this.setMethods(c7));
      return this.telemetryEnabled && (this.events.set(c7, D7), this.shouldPersist = true), D7;
    }, this.getEvent = (i3) => {
      const { eventId: r3, topic: n4 } = i3;
      if (r3) return this.events.get(r3);
      const a5 = Array.from(this.events.values()).find((h7) => h7.props.properties.topic === n4);
      if (a5) return Z4(Z4({}, a5), this.setMethods(a5.eventId));
    }, this.deleteEvent = (i3) => {
      const { eventId: r3 } = i3;
      this.events.delete(r3), this.shouldPersist = true;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r2.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i3) => {
          (0, import_time7.fromMiliseconds)(Date.now()) - (0, import_time7.fromMiliseconds)(i3.timestamp) > St4 && (this.events.delete(i3.eventId), this.shouldPersist = true);
        });
      });
    }, this.setMethods = (i3) => ({ addTrace: (r3) => this.addTrace(i3, r3), setError: (r3) => this.setError(i3, r3) }), this.addTrace = (i3, r3) => {
      const n4 = this.events.get(i3);
      n4 && (n4.props.properties.trace.push(r3), this.events.set(i3, n4), this.shouldPersist = true);
    }, this.setError = (i3, r3) => {
      const n4 = this.events.get(i3);
      n4 && (n4.props.type = r3, n4.timestamp = Date.now(), this.events.set(i3, n4), this.shouldPersist = true);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }, this.restore = async () => {
      try {
        const i3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i3.length) return;
        i3.forEach((r3) => {
          this.events.set(r3.eventId, Z4(Z4({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i3 = [];
      for (const [r3, n4] of this.events) n4.props.type && i3.push(n4);
      if (i3.length !== 0) try {
        if ((await this.sendEvent(i3)).ok) for (const r3 of i3) this.events.delete(r3.eventId), this.shouldPersist = true;
      } catch (r3) {
        this.logger.warn(r3);
      }
    }, this.sendEvent = async (i3) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Rt3}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${se4}${r3}`, { method: "POST", body: JSON.stringify(i3) });
    }, this.getAppDomain = () => Nt4().url, this.logger = E(t, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var yn3 = Object.defineProperty;
var gi3 = Object.getOwnPropertySymbols;
var Dn3 = Object.prototype.hasOwnProperty;
var mn2 = Object.prototype.propertyIsEnumerable;
var yi3 = (o4, e, t) => e in o4 ? yn3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Di3 = (o4, e) => {
  for (var t in e || (e = {})) Dn3.call(e, t) && yi3(o4, t, e[t]);
  if (gi3) for (var t of gi3(e)) mn2.call(e, t) && yi3(o4, t, e[t]);
  return o4;
};
var ne4 = class _ne extends n3 {
  constructor(e) {
    var t;
    super(e), this.protocol = ye4, this.version = De2, this.name = ie4, this.events = new import_events12.EventEmitter(), this.initialized = false, this.on = (n4, a5) => this.events.on(n4, a5), this.once = (n4, a5) => this.events.once(n4, a5), this.off = (n4, a5) => this.events.off(n4, a5), this.removeListener = (n4, a5) => this.events.removeListener(n4, a5), this.dispatchEnvelope = ({ topic: n4, message: a5, sessionExists: h7 }) => {
      if (!n4 || !a5) return;
      const c7 = { topic: n4, message: a5, publishedAt: Date.now(), transportType: M7.link_mode };
      this.relayer.onLinkMessageEvent(c7, { sessionExists: h7 });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || be5, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : Ye2.logger }), { logger: i3, chunkLoggerController: r3 } = A({ opts: s2, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = r3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var n4, a5;
      (n4 = this.logChunkController) != null && n4.downloadLogsBlobInBrowser && ((a5 = this.logChunkController) == null || a5.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i3, this.name), this.heartbeat = new i(), this.crypto = new Ht4(this, this.logger, e == null ? void 0 : e.keychain), this.history = new ai3(this, this.logger), this.expirer = new hi3(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h4(Di3(Di3({}, Je4), e == null ? void 0 : e.storageOptions)), this.relayer = new ti3({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new oi3(this, this.logger), this.verify = new ci3(this, this.logger, this.storage), this.echoClient = new li3(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new pi3(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const t = new _ne(e);
    await t.initialize();
    const s2 = await t.crypto.getClientId();
    return await t.storage.setItem(lt2, s2), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(fe5, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(fe5) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var bn3 = ne4;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events13 = __toESM(require_events());
var import_time8 = __toESM(require_cjs());
var be6 = "wc";
var Ce5 = 2;
var Le4 = "client";
var ye5 = `${be6}@${Ce5}:${Le4}:`;
var we6 = { name: Le4, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var xe3 = "WALLETCONNECT_DEEPLINK_CHOICE";
var st5 = "proposal";
var it5 = "Proposal expired";
var rt4 = "session";
var z8 = import_time8.SEVEN_DAYS;
var nt3 = "engine";
var v5 = { wc_sessionPropose: { req: { ttl: import_time8.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time8.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time8.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time8.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time8.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time8.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time8.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var me5 = { min: import_time8.FIVE_MINUTES, max: import_time8.SEVEN_DAYS };
var x8 = { idle: "IDLE", active: "ACTIVE" };
var ot4 = "request";
var at4 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var ct3 = "wc";
var lt3 = "auth";
var pt4 = "authKeys";
var ht4 = "pairingTopics";
var dt3 = "requests";
var oe3 = `${ct3}@${1.5}:${lt3}:`;
var ae5 = `${oe3}:PUB_KEY`;
var ys3 = Object.defineProperty;
var ws2 = Object.defineProperties;
var ms2 = Object.getOwnPropertyDescriptors;
var ut4 = Object.getOwnPropertySymbols;
var _s2 = Object.prototype.hasOwnProperty;
var Es2 = Object.prototype.propertyIsEnumerable;
var gt5 = (q6, o4, e) => o4 in q6 ? ys3(q6, o4, { enumerable: true, configurable: true, writable: true, value: e }) : q6[o4] = e;
var I5 = (q6, o4) => {
  for (var e in o4 || (o4 = {})) _s2.call(o4, e) && gt5(q6, e, o4[e]);
  if (ut4) for (var e of ut4(o4)) Es2.call(o4, e) && gt5(q6, e, o4[e]);
  return q6;
};
var D5 = (q6, o4) => ws2(q6, ms2(o4));
var Rs3 = class extends M5 {
  constructor(o4) {
    super(o4), this.name = nt3, this.events = new import_events13.default(), this.initialized = false, this.requestQueue = { state: x8.idle, queue: [] }, this.sessionRequestQueue = { state: x8.idle, queue: [] }, this.requestQueueDelay = import_time8.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v5) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time8.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = D5(I5({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(t);
      const { pairingTopic: s2, requiredNamespaces: i3, optionalNamespaces: r3, sessionProperties: n4, relays: a5 } = t;
      let c7 = s2, h7, p5 = false;
      try {
        c7 && (p5 = this.client.core.pairing.pairings.get(c7).active);
      } catch (E6) {
        throw this.client.logger.error(`connect() -> pairing.get(${c7}) failed`), E6;
      }
      if (!c7 || !p5) {
        const { topic: E6, uri: S9 } = await this.client.core.pairing.create();
        c7 = E6, h7 = S9;
      }
      if (!c7) {
        const { message: E6 } = S5("NO_MATCHING_KEY", `connect() pairing topic: ${c7}`);
        throw new Error(E6);
      }
      const d6 = await this.client.core.crypto.generateKeyPair(), l7 = v5.wc_sessionPropose.req.ttl || import_time8.FIVE_MINUTES, w5 = Mt3(l7), m2 = I5({ requiredNamespaces: i3, optionalNamespaces: r3, relays: a5 ?? [{ protocol: rt3 }], proposer: { publicKey: d6, metadata: this.client.metadata }, expiryTimestamp: w5, pairingTopic: c7 }, n4 && { sessionProperties: n4 }), { reject: y9, resolve: _6, done: R6 } = _t4(l7, it5);
      this.events.once(Lt3("session_connect"), async ({ error: E6, session: S9 }) => {
        if (E6) y9(E6);
        else if (S9) {
          S9.self.publicKey = d6;
          const M8 = D5(I5({}, S9), { pairingTopic: m2.pairingTopic, requiredNamespaces: m2.requiredNamespaces, optionalNamespaces: m2.optionalNamespaces, transportType: M7.relay });
          await this.client.session.set(S9.topic, M8), await this.setExpiry(S9.topic, S9.expiry), c7 && await this.client.core.pairing.updateMetadata({ topic: c7, metadata: S9.peer.metadata }), this.cleanupDuplicatePairings(M8), _6(M8);
        }
      });
      const V6 = await this.sendRequest({ topic: c7, method: "wc_sessionPropose", params: m2, throwOnFailedPublish: true });
      return await this.setProposal(V6, I5({ id: V6 }, m2)), { uri: h7, approval: R6 };
    }, this.pair = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }, this.approve = async (e) => {
      var t, s2, i3;
      const r3 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e == null ? void 0 : e.id) == null ? void 0 : t.toString(), trace: [Is2.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (N5) {
        throw r3.setError(Ts2.no_internet_connection), N5;
      }
      try {
        await this.isValidProposalId(e == null ? void 0 : e.id);
      } catch (N5) {
        throw this.client.logger.error(`approve() -> proposal.get(${e == null ? void 0 : e.id}) failed`), r3.setError(Ts2.proposal_not_found), N5;
      }
      try {
        await this.isValidApprove(e);
      } catch (N5) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r3.setError(Ts2.session_approve_namespace_validation_failure), N5;
      }
      const { id: n4, relayProtocol: a5, namespaces: c7, sessionProperties: h7, sessionConfig: p5 } = e, d6 = this.client.proposal.get(n4);
      this.client.core.eventClient.deleteEvent({ eventId: r3.eventId });
      const { pairingTopic: l7, proposer: w5, requiredNamespaces: m2, optionalNamespaces: y9 } = d6;
      let _6 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: l7 });
      _6 || (_6 = (i3 = this.client.core.eventClient) == null ? void 0 : i3.createEvent({ type: Is2.session_approve_started, properties: { topic: l7, trace: [Is2.session_approve_started, Is2.session_namespaces_validation_success] } }));
      const R6 = await this.client.core.crypto.generateKeyPair(), V6 = w5.publicKey, E6 = await this.client.core.crypto.generateSharedKey(R6, V6), S9 = I5(I5({ relay: { protocol: a5 ?? "irn" }, namespaces: c7, controller: { publicKey: R6, metadata: this.client.metadata }, expiry: Mt3(z8) }, h7 && { sessionProperties: h7 }), p5 && { sessionConfig: p5 }), M8 = M7.relay;
      _6.addTrace(Is2.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(E6, { transportType: M8 });
      } catch (N5) {
        throw _6.setError(Ts2.subscribe_session_topic_failure), N5;
      }
      _6.addTrace(Is2.subscribe_session_topic_success);
      const W4 = D5(I5({}, S9), { topic: E6, requiredNamespaces: m2, optionalNamespaces: y9, pairingTopic: l7, acknowledged: false, self: S9.controller, peer: { publicKey: w5.publicKey, metadata: w5.metadata }, controller: R6, transportType: M7.relay });
      await this.client.session.set(E6, W4), _6.addTrace(Is2.store_session);
      try {
        _6.addTrace(Is2.publishing_session_settle), await this.sendRequest({ topic: E6, method: "wc_sessionSettle", params: S9, throwOnFailedPublish: true }).catch((N5) => {
          throw _6 == null ? void 0 : _6.setError(Ts2.session_settle_publish_failure), N5;
        }), _6.addTrace(Is2.session_settle_publish_success), _6.addTrace(Is2.publishing_session_approve), await this.sendResult({ id: n4, topic: l7, result: { relay: { protocol: a5 ?? "irn" }, responderPublicKey: R6 }, throwOnFailedPublish: true }).catch((N5) => {
          throw _6 == null ? void 0 : _6.setError(Ts2.session_approve_publish_failure), N5;
        }), _6.addTrace(Is2.session_approve_publish_success);
      } catch (N5) {
        throw this.client.logger.error(N5), this.client.session.delete(E6, U3("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(E6), N5;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _6.eventId }), await this.client.core.pairing.updateMetadata({ topic: l7, metadata: w5.metadata }), await this.client.proposal.delete(n4, U3("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l7 }), await this.setExpiry(E6, Mt3(z8)), { topic: E6, acknowledged: () => Promise.resolve(this.client.session.get(E6)) };
    }, this.reject = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e);
      } catch (r3) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r3;
      }
      const { id: t, reason: s2 } = e;
      let i3;
      try {
        i3 = this.client.proposal.get(t).pairingTopic;
      } catch (r3) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r3;
      }
      i3 && (await this.sendError({ id: t, topic: i3, error: s2, rpcOpts: v5.wc_sessionPropose.reject }), await this.client.proposal.delete(t, U3("USER_DISCONNECTED")));
    }, this.update = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e);
      } catch (p5) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p5;
      }
      const { topic: t, namespaces: s2 } = e, { done: i3, resolve: r3, reject: n4 } = _t4(), a5 = payloadId(), c7 = getBigIntRpcId().toString(), h7 = this.client.session.get(t).namespaces;
      return this.events.once(Lt3("session_update", a5), ({ error: p5 }) => {
        p5 ? n4(p5) : r3();
      }), await this.client.session.update(t, { namespaces: s2 }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a5, relayRpcId: c7 }).catch((p5) => {
        this.client.logger.error(p5), this.client.session.update(t, { namespaces: h7 }), n4(p5);
      }), { acknowledged: i3 };
    }, this.extend = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e);
      } catch (a5) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a5;
      }
      const { topic: t } = e, s2 = payloadId(), { done: i3, resolve: r3, reject: n4 } = _t4();
      return this.events.once(Lt3("session_extend", s2), ({ error: a5 }) => {
        a5 ? n4(a5) : r3();
      }), await this.setExpiry(t, Mt3(z8)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a5) => {
        n4(a5);
      }), { acknowledged: i3 };
    }, this.request = async (e) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e);
      } catch (w5) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), w5;
      }
      const { chainId: t, request: s2, topic: i3, expiry: r3 = v5.wc_sessionRequest.req.ttl } = e, n4 = this.client.session.get(i3);
      (n4 == null ? void 0 : n4.transportType) === M7.relay && await this.confirmOnlineStateOrThrow();
      const a5 = payloadId(), c7 = getBigIntRpcId().toString(), { done: h7, resolve: p5, reject: d6 } = _t4(r3, "Request expired. Please try again.");
      this.events.once(Lt3("session_request", a5), ({ error: w5, result: m2 }) => {
        w5 ? d6(w5) : p5(m2);
      });
      const l7 = this.getAppLinkIfEnabled(n4.peer.metadata, n4.transportType);
      return l7 ? (await this.sendRequest({ clientRpcId: a5, relayRpcId: c7, topic: i3, method: "wc_sessionRequest", params: { request: D5(I5({}, s2), { expiryTimestamp: Mt3(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true, appLink: l7 }).catch((w5) => d6(w5)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a5 }), await h7()) : await Promise.all([new Promise(async (w5) => {
        await this.sendRequest({ clientRpcId: a5, relayRpcId: c7, topic: i3, method: "wc_sessionRequest", params: { request: D5(I5({}, s2), { expiryTimestamp: Mt3(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true }).catch((m2) => d6(m2)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a5 }), w5();
      }), new Promise(async (w5) => {
        var m2;
        if (!((m2 = n4.sessionConfig) != null && m2.disableDeepLink)) {
          const y9 = await qt3(this.client.core.storage, xe3);
          await Ft4({ id: a5, topic: i3, wcDeepLink: y9 });
        }
        w5();
      }), h7()]).then((w5) => w5[2]);
    }, this.respond = async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: t, response: s2 } = e, { id: i3 } = s2, r3 = this.client.session.get(t);
      r3.transportType === M7.relay && await this.confirmOnlineStateOrThrow();
      const n4 = this.getAppLinkIfEnabled(r3.peer.metadata, r3.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i3, topic: t, result: s2.result, throwOnFailedPublish: true, appLink: n4 }) : isJsonRpcError(s2) && await this.sendError({ id: i3, topic: t, error: s2.error, appLink: n4 }), this.cleanupAfterResponse(e);
    }, this.ping = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) {
        const s2 = payloadId(), i3 = getBigIntRpcId().toString(), { done: r3, resolve: n4, reject: a5 } = _t4();
        this.events.once(Lt3("session_ping", s2), ({ error: c7 }) => {
          c7 ? a5(c7) : n4();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i3 }), r3()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && await this.client.core.pairing.ping({ topic: t });
    }, this.emit = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
      const { topic: t, event: s2, chainId: i3 } = e, r3 = getBigIntRpcId().toString();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s2, chainId: i3 }, throwOnFailedPublish: true, relayRpcId: r3 });
    }, this.disconnect = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: U3("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s2 } = S5("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s2);
      }
    }, this.find = (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => zr4(t, e))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (e, t) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(e);
      const i3 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), r3 = i3 ? M7.link_mode : M7.relay;
      r3 === M7.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n4, statement: a5 = "", uri: c7, domain: h7, nonce: p5, type: d6, exp: l7, nbf: w5, methods: m2 = [], expiry: y9 } = e, _6 = [...e.resources || []], { topic: R6, uri: V6 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r3 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: R6, uri: V6 } });
      const E6 = await this.client.core.crypto.generateKeyPair(), S9 = hr3(E6);
      if (await Promise.all([this.client.auth.authKeys.set(ae5, { responseTopic: S9, publicKey: E6 }), this.client.auth.pairingTopics.set(S9, { topic: S9, pairingTopic: R6 })]), await this.client.core.relayer.subscribe(S9, { transportType: r3 }), this.client.logger.info(`sending request to new pairing topic: ${R6}`), m2.length > 0) {
        const { namespace: O8 } = re3(n4[0]);
        let T4 = ir4(O8, "request", m2);
        Y2(_6) && (T4 = cr4(T4, _6.pop())), _6.push(T4);
      }
      const M8 = y9 && y9 > v5.wc_sessionAuthenticate.req.ttl ? y9 : v5.wc_sessionAuthenticate.req.ttl, W4 = { authPayload: { type: d6 ?? "caip122", chains: n4, statement: a5, aud: c7, domain: h7, version: "1", nonce: p5, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: l7, nbf: w5, resources: _6 }, requester: { publicKey: E6, metadata: this.client.metadata }, expiryTimestamp: Mt3(M8) }, N5 = { eip155: { chains: n4, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m2])], events: ["chainChanged", "accountsChanged"] } }, De3 = { requiredNamespaces: {}, optionalNamespaces: N5, relays: [{ protocol: "irn" }], pairingTopic: R6, proposer: { publicKey: E6, metadata: this.client.metadata }, expiryTimestamp: Mt3(v5.wc_sessionPropose.req.ttl) }, { done: wt5, resolve: Ve3, reject: Ee6 } = _t4(M8, "Request expired"), ce4 = async ({ error: O8, session: T4 }) => {
        if (this.events.off(Lt3("session_request", G4), Re2), O8) Ee6(O8);
        else if (T4) {
          T4.self.publicKey = E6, await this.client.session.set(T4.topic, T4), await this.setExpiry(T4.topic, T4.expiry), R6 && await this.client.core.pairing.updateMetadata({ topic: R6, metadata: T4.peer.metadata });
          const le4 = this.client.session.get(T4.topic);
          await this.deleteProposal(Z6), Ve3({ session: le4 });
        }
      }, Re2 = async (O8) => {
        var T4, le4, Me2;
        if (await this.deletePendingAuthRequest(G4, { message: "fulfilled", code: 0 }), O8.error) {
          const te5 = U3("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O8.error.code === te5.code ? void 0 : (this.events.off(Lt3("session_connect"), ce4), Ee6(O8.error.message));
        }
        await this.deleteProposal(Z6), this.events.off(Lt3("session_connect"), ce4);
        const { cacaos: ke3, responder: j6 } = O8.result, Ie5 = [], $e3 = [];
        for (const te5 of ke3) {
          await nr4({ cacao: te5, projectId: this.client.core.projectId }) || (this.client.logger.error(te5, "Signature verification failed"), Ee6(U3("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: fe6 } = te5, ve5 = Y2(fe6.resources), Ke5 = [ln3(fe6.iss)], mt4 = fe4(fe6.iss);
          if (ve5) {
            const qe3 = ar4(ve5), _t6 = ur3(ve5);
            Ie5.push(...qe3), Ke5.push(..._t6);
          }
          for (const qe3 of Ke5) $e3.push(`${qe3}:${mt4}`);
        }
        const ee7 = await this.client.core.crypto.generateSharedKey(E6, j6.publicKey);
        let pe4;
        Ie5.length > 0 && (pe4 = { topic: ee7, acknowledged: true, self: { publicKey: E6, metadata: this.client.metadata }, peer: j6, controller: j6.publicKey, expiry: Mt3(z8), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: R6, namespaces: Jr3([...new Set(Ie5)], [...new Set($e3)]), transportType: r3 }, await this.client.core.relayer.subscribe(ee7, { transportType: r3 }), await this.client.session.set(ee7, pe4), R6 && await this.client.core.pairing.updateMetadata({ topic: R6, metadata: j6.metadata }), pe4 = this.client.session.get(ee7)), (T4 = this.client.metadata.redirect) != null && T4.linkMode && (le4 = j6.metadata.redirect) != null && le4.linkMode && (Me2 = j6.metadata.redirect) != null && Me2.universal && t && (this.client.core.addLinkModeSupportedApp(j6.metadata.redirect.universal), this.client.session.update(ee7, { transportType: M7.link_mode })), Ve3({ auths: ke3, session: pe4 });
      }, G4 = payloadId(), Z6 = payloadId();
      this.events.once(Lt3("session_connect"), ce4), this.events.once(Lt3("session_request", G4), Re2);
      let Se3;
      try {
        if (i3) {
          const O8 = formatJsonRpcRequest("wc_sessionAuthenticate", W4, G4);
          this.client.core.history.set(R6, O8);
          const T4 = await this.client.core.crypto.encode("", O8, { type: M6, encoding: lr3 });
          Se3 = xr3(t, R6, T4);
        } else await Promise.all([this.sendRequest({ topic: R6, method: "wc_sessionAuthenticate", params: W4, expiry: e.expiry, throwOnFailedPublish: true, clientRpcId: G4 }), this.sendRequest({ topic: R6, method: "wc_sessionPropose", params: De3, expiry: v5.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: Z6 })]);
      } catch (O8) {
        throw this.events.off(Lt3("session_connect"), ce4), this.events.off(Lt3("session_request", G4), Re2), O8;
      }
      return await this.setProposal(Z6, I5({ id: Z6 }, De3)), await this.setAuthRequest(G4, { request: D5(I5({}, W4), { verifyContext: {} }), pairingTopic: R6, transportType: r3 }), { uri: Se3 ?? V6, response: wt5 };
    }, this.approveSessionAuthenticate = async (e) => {
      const { id: t, auths: s2 } = e, i3 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [Cs2.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y9) {
        throw i3.setError(Ps2.no_internet_connection), y9;
      }
      const r3 = this.getPendingAuthRequest(t);
      if (!r3) throw i3.setError(Ps2.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const n4 = r3.transportType || M7.relay;
      n4 === M7.relay && await this.confirmOnlineStateOrThrow();
      const a5 = r3.requester.publicKey, c7 = await this.client.core.crypto.generateKeyPair(), h7 = hr3(a5), p5 = { type: D4, receiverPublicKey: a5, senderPublicKey: c7 }, d6 = [], l7 = [];
      for (const y9 of s2) {
        if (!await nr4({ cacao: y9, projectId: this.client.core.projectId })) {
          i3.setError(Ps2.invalid_cacao);
          const S9 = U3("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: h7, error: S9, encodeOpts: p5 }), new Error(S9.message);
        }
        i3.addTrace(Cs2.cacaos_verified);
        const { p: _6 } = y9, R6 = Y2(_6.resources), V6 = [ln3(_6.iss)], E6 = fe4(_6.iss);
        if (R6) {
          const S9 = ar4(R6), M8 = ur3(R6);
          d6.push(...S9), V6.push(...M8);
        }
        for (const S9 of V6) l7.push(`${S9}:${E6}`);
      }
      const w5 = await this.client.core.crypto.generateSharedKey(c7, a5);
      i3.addTrace(Cs2.create_authenticated_session_topic);
      let m2;
      if ((d6 == null ? void 0 : d6.length) > 0) {
        m2 = { topic: w5, acknowledged: true, self: { publicKey: c7, metadata: this.client.metadata }, peer: { publicKey: a5, metadata: r3.requester.metadata }, controller: a5, expiry: Mt3(z8), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r3.pairingTopic, namespaces: Jr3([...new Set(d6)], [...new Set(l7)]), transportType: n4 }, i3.addTrace(Cs2.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w5, { transportType: n4 });
        } catch (y9) {
          throw i3.setError(Ps2.subscribe_authenticated_session_topic_failure), y9;
        }
        i3.addTrace(Cs2.subscribe_authenticated_session_topic_success), await this.client.session.set(w5, m2), i3.addTrace(Cs2.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r3.pairingTopic, metadata: r3.requester.metadata });
      }
      i3.addTrace(Cs2.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: h7, id: t, result: { cacaos: s2, responder: { publicKey: c7, metadata: this.client.metadata } }, encodeOpts: p5, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r3.requester.metadata, n4) });
      } catch (y9) {
        throw i3.setError(Ps2.authenticated_session_approve_publish_failure), y9;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r3.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i3.eventId }), { session: m2 };
    }, this.rejectSessionAuthenticate = async (e) => {
      this.isInitialized();
      const { id: t, reason: s2 } = e, i3 = this.getPendingAuthRequest(t);
      if (!i3) throw new Error(`Could not find pending auth request with id ${t}`);
      i3.transportType === M7.relay && await this.confirmOnlineStateOrThrow();
      const r3 = i3.requester.publicKey, n4 = await this.client.core.crypto.generateKeyPair(), a5 = hr3(r3), c7 = { type: D4, receiverPublicKey: r3, senderPublicKey: n4 };
      await this.sendError({ id: t, topic: a5, error: s2, encodeOpts: c7, rpcOpts: v5.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i3.requester.metadata, i3.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, U3("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (e) => {
      this.isInitialized();
      const { request: t, iss: s2 } = e;
      return dn3(t, s2);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e = this.relayMessageCache.shift();
          e && await this.onRelayMessage(e);
        } catch (e) {
          this.client.logger.error(e);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (e) => {
      if (e.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r3, n4;
          return ((r3 = i3.peerMetadata) == null ? void 0 : r3.url) && ((n4 = i3.peerMetadata) == null ? void 0 : n4.url) === e.peer.metadata.url && i3.topic && i3.topic !== t.topic;
        });
        if (s2.length === 0) return;
        this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.deleteSession = async (e) => {
      var t;
      const { topic: s2, expirerHasDeleted: i3 = false, emitEvent: r3 = true, id: n4 = 0 } = e, { self: a5 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, U3("USER_DISCONNECTED")), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a5.publicKey) && await this.client.core.crypto.deleteKeyPair(a5.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i3 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(xe3).catch((c7) => this.client.logger.warn(c7)), this.getPendingSessionRequests().forEach((c7) => {
        c7.topic === s2 && this.deletePendingSessionRequest(c7.id, U3("USER_DISCONNECTED"));
      }), s2 === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = x8.idle), r3 && this.client.events.emit("session_delete", { id: n4, topic: s2 });
    }, this.deleteProposal = async (e, t) => {
      if (t) try {
        const s2 = this.client.proposal.get(e), i3 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
        i3 == null ? void 0 : i3.setError(Ts2.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e, U3("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
    }, this.deletePendingSessionRequest = async (e, t, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e), s2 && (this.sessionRequestQueue.state = x8.idle, this.client.events.emit("session_request_expire", { id: e }));
    }, this.deletePendingAuthRequest = async (e, t, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(e, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.setExpiry = async (e, t) => {
      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
    }, this.setProposal = async (e, t) => {
      this.client.core.expirer.set(e, Mt3(v5.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
    }, this.setAuthRequest = async (e, t) => {
      const { request: s2, pairingTopic: i3, transportType: r3 = M7.relay } = t;
      this.client.core.expirer.set(e, s2.expiryTimestamp), await this.client.auth.requests.set(e, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: e, pairingTopic: i3, verifyContext: s2.verifyContext, transportType: r3 });
    }, this.setPendingSessionRequest = async (e) => {
      const { id: t, topic: s2, params: i3, verifyContext: r3 } = e, n4 = i3.request.expiryTimestamp || Mt3(v5.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, n4), await this.client.pendingRequest.set(t, { id: t, topic: s2, params: i3, verifyContext: r3 });
    }, this.sendRequest = async (e) => {
      const { topic: t, method: s2, params: i3, expiry: r3, relayRpcId: n4, clientRpcId: a5, throwOnFailedPublish: c7, appLink: h7 } = e, p5 = formatJsonRpcRequest(s2, i3, a5);
      let d6;
      const l7 = !!h7;
      try {
        const y9 = l7 ? lr3 : ge2;
        d6 = await this.client.core.crypto.encode(t, p5, { encoding: y9 });
      } catch (y9) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), y9;
      }
      let w5;
      if (at4.includes(s2)) {
        const y9 = yr4(JSON.stringify(p5)), _6 = yr4(d6);
        w5 = await this.client.core.verify.register({ id: _6, decryptedId: y9 });
      }
      const m2 = v5[s2].req;
      if (m2.attestation = w5, r3 && (m2.ttl = r3), n4 && (m2.id = n4), this.client.core.history.set(t, p5), l7) {
        const y9 = xr3(h7, t, d6);
        await global.Linking.openURL(y9, this.client.name);
      } else {
        const y9 = v5[s2].req;
        r3 && (y9.ttl = r3), n4 && (y9.id = n4), c7 ? (y9.internal = D5(I5({}, y9.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d6, y9)) : this.client.core.relayer.publish(t, d6, y9).catch((_6) => this.client.logger.error(_6));
      }
      return p5.id;
    }, this.sendResult = async (e) => {
      const { id: t, topic: s2, result: i3, throwOnFailedPublish: r3, encodeOpts: n4, appLink: a5 } = e, c7 = formatJsonRpcResult(t, i3);
      let h7;
      const p5 = a5 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l7 = p5 ? lr3 : ge2;
        h7 = await this.client.core.crypto.encode(s2, c7, D5(I5({}, n4 || {}), { encoding: l7 }));
      } catch (l7) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), l7;
      }
      let d6;
      try {
        d6 = await this.client.core.history.get(s2, t);
      } catch (l7) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${t}) failed`), l7;
      }
      if (p5) {
        const l7 = xr3(a5, s2, h7);
        await global.Linking.openURL(l7, this.client.name);
      } else {
        const l7 = v5[d6.request.method].res;
        r3 ? (l7.internal = D5(I5({}, l7.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, h7, l7)) : this.client.core.relayer.publish(s2, h7, l7).catch((w5) => this.client.logger.error(w5));
      }
      await this.client.core.history.resolve(c7);
    }, this.sendError = async (e) => {
      const { id: t, topic: s2, error: i3, encodeOpts: r3, rpcOpts: n4, appLink: a5 } = e, c7 = formatJsonRpcError(t, i3);
      let h7;
      const p5 = a5 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l7 = p5 ? lr3 : ge2;
        h7 = await this.client.core.crypto.encode(s2, c7, D5(I5({}, r3 || {}), { encoding: l7 }));
      } catch (l7) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), l7;
      }
      let d6;
      try {
        d6 = await this.client.core.history.get(s2, t);
      } catch (l7) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${t}) failed`), l7;
      }
      if (p5) {
        const l7 = xr3(a5, s2, h7);
        await global.Linking.openURL(l7, this.client.name);
      } else {
        const l7 = n4 || v5[d6.request.method].res;
        this.client.core.relayer.publish(s2, h7, l7);
      }
      await this.client.core.history.resolve(c7);
    }, this.cleanup = async () => {
      const e = [], t = [];
      this.client.session.getAll().forEach((s2) => {
        let i3 = false;
        Kt3(s2.expiry) && (i3 = true), this.client.core.crypto.keychain.has(s2.topic) || (i3 = true), i3 && e.push(s2.topic);
      }), this.client.proposal.getAll().forEach((s2) => {
        Kt3(s2.expiryTimestamp) && t.push(s2.id);
      }), await Promise.all([...e.map((s2) => this.deleteSession({ topic: s2 })), ...t.map((s2) => this.deleteProposal(s2))]);
    }, this.onRelayEventRequest = async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === x8.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = x8.active;
        const e = this.requestQueue.queue.shift();
        if (e) try {
          await this.processRequest(e);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = x8.idle;
    }, this.processRequest = async (e) => {
      const { topic: t, payload: s2, attestation: i3, transportType: r3, encryptedId: n4 } = e, a5 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a5 })) switch (a5) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s2);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s2);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s2);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s2);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s2);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4, transportType: r3 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s2);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4, transportType: r3 });
        default:
          return this.client.logger.info(`Unsupported request method ${a5}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: t, payload: s2, transportType: i3 } = e, r3 = (await this.client.core.history.get(t, s2.id)).request.method;
      switch (r3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s2, i3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${r3}`);
      }
    }, this.onRelayEventUnknownPayload = (e) => {
      const { topic: t } = e, { message: s2 } = S5("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }, this.shouldIgnorePairingRequest = (e) => {
      const { topic: t, requestMethod: s2 } = e, i3 = this.expectedPairingMethodMap.get(t);
      return !i3 || i3.includes(s2) ? false : !!(i3.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (e) => {
      const { topic: t, payload: s2, attestation: i3, encryptedId: r3 } = e, { params: n4, id: a5 } = s2;
      try {
        const c7 = this.client.core.eventClient.getEvent({ topic: t });
        this.isValidConnect(I5({}, s2.params));
        const h7 = n4.expiryTimestamp || Mt3(v5.wc_sessionPropose.req.ttl), p5 = I5({ id: a5, pairingTopic: t, expiryTimestamp: h7 }, n4);
        await this.setProposal(a5, p5);
        const d6 = await this.getVerifyContext({ attestationId: i3, hash: yr4(JSON.stringify(s2)), encryptedId: r3, metadata: p5.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), c7 == null ? void 0 : c7.setError($4.proposal_listener_not_found)), c7 == null ? void 0 : c7.addTrace(z7.emit_session_proposal), this.client.events.emit("session_proposal", { id: a5, params: p5, verifyContext: d6 });
      } catch (c7) {
        await this.sendError({ id: a5, topic: t, error: c7, rpcOpts: v5.wc_sessionPropose.autoReject }), this.client.logger.error(c7);
      }
    }, this.onSessionProposeResponse = async (e, t, s2) => {
      const { id: i3 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r3 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r3 });
        const n4 = this.client.proposal.get(i3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n4 });
        const a5 = n4.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a5 });
        const c7 = r3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c7 });
        const h7 = await this.client.core.crypto.generateSharedKey(a5, c7);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: h7 });
        const p5 = await this.client.core.relayer.subscribe(h7, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p5 }), await this.client.core.pairing.activate({ topic: e });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i3, U3("USER_DISCONNECTED"));
        const r3 = Lt3("session_connect");
        if (this.events.listenerCount(r3) === 0) throw new Error(`emitting ${r3} without any listeners, 954`);
        this.events.emit(Lt3("session_connect"), { error: t.error });
      }
    }, this.onSessionSettleRequest = async (e, t) => {
      const { id: s2, params: i3 } = t;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r3, controller: n4, expiry: a5, namespaces: c7, sessionProperties: h7, sessionConfig: p5 } = t.params, d6 = D5(I5(I5({ topic: e, relay: r3, expiry: a5, namespaces: c7, acknowledged: true, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: n4.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: n4.publicKey, metadata: n4.metadata } }, h7 && { sessionProperties: h7 }), p5 && { sessionConfig: p5 }), { transportType: M7.relay }), l7 = Lt3("session_connect");
        if (this.events.listenerCount(l7) === 0) throw new Error(`emitting ${l7} without any listeners 997`);
        this.events.emit(Lt3("session_connect"), { session: d6 }), await this.sendResult({ id: t.id, topic: e, result: true, throwOnFailedPublish: true });
      } catch (r3) {
        await this.sendError({ id: s2, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionSettleResponse = async (e, t) => {
      const { id: s2 } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(Lt3("session_approve", s2), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, U3("USER_DISCONNECTED")), this.events.emit(Lt3("session_approve", s2), { error: t.error }));
    }, this.onSessionUpdateRequest = async (e, t) => {
      const { params: s2, id: i3 } = t;
      try {
        const r3 = `${e}_session_update`, n4 = yo.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, i3)) {
          this.client.logger.info(`Discarding out of sync request - ${i3}`), this.sendError({ id: i3, topic: e, error: U3("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I5({ topic: e }, s2));
        try {
          yo.set(r3, i3), await this.client.session.update(e, { namespaces: s2.namespaces }), await this.sendResult({ id: i3, topic: e, result: true, throwOnFailedPublish: true });
        } catch (a5) {
          throw yo.delete(r3), a5;
        }
        this.client.events.emit("session_update", { id: i3, topic: e, params: s2 });
      } catch (r3) {
        await this.sendError({ id: i3, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.isRequestOutOfSync = (e, t) => parseInt(t.toString().slice(0, -3)) <= parseInt(e.toString().slice(0, -3)), this.onSessionUpdateResponse = (e, t) => {
      const { id: s2 } = t, i3 = Lt3("session_update", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Lt3("session_update", s2), {}) : isJsonRpcError(t) && this.events.emit(Lt3("session_update", s2), { error: t.error });
    }, this.onSessionExtendRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, Mt3(z8)), await this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s2, topic: e });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e, t) => {
      const { id: s2 } = t, i3 = Lt3("session_extend", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Lt3("session_extend", s2), {}) : isJsonRpcError(t) && this.events.emit(Lt3("session_extend", s2), { error: t.error });
    }, this.onSessionPingRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s2, topic: e });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e, t) => {
      const { id: s2 } = t, i3 = Lt3("session_ping", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t) ? this.events.emit(Lt3("session_ping", s2), {}) : isJsonRpcError(t) && this.events.emit(Lt3("session_ping", s2), { error: t.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidDisconnect({ topic: e, reason: t.params }), Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(v4.publish, async () => {
            i3(await this.deleteSession({ topic: e, id: s2 }));
          });
        }), this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: U3("USER_DISCONNECTED") })]).catch((i3) => this.client.logger.error(i3));
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e) => {
      var t, s2, i3;
      const { topic: r3, payload: n4, attestation: a5, encryptedId: c7, transportType: h7 } = e, { id: p5, params: d6 } = n4;
      try {
        await this.isValidRequest(I5({ topic: r3 }, d6));
        const l7 = this.client.session.get(r3), w5 = await this.getVerifyContext({ attestationId: a5, hash: yr4(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", d6, p5))), encryptedId: c7, metadata: l7.peer.metadata, transportType: h7 }), m2 = { id: p5, topic: r3, params: d6, verifyContext: w5 };
        await this.setPendingSessionRequest(m2), h7 === M7.link_mode && (t = l7.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s2 = l7.peer.metadata.redirect) == null ? void 0 : s2.universal), (i3 = this.client.signConfig) != null && i3.disableRequestQueue ? this.emitSessionRequest(m2) : (this.addSessionRequestToSessionRequestQueue(m2), this.processSessionRequestQueue());
      } catch (l7) {
        await this.sendError({ id: p5, topic: r3, error: l7 }), this.client.logger.error(l7);
      }
    }, this.onSessionRequestResponse = (e, t) => {
      const { id: s2 } = t, i3 = Lt3("session_request", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Lt3("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Lt3("session_request", s2), { error: t.error });
    }, this.onSessionEventRequest = async (e, t) => {
      const { id: s2, params: i3 } = t;
      try {
        const r3 = `${e}_session_event_${i3.event.name}`, n4 = yo.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(I5({ topic: e }, i3)), this.client.events.emit("session_event", { id: s2, topic: e, params: i3 }), yo.set(r3, s2);
      } catch (r3) {
        await this.sendError({ id: s2, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionAuthenticateResponse = (e, t) => {
      const { id: s2 } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e, payload: t }), isJsonRpcResult(t) ? this.events.emit(Lt3("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Lt3("session_request", s2), { error: t.error });
    }, this.onSessionAuthenticateRequest = async (e) => {
      var t;
      const { topic: s2, payload: i3, attestation: r3, encryptedId: n4, transportType: a5 } = e;
      try {
        const { requester: c7, authPayload: h7, expiryTimestamp: p5 } = i3.params, d6 = await this.getVerifyContext({ attestationId: r3, hash: yr4(JSON.stringify(i3)), encryptedId: n4, metadata: c7.metadata, transportType: a5 }), l7 = { requester: c7, pairingTopic: s2, id: i3.id, authPayload: h7, verifyContext: d6, expiryTimestamp: p5 };
        await this.setAuthRequest(i3.id, { request: l7, pairingTopic: s2, transportType: a5 }), a5 === M7.link_mode && (t = c7.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(c7.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i3.params, id: i3.id, verifyContext: d6 });
      } catch (c7) {
        this.client.logger.error(c7);
        const h7 = i3.params.requester.publicKey, p5 = await this.client.core.crypto.generateKeyPair(), d6 = this.getAppLinkIfEnabled(i3.params.requester.metadata, a5), l7 = { type: D4, receiverPublicKey: h7, senderPublicKey: p5 };
        await this.sendError({ id: i3.id, topic: s2, error: c7, encodeOpts: l7, rpcOpts: v5.wc_sessionAuthenticate.autoReject, appLink: d6 });
      }
    }, this.addSessionRequestToSessionRequestQueue = (e) => {
      this.sessionRequestQueue.queue.push(e);
    }, this.cleanupAfterResponse = (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = x8.idle, this.processSessionRequestQueue();
      }, (0, import_time8.toMiliseconds)(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: e, error: t }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i3) => i3.topic === e && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        const r3 = i3.request.id, n4 = Lt3("session_request", r3);
        if (this.events.listenerCount(n4) === 0) throw new Error(`emitting ${n4} without any listeners`);
        this.events.emit(Lt3("session_request", i3.request.id), { error: t });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === x8.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = x8.active, this.emitSessionRequest(e);
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.emitSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onPairingCreated = (e) => {
      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
      const t = this.client.proposal.getAll().find((s2) => s2.pairingTopic === e.topic);
      t && this.onSessionProposeRequest({ topic: e.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties }, t.id) });
    }, this.isValidConnect = async (e) => {
      if (!to2(e)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(a5);
      }
      const { pairingTopic: t, requiredNamespaces: s2, optionalNamespaces: i3, sessionProperties: r3, relays: n4 } = e;
      if (I3(t) || await this.isValidPairingTopic(t), !eo2(n4, true)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", `connect() relays: ${n4}`);
        throw new Error(a5);
      }
      !I3(s2) && Z3(s2) !== 0 && this.validateNamespaces(s2, "requiredNamespaces"), !I3(i3) && Z3(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), I3(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.validateNamespaces = (e, t) => {
      const s2 = Xr2(e, "connect()", t);
      if (s2) throw new Error(s2.message);
    }, this.isValidApprove = async (e) => {
      if (!to2(e)) throw new Error(S5("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: t, namespaces: s2, relayProtocol: i3, sessionProperties: r3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const n4 = this.client.proposal.get(t), a5 = Wn3(s2, "approve()");
      if (a5) throw new Error(a5.message);
      const c7 = zn3(n4.requiredNamespaces, s2, "approve()");
      if (c7) throw new Error(c7.message);
      if (!b3(i3, true)) {
        const { message: h7 } = S5("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(h7);
      }
      I3(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.isValidReject = async (e) => {
      if (!to2(e)) {
        const { message: i3 } = S5("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i3);
      }
      const { id: t, reason: s2 } = e;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !ro3(s2)) {
        const { message: i3 } = S5("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e) => {
      if (!to2(e)) {
        const { message: c7 } = S5("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(c7);
      }
      const { relay: t, controller: s2, namespaces: i3, expiry: r3 } = e;
      if (!Jn3(t)) {
        const { message: c7 } = S5("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c7);
      }
      const n4 = Zr3(s2, "onSessionSettleRequest()");
      if (n4) throw new Error(n4.message);
      const a5 = Wn3(i3, "onSessionSettleRequest()");
      if (a5) throw new Error(a5.message);
      if (Kt3(r3)) {
        const { message: c7 } = S5("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c7);
      }
    }, this.isValidUpdate = async (e) => {
      if (!to2(e)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a5);
      }
      const { topic: t, namespaces: s2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i3 = this.client.session.get(t), r3 = Wn3(s2, "update()");
      if (r3) throw new Error(r3.message);
      const n4 = zn3(i3.requiredNamespaces, s2, "update()");
      if (n4) throw new Error(n4.message);
    }, this.isValidExtend = async (e) => {
      if (!to2(e)) {
        const { message: s2 } = S5("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }, this.isValidRequest = async (e) => {
      if (!to2(e)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a5);
      }
      const { topic: t, request: s2, chainId: i3, expiry: r3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: n4 } = this.client.session.get(t);
      if (!co3(n4, i3)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a5);
      }
      if (!oo2(s2)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a5);
      }
      if (!ao3(n4, i3, s2.method)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a5);
      }
      if (r3 && !po2(r3, me5)) {
        const { message: a5 } = S5("MISSING_OR_INVALID", `request() expiry: ${r3}. Expiry must be a number (in seconds) between ${me5.min} and ${me5.max}`);
        throw new Error(a5);
      }
    }, this.isValidRespond = async (e) => {
      var t;
      if (!to2(e)) {
        const { message: r3 } = S5("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(r3);
      }
      const { topic: s2, response: i3 } = e;
      try {
        await this.isValidSessionTopic(s2);
      } catch (r3) {
        throw (t = e == null ? void 0 : e.response) != null && t.id && this.cleanupAfterResponse(e), r3;
      }
      if (!so2(i3)) {
        const { message: r3 } = S5("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(r3);
      }
    }, this.isValidPing = async (e) => {
      if (!to2(e)) {
        const { message: s2 } = S5("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidEmit = async (e) => {
      if (!to2(e)) {
        const { message: n4 } = S5("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(n4);
      }
      const { topic: t, event: s2, chainId: i3 } = e;
      await this.isValidSessionTopic(t);
      const { namespaces: r3 } = this.client.session.get(t);
      if (!co3(r3, i3)) {
        const { message: n4 } = S5("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(n4);
      }
      if (!io2(s2)) {
        const { message: n4 } = S5("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
      if (!uo2(r3, i3, s2.name)) {
        const { message: n4 } = S5("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
    }, this.isValidDisconnect = async (e) => {
      if (!to2(e)) {
        const { message: s2 } = S5("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidAuthenticate = (e) => {
      const { chains: t, uri: s2, domain: i3, nonce: r3 } = e;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!b3(s2, false)) throw new Error("uri is required parameter");
      if (!b3(i3, false)) throw new Error("domain is required parameter");
      if (!b3(r3, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a5) => re3(a5).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n4 } = re3(t[0]);
      if (n4 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (e) => {
      const { attestationId: t, hash: s2, encryptedId: i3, metadata: r3, transportType: n4 } = e, a5 = { verified: { verifyUrl: r3.verifyUrl || J3, validation: "UNKNOWN", origin: r3.url || "" } };
      try {
        if (n4 === M7.link_mode) {
          const h7 = this.getAppLinkIfEnabled(r3, n4);
          return a5.verified.validation = h7 && new URL(h7).origin === new URL(r3.url).origin ? "VALID" : "INVALID", a5;
        }
        const c7 = await this.client.core.verify.resolve({ attestationId: t, hash: s2, encryptedId: i3, verifyUrl: r3.verifyUrl });
        c7 && (a5.verified.origin = c7.origin, a5.verified.isScam = c7.isScam, a5.verified.validation = c7.origin === new URL(r3.url).origin ? "VALID" : "INVALID");
      } catch (c7) {
        this.client.logger.warn(c7);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a5)}`), a5;
    }, this.validateSessionProps = (e, t) => {
      Object.values(e).forEach((s2) => {
        if (!b3(s2, false)) {
          const { message: i3 } = S5("MISSING_OR_INVALID", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s2)}`);
          throw new Error(i3);
        }
      });
    }, this.getPendingAuthRequest = (e) => {
      const t = this.client.auth.requests.get(e);
      return typeof t == "object" ? t : void 0;
    }, this.addToRecentlyDeleted = (e, t) => {
      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i3 = this.recentlyDeletedLimit / 2;
        for (const r3 of this.recentlyDeletedMap.keys()) {
          if (s2++ >= i3) break;
          this.recentlyDeletedMap.delete(r3);
        }
      }
    }, this.checkRecentlyDeleted = (e) => {
      const t = this.recentlyDeletedMap.get(e);
      if (t) {
        const { message: s2 } = S5("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
        throw new Error(s2);
      }
    }, this.isLinkModeEnabled = (e, t) => {
      var s2, i3, r3, n4, a5, c7, h7, p5, d6;
      return !e || t !== M7.link_mode ? false : ((i3 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i3.linkMode) === true && ((n4 = (r3 = this.client.metadata) == null ? void 0 : r3.redirect) == null ? void 0 : n4.universal) !== void 0 && ((c7 = (a5 = this.client.metadata) == null ? void 0 : a5.redirect) == null ? void 0 : c7.universal) !== "" && ((h7 = e == null ? void 0 : e.redirect) == null ? void 0 : h7.universal) !== void 0 && ((p5 = e == null ? void 0 : e.redirect) == null ? void 0 : p5.universal) !== "" && ((d6 = e == null ? void 0 : e.redirect) == null ? void 0 : d6.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (e, t) => {
      var s2;
      return this.isLinkModeEnabled(e, t) ? (s2 = e == null ? void 0 : e.redirect) == null ? void 0 : s2.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: e }) => {
      if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
      const t = Bt4(e, "topic") || "", s2 = decodeURIComponent(Bt4(e, "wc_ev") || ""), i3 = this.client.session.keys.includes(t);
      i3 && this.client.session.update(t, { transportType: M7.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s2, sessionExists: i3 });
    }, this.registerLinkModeListeners = async () => {
      var e;
      if (Wt4() || _4() && (e = this.client.metadata.redirect) != null && e.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await t.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o4 } = S5("NOT_INITIALIZED", this.name);
      throw new Error(o4);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v4.message, (o4) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(o4) : this.onRelayMessage(o4);
    });
  }
  async onRelayMessage(o4) {
    const { topic: e, message: t, attestation: s2, transportType: i3 } = o4, { publicKey: r3 } = this.client.auth.authKeys.keys.includes(ae5) ? this.client.auth.authKeys.get(ae5) : { responseTopic: void 0, publicKey: void 0 }, n4 = await this.client.core.crypto.decode(e, t, { receiverPublicKey: r3, encoding: i3 === M7.link_mode ? lr3 : ge2 });
    try {
      isJsonRpcRequest(n4) ? (this.client.core.history.set(e, n4), this.onRelayEventRequest({ topic: e, payload: n4, attestation: s2, transportType: i3, encryptedId: yr4(t) })) : isJsonRpcResponse(n4) ? (await this.client.core.history.resolve(n4), await this.onRelayEventResponse({ topic: e, payload: n4, transportType: i3 }), this.client.core.history.delete(e, n4.id)) : this.onRelayEventUnknownPayload({ topic: e, payload: n4, transportType: i3 });
    } catch (a5) {
      this.client.logger.error(a5);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(S7.expired, async (o4) => {
      const { topic: e, id: t } = Vt3(o4.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, S5("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, S5("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V4.create, (o4) => this.onPairingCreated(o4)), this.client.core.pairing.events.on(V4.delete, (o4) => {
      this.addToRecentlyDeleted(o4.topic, "pairing");
    });
  }
  isValidPairingTopic(o4) {
    if (!b3(o4, false)) {
      const { message: e } = S5("MISSING_OR_INVALID", `pairing topic should be a string: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o4)) {
      const { message: e } = S5("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (Kt3(this.client.core.pairing.pairings.get(o4).expiry)) {
      const { message: e } = S5("EXPIRED", `pairing topic: ${o4}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(o4) {
    if (!b3(o4, false)) {
      const { message: e } = S5("MISSING_OR_INVALID", `session topic should be a string: ${o4}`);
      throw new Error(e);
    }
    if (this.checkRecentlyDeleted(o4), !this.client.session.keys.includes(o4)) {
      const { message: e } = S5("NO_MATCHING_KEY", `session topic doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (Kt3(this.client.session.get(o4).expiry)) {
      await this.deleteSession({ topic: o4 });
      const { message: e } = S5("EXPIRED", `session topic: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(o4)) {
      const { message: e } = S5("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o4}`);
      throw await this.deleteSession({ topic: o4 }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(o4) {
    if (this.checkRecentlyDeleted(o4), this.client.session.keys.includes(o4)) await this.isValidSessionTopic(o4);
    else if (this.client.core.pairing.pairings.keys.includes(o4)) this.isValidPairingTopic(o4);
    else if (b3(o4, false)) {
      const { message: e } = S5("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o4}`);
      throw new Error(e);
    } else {
      const { message: e } = S5("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o4}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(o4) {
    if (!no3(o4)) {
      const { message: e } = S5("MISSING_OR_INVALID", `proposal id should be a number: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(o4)) {
      const { message: e } = S5("NO_MATCHING_KEY", `proposal id doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (Kt3(this.client.proposal.get(o4).expiryTimestamp)) {
      await this.deleteProposal(o4);
      const { message: e } = S5("EXPIRED", `proposal id: ${o4}`);
      throw new Error(e);
    }
  }
};
var Ss3 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, st5, ye5), this.core = o4, this.logger = e;
  }
};
var yt4 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, rt4, ye5), this.core = o4, this.logger = e;
  }
};
var Is3 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, ot4, ye5, (t) => t.id), this.core = o4, this.logger = e;
  }
};
var fs2 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, pt4, oe3, () => ae5), this.core = o4, this.logger = e;
  }
};
var vs3 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, ht4, oe3), this.core = o4, this.logger = e;
  }
};
var qs3 = class extends ni3 {
  constructor(o4, e) {
    super(o4, e, dt3, oe3, (t) => t.id), this.core = o4, this.logger = e;
  }
};
var Ts3 = class {
  constructor(o4, e) {
    this.core = o4, this.logger = e, this.authKeys = new fs2(this.core, this.logger), this.pairingTopics = new vs3(this.core, this.logger), this.requests = new qs3(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var _e5 = class __e extends S4 {
  constructor(o4) {
    super(o4), this.protocol = be6, this.version = Ce5, this.name = we6.name, this.events = new import_events13.EventEmitter(), this.on = (t, s2) => this.events.on(t, s2), this.once = (t, s2) => this.events.once(t, s2), this.off = (t, s2) => this.events.off(t, s2), this.removeListener = (t, s2) => this.events.removeListener(t, s2), this.removeAllListeners = (t) => this.events.removeAllListeners(t), this.connect = async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approve = async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.reject = async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.update = async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.extend = async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.request = async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.ping = async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.emit = async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.disconnect = async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.find = (t) => {
      try {
        return this.engine.find(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.authenticate = async (t, s2) => {
      try {
        return await this.engine.authenticate(t, s2);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approveSessionAuthenticate = async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.rejectSessionAuthenticate = async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.name = (o4 == null ? void 0 : o4.name) || we6.name, this.metadata = (o4 == null ? void 0 : o4.metadata) || Nt4(), this.signConfig = o4 == null ? void 0 : o4.signConfig;
    const e = typeof (o4 == null ? void 0 : o4.logger) < "u" && typeof (o4 == null ? void 0 : o4.logger) != "string" ? o4.logger : (0, import_pino.default)(k({ level: (o4 == null ? void 0 : o4.logger) || we6.logger }));
    this.core = (o4 == null ? void 0 : o4.core) || new bn3(o4), this.logger = E(e, this.name), this.session = new yt4(this.core, this.logger), this.proposal = new Ss3(this.core, this.logger), this.pendingRequest = new Is3(this.core, this.logger), this.engine = new Rs3(this), this.auth = new Ts3(this.core, this.logger);
  }
  static async init(o4) {
    const e = new __e(o4);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (o4) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o4.message), o4;
    }
  }
};
var Ns3 = yt4;
var Ps3 = _e5;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l6 = { exports: {} };
var c6 = typeof Reflect == "object" ? Reflect : null;
var y8 = c6 && typeof c6.apply == "function" ? c6.apply : function(t, e, n4) {
  return Function.prototype.apply.call(t, e, n4);
};
var f6;
c6 && typeof c6.ownKeys == "function" ? f6 = c6.ownKeys : Object.getOwnPropertySymbols ? f6 = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f6 = function(t) {
  return Object.getOwnPropertyNames(t);
};
function k5(s2) {
  console && console.warn && console.warn(s2);
}
var w4 = Number.isNaN || function(t) {
  return t !== t;
};
function o3() {
  o3.init.call(this);
}
l6.exports = o3, l6.exports.once = K5, o3.EventEmitter = o3, o3.prototype._events = void 0, o3.prototype._eventsCount = 0, o3.prototype._maxListeners = void 0;
var L4 = 10;
function g4(s2) {
  if (typeof s2 != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s2);
}
Object.defineProperty(o3, "defaultMaxListeners", { enumerable: true, get: function() {
  return L4;
}, set: function(s2) {
  if (typeof s2 != "number" || s2 < 0 || w4(s2)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s2 + ".");
  L4 = s2;
} }), o3.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o3.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || w4(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _5(s2) {
  return s2._maxListeners === void 0 ? o3.defaultMaxListeners : s2._maxListeners;
}
o3.prototype.getMaxListeners = function() {
  return _5(this);
}, o3.prototype.emit = function(t) {
  for (var e = [], n4 = 1; n4 < arguments.length; n4++) e.push(arguments[n4]);
  var i3 = t === "error", a5 = this._events;
  if (a5 !== void 0) i3 = i3 && a5.error === void 0;
  else if (!i3) return false;
  if (i3) {
    var r3;
    if (e.length > 0 && (r3 = e[0]), r3 instanceof Error) throw r3;
    var h7 = new Error("Unhandled error." + (r3 ? " (" + r3.message + ")" : ""));
    throw h7.context = r3, h7;
  }
  var u4 = a5[t];
  if (u4 === void 0) return false;
  if (typeof u4 == "function") y8(u4, this, e);
  else for (var d6 = u4.length, M8 = O7(u4, d6), n4 = 0; n4 < d6; ++n4) y8(M8[n4], this, e);
  return true;
};
function S8(s2, t, e, n4) {
  var i3, a5, r3;
  if (g4(e), a5 = s2._events, a5 === void 0 ? (a5 = s2._events = /* @__PURE__ */ Object.create(null), s2._eventsCount = 0) : (a5.newListener !== void 0 && (s2.emit("newListener", t, e.listener ? e.listener : e), a5 = s2._events), r3 = a5[t]), r3 === void 0) r3 = a5[t] = e, ++s2._eventsCount;
  else if (typeof r3 == "function" ? r3 = a5[t] = n4 ? [e, r3] : [r3, e] : n4 ? r3.unshift(e) : r3.push(e), i3 = _5(s2), i3 > 0 && r3.length > i3 && !r3.warned) {
    r3.warned = true;
    var h7 = new Error("Possible EventEmitter memory leak detected. " + r3.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h7.name = "MaxListenersExceededWarning", h7.emitter = s2, h7.type = t, h7.count = r3.length, k5(h7);
  }
  return s2;
}
o3.prototype.addListener = function(t, e) {
  return S8(this, t, e, false);
}, o3.prototype.on = o3.prototype.addListener, o3.prototype.prependListener = function(t, e) {
  return S8(this, t, e, true);
};
function D6() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function C5(s2, t, e) {
  var n4 = { fired: false, wrapFn: void 0, target: s2, type: t, listener: e }, i3 = D6.bind(n4);
  return i3.listener = e, n4.wrapFn = i3, i3;
}
o3.prototype.once = function(t, e) {
  return g4(e), this.on(t, C5(this, t, e)), this;
}, o3.prototype.prependOnceListener = function(t, e) {
  return g4(e), this.prependListener(t, C5(this, t, e)), this;
}, o3.prototype.removeListener = function(t, e) {
  var n4, i3, a5, r3, h7;
  if (g4(e), i3 = this._events, i3 === void 0) return this;
  if (n4 = i3[t], n4 === void 0) return this;
  if (n4 === e || n4.listener === e) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i3[t], i3.removeListener && this.emit("removeListener", t, n4.listener || e));
  else if (typeof n4 != "function") {
    for (a5 = -1, r3 = n4.length - 1; r3 >= 0; r3--) if (n4[r3] === e || n4[r3].listener === e) {
      h7 = n4[r3].listener, a5 = r3;
      break;
    }
    if (a5 < 0) return this;
    a5 === 0 ? n4.shift() : F6(n4, a5), n4.length === 1 && (i3[t] = n4[0]), i3.removeListener !== void 0 && this.emit("removeListener", t, h7 || e);
  }
  return this;
}, o3.prototype.off = o3.prototype.removeListener, o3.prototype.removeAllListeners = function(t) {
  var e, n4, i3;
  if (n4 = this._events, n4 === void 0) return this;
  if (n4.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n4[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n4[t]), this;
  if (arguments.length === 0) {
    var a5 = Object.keys(n4), r3;
    for (i3 = 0; i3 < a5.length; ++i3) r3 = a5[i3], r3 !== "removeListener" && this.removeAllListeners(r3);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = n4[t], typeof e == "function") this.removeListener(t, e);
  else if (e !== void 0) for (i3 = e.length - 1; i3 >= 0; i3--) this.removeListener(t, e[i3]);
  return this;
};
function b6(s2, t, e) {
  var n4 = s2._events;
  if (n4 === void 0) return [];
  var i3 = n4[t];
  return i3 === void 0 ? [] : typeof i3 == "function" ? e ? [i3.listener || i3] : [i3] : e ? z9(i3) : O7(i3, i3.length);
}
o3.prototype.listeners = function(t) {
  return b6(this, t, true);
}, o3.prototype.rawListeners = function(t) {
  return b6(this, t, false);
}, o3.listenerCount = function(s2, t) {
  return typeof s2.listenerCount == "function" ? s2.listenerCount(t) : E5.call(s2, t);
}, o3.prototype.listenerCount = E5;
function E5(s2) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s2];
    if (typeof e == "function") return 1;
    if (e !== void 0) return e.length;
  }
  return 0;
}
o3.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f6(this._events) : [];
};
function O7(s2, t) {
  for (var e = new Array(t), n4 = 0; n4 < t; ++n4) e[n4] = s2[n4];
  return e;
}
function F6(s2, t) {
  for (; t + 1 < s2.length; t++) s2[t] = s2[t + 1];
  s2.pop();
}
function z9(s2) {
  for (var t = new Array(s2.length), e = 0; e < t.length; ++e) t[e] = s2[e].listener || s2[e];
  return t;
}
function K5(s2, t) {
  return new Promise(function(e, n4) {
    function i3(r3) {
      s2.removeListener(t, a5), n4(r3);
    }
    function a5() {
      typeof s2.removeListener == "function" && s2.removeListener("error", i3), e([].slice.call(arguments));
    }
    R5(s2, t, a5, { once: true }), t !== "error" && U5(s2, i3, { once: true });
  });
}
function U5(s2, t, e) {
  typeof s2.on == "function" && R5(s2, "error", t, e);
}
function R5(s2, t, e, n4) {
  if (typeof s2.on == "function") n4.once ? s2.once(t, e) : s2.on(t, e);
  else if (typeof s2.addEventListener == "function") s2.addEventListener(t, function i3(a5) {
    n4.once && s2.removeEventListener(t, i3), e(a5);
  });
  else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s2);
}
var A3 = "wc";
var p4 = "Web3Wallet";
var $6 = `${A3}@2:${p4}:`;
var Q4 = class extends l6.exports {
  constructor() {
    super();
  }
};
var x9 = class {
  constructor(t) {
    this.opts = t;
  }
};
var P5 = class {
  constructor(t) {
    this.client = t;
  }
};
var V5 = Object.defineProperty;
var B5 = Object.defineProperties;
var J4 = Object.getOwnPropertyDescriptors;
var q5 = Object.getOwnPropertySymbols;
var Y3 = Object.prototype.hasOwnProperty;
var Z5 = Object.prototype.propertyIsEnumerable;
var j5 = (s2, t, e) => t in s2 ? V5(s2, t, { enumerable: true, configurable: true, writable: true, value: e }) : s2[t] = e;
var ee6 = (s2, t) => {
  for (var e in t || (t = {})) Y3.call(t, e) && j5(s2, e, t[e]);
  if (q5) for (var e of q5(t)) Z5.call(t, e) && j5(s2, e, t[e]);
  return s2;
};
var te4 = (s2, t) => B5(s2, J4(t));
var se5 = class extends P5 {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await Ps3.init({ core: this.client.core, metadata: this.client.metadata, signConfig: this.client.signConfig }), this.authClient = await zr3.init({ core: this.client.core, projectId: "", metadata: this.client.metadata });
    }, this.pair = async (e) => {
      await this.client.core.pairing.pair(e);
    }, this.approveSession = async (e) => {
      const { topic: n4, acknowledged: i3 } = await this.signClient.approve(te4(ee6({}, e), { id: e.id, namespaces: e.namespaces, sessionProperties: e.sessionProperties, sessionConfig: e.sessionConfig }));
      return await i3(), this.signClient.session.get(n4);
    }, this.rejectSession = async (e) => await this.signClient.reject(e), this.updateSession = async (e) => await this.signClient.update(e), this.extendSession = async (e) => await this.signClient.extend(e), this.respondSessionRequest = async (e) => await this.signClient.respond(e), this.disconnectSession = async (e) => await this.signClient.disconnect(e), this.emitSessionEvent = async (e) => await this.signClient.emit(e), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e, n4) => (e[n4.topic] = n4, e), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e, n4) => await this.authClient.respond(e, n4), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e) => "requester" in e), this.formatMessage = (e, n4) => this.authClient.formatMessage(e, n4), this.approveSessionAuthenticate = async (e) => await this.signClient.approveSessionAuthenticate(e), this.rejectSessionAuthenticate = async (e) => await this.signClient.rejectSessionAuthenticate(e), this.formatAuthMessage = (e) => this.signClient.formatAuthMessage(e), this.registerDeviceToken = (e) => this.client.core.echoClient.registerDeviceToken(e), this.on = (e, n4) => (this.setEvent(e, "off"), this.setEvent(e, "on"), this.client.events.on(e, n4)), this.once = (e, n4) => (this.setEvent(e, "off"), this.setEvent(e, "once"), this.client.events.once(e, n4)), this.off = (e, n4) => (this.setEvent(e, "off"), this.client.events.off(e, n4)), this.removeListener = (e, n4) => (this.setEvent(e, "removeListener"), this.client.events.removeListener(e, n4)), this.onSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onSessionProposal = (e) => {
      this.client.events.emit("session_proposal", e);
    }, this.onSessionDelete = (e) => {
      this.client.events.emit("session_delete", e);
    }, this.onAuthRequest = (e) => {
      this.client.events.emit("auth_request", e);
    }, this.onProposalExpire = (e) => {
      this.client.events.emit("proposal_expire", e);
    }, this.onSessionRequestExpire = (e) => {
      this.client.events.emit("session_request_expire", e);
    }, this.onSessionRequestAuthenticate = (e) => {
      this.client.events.emit("session_authenticate", e);
    }, this.setEvent = (e, n4) => {
      switch (e) {
        case "session_request":
          this.signClient.events[n4]("session_request", this.onSessionRequest);
          break;
        case "session_proposal":
          this.signClient.events[n4]("session_proposal", this.onSessionProposal);
          break;
        case "session_delete":
          this.signClient.events[n4]("session_delete", this.onSessionDelete);
          break;
        case "auth_request":
          this.authClient[n4]("auth_request", this.onAuthRequest);
          break;
        case "proposal_expire":
          this.signClient.events[n4]("proposal_expire", this.onProposalExpire);
          break;
        case "session_request_expire":
          this.signClient.events[n4]("session_request_expire", this.onSessionRequestExpire);
          break;
        case "session_authenticate":
          this.signClient.events[n4]("session_authenticate", this.onSessionRequestAuthenticate);
          break;
      }
    }, this.signClient = {}, this.authClient = {};
  }
};
var ne5 = { decryptMessage: async (s2) => {
  const t = { core: new bn3({ storageOptions: s2.storageOptions, storage: s2.storage }) };
  await t.core.crypto.init();
  const e = t.core.crypto.decode(s2.topic, s2.encryptedMessage);
  return t.core = null, e;
}, getMetadata: async (s2) => {
  const t = { core: new bn3({ storageOptions: s2.storageOptions, storage: s2.storage }), sessionStore: null };
  t.sessionStore = new Ns3(t.core, t.core.logger), await t.sessionStore.init();
  const e = t.sessionStore.get(s2.topic), n4 = e == null ? void 0 : e.peer.metadata;
  return t.core = null, t.sessionStore = null, n4;
} };
var T3 = class extends x9 {
  constructor(s2) {
    super(s2), this.events = new l6.exports(), this.on = (t, e) => this.engine.on(t, e), this.once = (t, e) => this.engine.once(t, e), this.off = (t, e) => this.engine.off(t, e), this.removeListener = (t, e) => this.engine.removeListener(t, e), this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.approveSession = async (t) => {
      try {
        return await this.engine.approveSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.rejectSession = async (t) => {
      try {
        return await this.engine.rejectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.updateSession = async (t) => {
      try {
        return await this.engine.updateSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.extendSession = async (t) => {
      try {
        return await this.engine.extendSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.respondSessionRequest = async (t) => {
      try {
        return await this.engine.respondSessionRequest(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.disconnectSession = async (t) => {
      try {
        return await this.engine.disconnectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.emitSessionEvent = async (t) => {
      try {
        return await this.engine.emitSessionEvent(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respondAuthRequest = async (t, e) => {
      try {
        return await this.engine.respondAuthRequest(t, e);
      } catch (n4) {
        throw this.logger.error(n4.message), n4;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.formatMessage = (t, e) => {
      try {
        return this.engine.formatMessage(t, e);
      } catch (n4) {
        throw this.logger.error(n4.message), n4;
      }
    }, this.registerDeviceToken = (t) => {
      try {
        return this.engine.registerDeviceToken(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.approveSessionAuthenticate = (t) => {
      try {
        return this.engine.approveSessionAuthenticate(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.rejectSessionAuthenticate = (t) => {
      try {
        return this.engine.rejectSessionAuthenticate(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.metadata = s2.metadata, this.name = s2.name || p4, this.signConfig = s2.signConfig, this.core = s2.core, this.logger = this.core.logger, this.engine = new se5(this);
  }
  static async init(s2) {
    const t = new T3(s2);
    return await t.initialize(), t;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (s2) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(s2.message), s2;
    }
  }
};
var v6 = T3;
v6.notifications = ne5;
var ie5 = v6;

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/wc-fbb7ab15.browser.esm.js
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/wallets/dist/base-a72d5b10.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var walletAnalyticsEnabled = true;
function isWalletAnalyticsEnabled() {
  return walletAnalyticsEnabled;
}
function setWalletAnalyticsEnabled(enabled) {
  walletAnalyticsEnabled = enabled;
}
var ANALYTICS_ENDPOINT = "https://c.thirdweb.com/event";
function track(args) {
  if (!isWalletAnalyticsEnabled()) {
    return;
  }
  const {
    clientId,
    walletType,
    walletAddress,
    source,
    action
  } = args;
  const body = {
    source,
    action,
    walletAddress,
    walletType
  };
  fetch(ANALYTICS_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-client-id": clientId,
      ...getAnalyticsHeaders()
    },
    body: JSON.stringify(body)
  });
}
var AbstractClientWallet = class extends AbstractWallet {
  /**
   * @internal
   */
  /**
   * @internal
   */
  getMeta() {
    return this.constructor.meta;
  }
  /**
   * Creates an returns instance of `AbstractClientWallet`
   *
   * @param walletId - A Unique identifier for the wallet ( name of the wallet )
   * @param options - Options for creating wallet instance
   */
  constructor(walletId, options) {
    super();
    this.walletId = walletId;
    this.options = options;
    this.chains = ((options == null ? void 0 : options.chains) || defaultChains).map((c7) => updateChainRPCs(c7, options == null ? void 0 : options.clientId));
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  /**
   * Returns the Wallet Connector used by the wallet
   */
  /**
   * auto-connect the wallet if possible
   * @returns
   */
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return this._connect(true, options);
  }
  /**
   * Connect wallet
   * @param connectOptions - Options for connecting to the wallet
   * @returns
   */
  async connect(connectOptions) {
    this._connectParams = connectOptions;
    const address = await this._connect(false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  /**
   * @internal
   * Get the options used for connecting to the wallet
   * @returns
   */
  getConnectParams() {
    return this._connectParams;
  }
  /**
   * @internal
   * Get the options used for creating the wallet instance
   */
  getOptions() {
    return this.options;
  }
  async _connect(isAutoConnect, connectOptions) {
    const connector = await this.getConnector();
    this._subscribeToEvents(connector);
    const isConnected = await connector.isConnected();
    if (isConnected) {
      const address = await connector.getAddress();
      connector.setupListeners();
      if (connectOptions == null ? void 0 : connectOptions.chainId) {
        await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
      }
      this.emit("connect", {
        address,
        chainId: await this.getChainId()
      });
      this._trackConnection(address);
      return address;
    }
    if (isAutoConnect) {
      throw new Error("Failed to auto connect to the wallet.");
    }
    try {
      const address = await connector.connect(connectOptions);
      this._trackConnection(address);
      return address;
    } catch (error) {
      throw new Error(error.message);
    }
  }
  _trackConnection(address) {
    var _a;
    track({
      clientId: ((_a = this.options) == null ? void 0 : _a.clientId) || "",
      source: "connectWallet",
      action: "connect",
      walletType: this.walletId,
      walletAddress: address
    });
  }
  async _subscribeToEvents(connector) {
    connector.on("connect", (data) => {
      var _a;
      this.emit("connect", {
        address: data.account,
        chainId: (_a = data.chain) == null ? void 0 : _a.id
      });
    });
    connector.on("change", (data) => {
      var _a;
      this.emit("change", {
        address: data.account,
        chainId: (_a = data.chain) == null ? void 0 : _a.id
      });
    });
    connector.on("message", (data) => {
      this.emit("message", data);
    });
    connector.on("disconnect", async () => {
      this.emit("disconnect");
    });
    connector.on("error", (error) => this.emit("error", error));
  }
  /**
   * Get [ethers Signer](https://docs.ethers.org/v5/api/signer/) object of the connected wallet
   */
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  /**
   * Disconnect the wallet
   */
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  /**
   * Switch to different Network/Blockchain in the connected wallet
   * @param chainId - The chainId of the network to switch to
   */
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  /**
   * Update the chains supported by the wallet. This is useful if wallet was initialized with some chains and this needs to be updated without re-initializing the wallet
   */
  async updateChains(chains) {
    this.chains = chains.map((c7) => {
      var _a;
      return updateChainRPCs(c7, (_a = this.options) == null ? void 0 : _a.clientId);
    });
    const connector = await this.getConnector();
    connector.updateChains(this.chains);
  }
  /**
   * If the wallet uses another "personal wallet" under the hood, return it
   *
   * This is only useful for wallets like Safe or Smart Wallet uses a "personal wallet" under the hood to sign transactions. This method returns that wallet
   */
  getPersonalWallet() {
    return void 0;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.browser.esm.js
init_lib3();
var BloctoWallet = class _BloctoWallet extends AbstractClientWallet {
  /**
   * Create a `BloctoWallet` instance
   * @param options - The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### appId (recommended)
   * To get advanced features and support from Blocto, you can create an appId from [blocto dashboard](https://docs.blocto.app/blocto-sdk/register-app-id)
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { BloctoWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new BloctoWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### chain (optional)
   * The Network to connect the wallet to. Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   */
  constructor(options) {
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    super(_BloctoWallet.id, options);
    _defineProperty(this, "name", "Blocto");
  }
  /**
   * @internal
   */
  async initConnector() {
    var _a, _b, _c;
    const {
      BloctoConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-JZ25U3K2.js");
    const bloctoConnector = new BloctoConnector({
      chains: this.chains,
      options: {
        appId: (_a = this.options) == null ? void 0 : _a.appId,
        chainId: (_c = (_b = this.options) == null ? void 0 : _b.chain) == null ? void 0 : _c.chainId
      }
    });
    this.connector = new WagmiAdapter(bloctoConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initConnector();
    }
    return Promise.resolve(this.connector);
  }
};
_defineProperty(BloctoWallet, "id", walletIds.blocto);
_defineProperty(BloctoWallet, "meta", {
  name: "Blocto",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMzNfMjM4NykiPgo8cmVjdCB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHJ4PSIxMiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMyLjkwMjggMTguMzA2M0MyOC4zOTExIDE4LjMwNjMgMjMuOTg3MyAyMC4wNDU5IDIwLjY5NTIgMjMuMTMxOUMxNy4wODQzIDI2LjUxNzYgMTQuNzk5MiAzMS41MTc3IDEzLjQ4OTMgMzYuMjIxMkMxMi42MzE0IDM5LjI5OTIgMTIuMjAxNiA0Mi40OTE1IDEyLjIwMTYgNDUuNjg1M0MxMi4yMDE2IDQ2LjY1MTEgMTIuMjQxMiA0Ny42MDg5IDEyLjMxNzQgNDguNTU1NkMxMi40MTA5IDQ5LjcwNjkgMTMuNTMyMSA1MC41MDQ2IDE0LjY0ODUgNTAuMjAzM0MxNS42MjIyIDQ5Ljk0MTYgMTYuNjQ2NiA0OS44MDA1IDE3LjcwMjggNDkuODAwNUMxOS44NzIyIDQ5LjgwMDUgMjEuOTA1MiA1MC4zOTA0IDIzLjY0OCA1MS40MjEyQzIzLjY5MDggNTEuNDQ2NiAyMy43MzIgNTEuNDcxOSAyMy43NzQ4IDUxLjQ5NTdDMjYuNjA3MSA1My4xODQ2IDI5Ljk0ODQgNTQuMTEyMyAzMy41MTE3IDUzLjk5MzRDNDIuODA2MiA1My42ODU3IDUwLjM5OSA0Ni4xMjMgNTAuNzQxNiAzNi44MzAxQzUxLjExNTggMjYuNjYzNSA0Mi45ODY5IDE4LjMwNDcgMzIuOTA0NCAxOC4zMDQ3TDMyLjkwMjggMTguMzA2M1pNMzIuOTAyOCA0NC4zMTJDMjguMzk3NSA0NC4zMTIgMjQuNzQ1NCA0MC42NTk5IDI0Ljc0NTQgMzYuMTU2MkMyNC43NDU0IDMxLjY1MjUgMjguMzk3NSAyNy45OTg3IDMyLjkwMjggMjcuOTk4N0MzNy40MDgxIDI3Ljk5ODcgNDEuMDYwMiAzMS42NTA5IDQxLjA2MDIgMzYuMTU2MkM0MS4wNjAyIDQwLjY2MTQgMzcuNDA4MSA0NC4zMTIgMzIuOTAyOCA0NC4zMTJaIiBmaWxsPSIjMTRBQUZGIi8+CjxwYXRoIGQ9Ik0yNS41NjM2IDEyLjY4MjZDMjUuNTYzNiAxNS4wMzQ0IDI0LjMzMTUgMTcuMjE2NCAyMi4zMDggMTguNDE1M0MyMS4wMzc3IDE5LjE2ODYgMTkuODQ2OCAyMC4wNTgyIDE4Ljc2ODQgMjEuMDcxNUMxNi4zNzU1IDIzLjMxMzkgMTQuNTg5OCAyNi4wNjUzIDEzLjI2NzMgMjguNzkyOUMxMy4wMDcyIDI5LjMzMDQgMTIuMiAyOS4xNDAyIDEyLjIgMjguNTQyM1YxMi42ODI2QzEyLjIgOC45OTI0MiAxNS4xOTI0IDYgMTguODgyNiA2QzIyLjU3MjggNiAyNS41NjUyIDguOTkyNDIgMjUuNTY1MiAxMi42ODI2SDI1LjU2MzZaIiBmaWxsPSIjMDA3NUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjIzM18yMzg3Ij4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  urls: {
    android: "https://play.google.com/store/apps/details?id=com.portto.blocto",
    ios: "https://apps.apple.com/app/blocto/id1481181682"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
init_lib3();
var EmbeddedWallet = class _EmbeddedWallet extends AbstractClientWallet {
  /**
   * Sends a verification email to the provided email address.
   *
   * @param email - The email address to which the verification email will be sent.
   * @param clientId - Your thirdweb client ID
   * @returns Information on the user's status and whether they are a new user.
   *
   * @example
   * ```typescript
   * EmbeddedWallet.sendVerificationEmail({ email: 'test@example.com', clientId: 'yourClientId' })
   *   .then(() => console.log('Verification email sent successfully.'))
   *   .catch(error => console.error('Failed to send verification email:', error));
   * ```
   */
  static async sendVerificationEmail(options) {
    const wallet = new _EmbeddedWallet({
      chain: c1,
      clientId: options.clientId
    });
    return wallet.sendVerificationEmail({
      email: options.email
    });
  }
  /**
   * Sends a verification sms to the provider phone number.
   *
   * @param phoneNumber - The phone number to which the verification sms will be sent. The phone number must contain the country code.
   * @param clientId - Your thirdweb client ID
   * @returns Information on the user's status and whether they are a new user.
   *
   * @example
   * ```typescript
   * const result = await EmbeddedWallet.sendVerificationEmail({
   *  phoneNumber: '+1234567890',
   *  clientId: 'yourClientId'
   * });
   * ```
   */
  static async sendVerificationSms(options) {
    const wallet = new _EmbeddedWallet({
      chain: c1,
      clientId: options.clientId
    });
    return wallet.sendVerificationSms({
      phoneNumber: options.phoneNumber
    });
  }
  /**
   * @internal
   */
  get walletName() {
    return "Embedded Wallet";
  }
  /**
   * @internal
   */
  /**
   * The options for instantiating an `EmbeddedWallet`
   *
   * @param options -
   * The options object contains the following properties:
   *
   * ### clientId (required)
   * The chain to connect to by default.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * ### chain (required)
   * The chain to connect to by default.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   */
  constructor(options) {
    super(_EmbeddedWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
  }
  async getConnector() {
    var _a, _b;
    if (!this.connector) {
      const {
        EmbeddedWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm-3TJI4NEY.js");
      this.connector = new EmbeddedWalletConnector({
        clientId: ((_a = this.options) == null ? void 0 : _a.clientId) ?? "",
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: (_b = this.options) == null ? void 0 : _b.onAuthSuccess
      });
    }
    return this.connector;
  }
  /**
   * auto connect the wallet if the wallet was previously connected and session is still valid
   */
  autoConnect(connectOptions) {
    if (!connectOptions) {
      throw new Error("Can't autoconnect embedded wallet");
    }
    return this.connect(connectOptions);
  }
  /**
   * @internal
   */
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    return {
      chainId: connectParams.chainId,
      authResult: {
        user: connectParams.authResult.user
      }
    };
  }
  /**
   * Get the email associated with the currently connected wallet.
   * @example
   * ```ts
   * ```javascript
   * const email = await wallet.getEmail();
   * ```
   */
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  /**
   * Get the phone number associated with the currently connected wallet.
   * @example
   * ```ts
   * ```javascript
   * const email = await wallet.getPhoneNumber();
   * ```
   */
  async getPhoneNumber() {
    const connector = await this.getConnector();
    return connector.getPhoneNumber();
  }
  /**
   * Get the instance of `EmbeddedWalletSdk` used by the wallet.
   */
  async getEmbeddedWalletSDK() {
    const connector = await this.getConnector();
    return connector.getEmbeddedWalletSDK();
  }
  // TODO move to connect/auth callback
  async getRecoveryInformation() {
    const connector = await this.getConnector();
    return connector.getRecoveryInformation();
  }
  /**
   * Send a verification code to the user's email for verification.
   * Use this as a prestep before calling `authenticate` with the `email_verification` strategy.
   *
   * ```javascript
   * const result = await wallet.sendVerificationEmail({
   *   email: "alice@example.com",
   * });
   * ```
   *
   * This method is also available as a static method on the `EmbeddedWallet` class.
   * ```javascript
   * const result = await EmbeddedWallet.sendVerificationEmail({
   *  email: "alice@example.com",
   * })
   * ```
   *
   * @param options - The `options` object contains the following properties:
   * ### email (required)
   * The email address to send verification email to.
   *
   * @returns object containing below properties:
   *
   * ```ts
   * {
   *  isNewDevice: boolean;
   *  isNewUser: boolean;
   *  recoveryShareManagement: "USER_MANAGED" | "AWS_MANAGED";
   * }
   * ```
   *
   * ### isNewDevice
   * If user has not logged in from this device before, this will be true.
   *
   * ### isNewUser
   * If user is logging in for the first time, this will be true.
   *
   * ### recoveryShareManagement
   * Recovery share management type. Can be either `USER_MANAGED` or `AWS_MANAGED`.
   *
   */
  async sendVerificationEmail(options) {
    const {
      email
    } = options;
    const connector = await this.getConnector();
    return connector.sendVerificationEmail({
      email
    });
  }
  /**
   * Send a verification code to the user's phone number for verification. The phone number must contain the country code.
   * Use this as a pre-step before calling `authenticate` with the `phone_number_verification` strategy.
   *
   * ```js
   * const result = await wallet.sendVerificationSms({
   *   phoneNumber: "+1234567890",
   * });
   * ```
   *
   * This method is also available as a static method on the `EmbeddedWallet` class.
   * ```javascript
   * const result = await EmbeddedWallet.sendVerificationSms({
   *   phoneNumber: "+1234567890",
   * });
   * ```
   *
   * @param options - The `options` object contains the following properties:
   * ### phoneNumber (required)
   * The phone number to send verification SMS to. The phone number must contain the country code.
   *
   * @returns object containing below properties:
   *
   * ```ts
   * {
   *  isNewDevice: boolean;
   *  isNewUser: boolean;
   *  recoveryShareManagement: "USER_MANAGED" | "AWS_MANAGED";
   * }
   * ```
   *
   * ### isNewDevice
   * If user has not logged in from this device before, this will be true.
   *
   * ### isNewUser
   * If user is logging in for the first time, this will be true.
   *
   * ### recoveryShareManagement
   * Recovery share management type. Can be either `USER_MANAGED` or `AWS_MANAGED`.
   */
  async sendVerificationSms(options) {
    const {
      phoneNumber
    } = options;
    const connector = await this.getConnector();
    return connector.sendVerificationSms({
      phoneNumber
    });
  }
  /**
   * Authenticate the user with any of the available auth strategies.
   *
   * @example
   * ```javascript
   * const authResult = await wallet.authenticate({
   *   strategy: "google",
   * });
   * ```
   *
   * @param params -
   * Choose one of the available auth strategy, which comes with different required arguments.
   * ```ts
   * // email verification
   * type EmailVerificationAuthParams = {
   *   strategy: "email_verification";
   *   email: string;
   *   verificationCode: string;
   *   recoveryCode?: string;
   * };
   *
   * export type EmbeddedWalletOauthStrategy = "google" | "apple" | "facebook";
   *
   * type OauthAuthParams = {
   *   strategy: EmbeddedWalletOauthStrategy;
   *   openedWindow?: Window;
   *   closeOpenedWindow?: (window: Window) => void;
   * };
   *
   * // bring your own authentication
   * type JwtAuthParams = {
   *   strategy: "jwt";
   *   jwt: string;
   *   encryptionKey?: string;
   * };
   *
   * // open iframe to send and input the verification code only
   * type IframeOtpAuthParams = {
   *   strategy: "iframe_email_verification";
   *   email: string;
   * };
   *
   * // open iframe to enter email and verification code
   * type IframeAuthParams = {
   *   strategy: "iframe";
   * };
   * ```
   *
   * @returns
   * The `authResult` object - which you can pass to the `connect` method to connect to the wallet.
   *
   * ```ts
   * const authResult = await wallet.authenticate(authOptions);
   * await wallet.connect({ authResult });
   * ```
   */
  async authenticate(params) {
    const connector = await this.getConnector();
    const authResult = connector.authenticate(params);
    try {
      await this.walletStorage.setItem(LAST_USED_AUTH_STRATEGY, params.strategy);
    } catch {
    }
    return authResult;
  }
  /**
   * @internal
   */
  async getLastUsedAuthStrategy() {
    try {
      return await this.walletStorage.getItem(LAST_USED_AUTH_STRATEGY);
    } catch {
      return null;
    }
  }
  /**
   * After authenticating, you can connect to the wallet by passing the `authResult` to the `connect` method.
   *
   * ```ts
   * const authResult = await wallet.authenticate(authOptions);
   *
   * await wallet.connect({ authResult });
   * ```
   *
   * @param connectOptions - The `connectOptions` object contains the following properties:
   *
   * ### authResult (required)
   *
   * The `authResult` object is returned from the `authenticate` method.
   *
   * @returns The address of the connected wallet.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(EmbeddedWallet, "id", walletIds.embeddedWallet);
_defineProperty(EmbeddedWallet, "meta", {
  name: "Embedded Wallet",
  iconURL: "ipfs://QmNx2evQa6tcQs9VTd3YaDm31ckfStvgRGKFGELahUmrbV/emailIcon.svg"
});
var LAST_USED_AUTH_STRATEGY = "lastUsedAuthStrategy";

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_lib3();
var MetaMaskWallet = class _MetaMaskWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "MetaMask";
  }
  /**
   * @param options -
   * The `options` object contains the following properties:
   *
   * ### clientId (recommended)
   * Provide clientId to use the thirdweb RPCs for given chains
   * You can create a client ID for your application from thirdweb dashboard.
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to MetaMask mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to `defaultChains` ( `import { defaultChains } from "@thirdweb-dev/chains"` )
   *
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { MetaMaskWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new MetaMaskWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrcode (optional)
   * Whether to display the Wallet Connect QR code Modal for connecting to MetaMask on mobile if MetaMask is not injected.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * options to customize the Wallet Connect QR Code Modal ( only relevant when qrcode is true )
   */
  constructor(options) {
    super(_MetaMaskWallet.id, options);
    this.isInjected = !!getInjectedMetamaskProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-2N6BNCOU.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the MetaMask wallet using a QR code if the user does not have the Metamask extension installed.
   *
   * You can use this method to display a QR code. User can scan the QR code from the MetaMask mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * metamask.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, MetaMask will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  /**
   * MetaMask extension on desktop supports switching accounts.
   * This method will trigger the MetaMask extension to show the account switcher Modal
   */
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/wallets/evm/wallets/okx/dist/thirdweb-dev-wallets-evm-wallets-okx.browser.esm.js
init_lib3();
var OKXWallet = class _OKXWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "OKX";
  }
  /**
   * Create instance of `OKXWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_OKXWallet.id, options);
    this.isInjected = !!getInjectedOKXProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OKXConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-okx.browser.esm-AQJM5QRV.js");
        this.OKXConnector = new OKXConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OKXConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the OKX Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(OKXWallet, "id", walletIds.okx);

// node_modules/@thirdweb-dev/wallets/evm/wallets/core-wallet/dist/thirdweb-dev-wallets-evm-wallets-core-wallet.browser.esm.js
init_lib3();
var CoreWallet = class _CoreWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Core wallet";
  }
  /**
   * Create instance of `CoreWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_CoreWallet.id, options);
    this.isInjected = !!getInjectedCoreWalletProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CoreWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-core-wallet.browser.esm-MF6WPAP2.js");
        this.CoreWalletConnector = new CoreWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CoreWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Core Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(CoreWallet, "id", walletIds.coreWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/onekey/dist/thirdweb-dev-wallets-evm-wallets-onekey.browser.esm.js
init_lib3();
var OneKeyWallet = class _OneKeyWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "OneKey wallet";
  }
  /**
   * Create instance of `OneKeyWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_OneKeyWallet.id, options);
    this.isInjected = !!getInjectedOneKeyProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OneKeyConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-onekey.browser.esm-PUER76VS.js");
        this.OneKeyConnector = new OneKeyConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OneKeyConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the OneKey Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(OneKeyWallet, "id", walletIds.oneKey);

// node_modules/@thirdweb-dev/wallets/evm/wallets/crypto-defi-wallet/dist/thirdweb-dev-wallets-evm-wallets-crypto-defi-wallet.browser.esm.js
init_lib3();
var CryptoDefiWallet = class _CryptoDefiWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Crypto Defi wallet";
  }
  /**
   * Create instance of `CryptoDefiWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_CryptoDefiWallet.id, options);
    this.isInjected = !!getInjectedCryptoDefiWalletProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CryptoDefiWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-crypto-defi-wallet.browser.esm-4ALENHI5.js");
        this.CryptoDefiWalletConnector = new CryptoDefiWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CryptoDefiWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Defi Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(CryptoDefiWallet, "id", walletIds.cryptoDefiWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/rabby/dist/thirdweb-dev-wallets-evm-wallets-rabby.browser.esm.js
init_lib3();
var RabbyWallet = class _RabbyWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Rabby wallet";
  }
  /**
   * Create instance of `RabbyWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_RabbyWallet.id, options);
    this.isInjected = !!getInjectedRabbyProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RabbyConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rabby.browser.esm-QZFXUBW7.js");
        this.RabbyConnector = new RabbyConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.RabbyConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Rabby Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RabbyWallet, "id", walletIds.rabby);

// node_modules/@thirdweb-dev/wallets/evm/wallets/coin98/dist/thirdweb-dev-wallets-evm-wallets-coin98.browser.esm.js
init_lib3();
var Coin98Wallet = class _Coin98Wallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Coin98 wallet";
  }
  /**
   * Create instance of `Coin98Wallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_Coin98Wallet.id, options);
    this.isInjected = !!getInjectedCoin98Provider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          Coin98Connector
        } = await import("./thirdweb-dev-wallets-evm-connectors-coin98.browser.esm-YFREKMW4.js");
        this.Coin98Connector = new Coin98Connector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.Coin98Connector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Coin98 Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(Coin98Wallet, "id", walletIds.coin98);

// node_modules/@thirdweb-dev/wallets/dist/getInjectedCoinbaseProvider-b24ac791.browser.esm.js
function getInjectedCoinbaseProvider() {
  var _a;
  function getReady(ethereum) {
    const isCoinbaseWallet = !!(ethereum == null ? void 0 : ethereum.isCoinbaseWallet);
    if (isCoinbaseWallet) {
      return ethereum;
    }
    if (ethereum && "overrideIsMetaMask" in ethereum) {
      if ("providerMap" in ethereum) {
        if (ethereum.providerMap instanceof Map) {
          if (ethereum.providerMap.has("CoinbaseWallet")) {
            return ethereum;
          }
        }
      }
    }
  }
  if (assertWindowEthereum(globalThis.window)) {
    if ((_a = globalThis.window.ethereum) == null ? void 0 : _a.providers) {
      return globalThis.window.ethereum.providers.find(getReady);
    }
    return getReady(globalThis.window.ethereum);
  }
}

// node_modules/@thirdweb-dev/wallets/dist/engine-09701abe.browser.esm.js
init_lib3();
var EngineSigner = class _EngineSigner extends ethers_exports.Signer {
  constructor(config, provider) {
    super();
    this.config = {
      ...config,
      engineUrl: config.engineUrl.replace(/\/$/, "")
    };
    ethers_exports.utils.defineReadOnly(this, "provider", provider || null);
  }
  async getAddress() {
    return this.config.backendWalletAddress;
  }
  async signMessage(message) {
    const res = await this.fetch({
      path: "/backend-wallet/sign-message",
      method: "POST",
      body: {
        message
      }
    });
    return res.result;
  }
  async signTransaction(transaction) {
    var _a, _b, _c, _d, _e6, _f;
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    const res = await this.fetch({
      path: "/backend-wallet/sign-transaction",
      method: "POST",
      body: {
        ...tx,
        nonce: (_a = tx.nonce) == null ? void 0 : _a.toString(),
        gasLimit: (_b = tx.gasLimit) == null ? void 0 : _b.toString(),
        gasPrice: (_c = tx.gasPrice) == null ? void 0 : _c.toString(),
        value: (_d = tx.value) == null ? void 0 : _d.toString(),
        maxPriorityFeePerGas: (_e6 = tx.maxPriorityFeePerGas) == null ? void 0 : _e6.toString(),
        maxFeePerGas: (_f = tx.maxFeePerGas) == null ? void 0 : _f.toString()
      }
    });
    return res.result;
  }
  async sendTransaction(transaction) {
    if (!this.provider) {
      throw new Error("Sending transactions requires a provider!");
    }
    const chainId = (await this.provider.getNetwork()).chainId;
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    const res = await this.fetch({
      path: `/backend-wallet/${chainId}/send-transaction`,
      method: "POST",
      body: {
        toAddress: tx.to,
        data: tx.data,
        value: tx.value || "0"
      }
    });
    const queueId = res.result.queueId;
    return {
      hash: queueId,
      confirmations: 0,
      from: this.config.backendWalletAddress,
      nonce: 0,
      gasLimit: BigNumber.from(0),
      value: BigNumber.from(0),
      data: "",
      chainId,
      wait: async (confirmations) => {
        if (!this.provider) {
          throw new Error("Sending transactions requires a provider!");
        }
        while (true) {
          const {
            result: txRes
          } = await this.fetch({
            path: `/transaction/status/${queueId}`,
            method: "GET"
          });
          switch (txRes.status) {
            case "errored":
              throw new Error(`Transaction errored with reason: ${txRes.errorMessage}`);
            case "cancelled":
              throw new Error(`Transaction execution cancelled.`);
            case "mined":
              const receipt = await this.provider.getTransactionReceipt(txRes.transactionHash);
              return receipt;
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      }
    };
  }
  connect(provider) {
    return new _EngineSigner(this.config, provider);
  }
  async fetch(_ref) {
    let {
      path,
      method,
      body
    } = _ref;
    const res = await fetch(`${this.config.engineUrl}${path}`, {
      method,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.config.accessToken}`,
        "x-backend-wallet-address": this.config.backendWalletAddress
      },
      ...body ? {
        body: JSON.stringify(body)
      } : {}
    });
    if (!res.ok) {
      throw new Error(await res.text());
    }
    return res.json();
  }
};
var EngineWallet = class extends AbstractWallet {
  constructor(config) {
    super();
    this._signer = new EngineSigner(config);
  }
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_lib3();
var PaperWallet = class _PaperWallet extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    var _a;
    super(_PaperWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
    if (options.paperClientId && options.paperClientId === "uninitialized") {
      this.paperClientId = "00000000-0000-0000-0000-000000000000";
      return;
    }
    if (options.advancedOptions && ((_a = options.advancedOptions) == null ? void 0 : _a.recoveryShareManagement) === "USER_MANAGED") {
      if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId) || !options.paperClientId && options.clientId && !this.isClientIdLegacyPaper(options.clientId)) {
        throw new Error('RecoveryShareManagement option "USER_MANAGED" is not supported with thirdweb client ID');
      }
    }
    if (!options.clientId && !options.paperClientId) {
      throw new Error("clientId or paperClientId is required");
    }
    if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId)) {
      throw new Error("paperClientId must be a legacy paper client ID");
    }
    if (options.clientId && this.isClientIdLegacyPaper(options.clientId)) {
      throw new Error("clientId must be a thirdweb client ID");
    }
    this.paperClientId = options.paperClientId ?? options.clientId;
    this.onAuthSuccess = options.onAuthSuccess;
  }
  isClientIdLegacyPaper(clientId) {
    return clientId.indexOf("-") > 0 && clientId.length === 36;
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-KDPPGRF6.js");
      this.connector = new PaperWalletConnector({
        clientId: this.paperClientId,
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: this.onAuthSuccess,
        advancedOptions: {
          recoveryShareManagement: (_b = (_a = this.options) == null ? void 0 : _a.advancedOptions) == null ? void 0 : _b.recoveryShareManagement
        },
        styles: (_c = this.options) == null ? void 0 : _c.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (typeof connectParams.googleLogin === "object") {
      return {
        ...connectParams,
        googleLogin: true
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getPaperSDK() {
    const connector = await this.getConnector();
    return connector.getPaperSDK();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
var import_buffer = __toESM(require_buffer2());
init_lib3();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class _CoinbaseWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Coinbase Wallet";
  }
  /**
   * @internal
   */
  /**
   * @internal
   */
  /**
   *
   * @param options -
   * The `options` object contains the following properties:
   *
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   *
   * ### chains (optional)
   *
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   *
   * ### dappMetadata (optional)
   *
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url` and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { CoinbaseWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new CoinbaseWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp", // optional
   *     logoUrl: "https://thirdweb.com/favicon.ico", // optional
   *   },
   * });
   * ```
   *
   * ### headlessMode (optional)
   * This is only relevant applies when coinbase extension wallet is NOT installed on user's browser.
   *
   * By default `headlessMode` is set to `false` - which means that when user does not have coinbase wallet extension installed, a QR Code scan modal will open when calling the `connect` method to allow the user to connect to their coinbase mobile app by scanning the QR code.
   *
   * If headlessMode is set to `true` and coinbase wallet extension is not installed, the wallet will NOT open a QR Code scan modal - This is useful if you want to create a custom QR Code modal.
   *
   * you can use the `getQrUrl` method to get the QR Code url and create your own QR Code Modal
   *
   * Must be a `boolean`.
   */
  constructor(options) {
    super(_CoinbaseWallet.id, options);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
    this.theme = (options == null ? void 0 : options.theme) || this.dappMetadata.isDarkMode === false ? "light" : "dark";
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-PEWR6PCB.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.theme === "dark",
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  /**
   * Get the QR Code url to render a custom QR Code Modal for connecting to Coinbase Wallet.
   *
   * This method is only relevant when coinbase extension wallet is NOT installed on user's browser and `headlessMode` is set to `true`.
   *
   * @example
   * ```ts
   * const wallet = new CoinbaseWallet({ headlessMode: true });
   *
   * const qrUrl = await wallet.getQrUrl();
   * // render a QR Code Modal with the qrUrl
   *
   * const walletAddress = await wallet.connect(); // this is resolved when user scans the QR Code and wallet is connected
   *
   * console.log('connected to', walletAddress);
   * ```
   *
   * @returns
   */
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
init_lib3();
var EthersWallet = class extends AbstractWallet {
  /**
   * Create instance of `EthersWallet`
   * @param signer - ethers.js signer object
   */
  constructor(signer) {
    super();
    this._signer = signer;
  }
  /**
   * Returns [ethers signer](https://docs.ethers.org/v5/api/signer/) object used by the wallet
   */
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
init_lib3();
var FrameWallet = class _FrameWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Frame Wallet";
  }
  /**
   * Create a `FrameWallet` instance
   * @param options -
   * The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { FrameWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new FrameWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_FrameWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-BLYCGHNB.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/wallets/evm/wallets/imtoken/dist/thirdweb-dev-wallets-evm-wallets-imtoken.browser.esm.js
init_lib3();
var ImTokenWallet = class _ImTokenWallet extends AbstractClientWallet {
  get walletName() {
    return "imToken";
  }
  constructor(options) {
    var _a;
    super(_ImTokenWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isImToken);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ImTokenConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-imtoken.browser.esm-5BFBJ66C.js");
        const imtokenConnector = new ImTokenConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.imtokenConnector = imtokenConnector;
        this.connector = new WagmiAdapter(imtokenConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Trust Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ImTokenWallet, "meta", {
  name: "imToken",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMl80NzgzKSI+CjxtYXNrIGlkPSJtYXNrMF8yMjJfNDc4MyIgc3R5bGU9Im1hc2stdHlwZTpsdW1pbmFuY2UiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjAiIHk9IjAiIHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCI+CjxwYXRoIGQ9Ik03OS44OTQ4IDBIMC4wNTA3ODEyVjgwSDc5Ljg5NDhWMFoiIGZpbGw9IndoaXRlIi8+CjwvbWFzaz4KPGcgbWFzaz0idXJsKCNtYXNrMF8yMjJfNDc4MykiPgo8cGF0aCBkPSJNNjIuMDI3NSAwSDE4LjA1MDlDOC4xNDYzOSAwIDAuMTE3MTg4IDguMDQ0ODggMC4xMTcxODggMTcuOTY4OFY2Mi4wMzEyQzAuMTE3MTg4IDcxLjk1NTEgOC4xNDYzOSA4MCAxOC4wNTA5IDgwSDYyLjAyNzVDNzEuOTMyIDgwIDc5Ljk2MTIgNzEuOTU1MSA3OS45NjEyIDYyLjAzMTJWMTcuOTY4OEM3OS45NjEyIDguMDQ0ODggNzEuOTMyIDAgNjIuMDI3NSAwWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIyMl80NzgzKSIvPgo8cGF0aCBkPSJNNjUuMDk4MSAyNC43MzNDNjYuNzU4NiA0Ny4yNjY3IDUyLjMwMjEgNTcuOTE3MiAzOS4zNDIzIDU5LjA1M0MyNy4yOTM1IDYwLjEwODcgMTUuOTUyIDUyLjY5MDggMTQuOTU3MSA0MS4yOTM2QzE0LjEzNjMgMzEuODc3NiAxOS45NDQ1IDI3Ljg2ODkgMjQuNTA4IDI3LjQ2OTRDMjkuMjAxNSAyNy4wNTcgMzMuMTQ1OCAzMC4zMDAxIDMzLjQ4NzkgMzQuMjI2OUMzMy44MTc1IDM4LjAwMiAzMS40NjY0IDM5LjcyMDUgMjkuODMxMyAzOS44NjM0QzI4LjUzODIgMzkuOTc3IDI2LjkxMTQgMzkuMTkwNSAyNi43NjQ1IDM3LjUwMTZDMjYuNjM4NSAzNi4wNTAzIDI3LjE4ODUgMzUuODUyNiAyNy4wNTQxIDM0LjMxMDlDMjYuODE0OSAzMS41NjYyIDI0LjQyNjEgMzEuMjQ2NiAyMy4xMTgzIDMxLjM2MDFDMjEuNTM1NyAzMS40OTkxIDE4LjY2NDEgMzMuMzQ5OCAxOS4wNjcgMzcuOTZDMTkuNDcyMiA0Mi42MTAxIDIzLjkyMjIgNDYuMjg0NSAyOS43NTU3IDQ1Ljc3MzRDMzYuMDUwOSA0NS4yMjIzIDQwLjQzMzcgNDAuMzExNCA0MC43NjM0IDMzLjQyMzRDNDAuNzYwMyAzMy4wNTg2IDQwLjgzNyAzMi42OTc1IDQwLjk4OCAzMi4zNjU1TDQwLjk5IDMyLjM1NzJDNDEuMDU3OCAzMi4yMTI4IDQxLjEzNzIgMzIuMDc0MiA0MS4yMjcyIDMxLjk0MjhDNDEuMzYxNiAzMS43NDA5IDQxLjUzMzggMzEuNTE4IDQxLjc1NjIgMzEuMjczOUM0MS43NTgzIDMxLjI2NzYgNDEuNzU4MyAzMS4yNjc2IDQxLjc2MjYgMzEuMjY3NkM0MS45MjQxIDMxLjA4NDcgNDIuMTE5NCAzMC44ODcgNDIuMzM5NyAzMC42NzQ1QzQ1LjA4OTcgMjguMDc1IDU0Ljk5MzEgMjEuOTQ0MiA2NC4zNTkyIDIzLjg4NTVDNjQuNTU3MyAyMy45MjggNjQuNzM2MSAyNC4wMzM0IDY0Ljg2OTMgMjQuMTg2MkM2NS4wMDI1IDI0LjMzOTEgNjUuMDgyNiAyNC41MzA4IDY1LjA5ODEgMjQuNzMzWiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzQ3ODMiIHgxPSI3My41MDA5IiB5MT0iNS4zMTI1IiB4Mj0iMi44NzI0MSIgeTI9Ijc3LjY3NDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzExQzREMSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMDYyQUQiLz4KPC9saW5lYXJHcmFkaWVudD4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yMjJfNDc4MyI+CjxyZWN0IHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4=",
  urls: {
    ios: "https://itunes.apple.com/us/app/imtoken2/id1384798940",
    android: "https://play.google.com/store/apps/details?id=im.token.app"
  }
});
_defineProperty(ImTokenWallet, "id", walletIds.imtoken);

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_lib3();
var InjectedWallet = class _InjectedWallet extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(_InjectedWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-KU4NCD7Y.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
init_lib3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var LocalWallet = class _LocalWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Local Wallet";
  }
  /**
   * Initialize the `LocalWallet` with the given `options`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId or secretKey (recommended)
   * Provide `clientId` or `secretKey` to use the thirdweb RPCs for given `chains`
   *
   * If you are using the `LocalWallet` in a in frontend - provide a `clientId`, If you are using the `LocalWallet` in backend - you can provide a `secretKey`.
   *
   * You can create a `clientId` / `secretKey` from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chain (optional)
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   * Defaults to `Ethereum`.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### storage (optional)
   * This is the default storage for storing the private key, mnemonic or encrypted JSON. This can be implemented in any way you want, as long as it conforms to the `AsyncStorage` interface:
   *
   * If omitted, defaults to browser local storage.
   *
   *
   * ```javascript
   * import { LocalWallet } from "@thirdweb-dev/wallets";
   *
   * const customStorage = {
   *   getItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   removeItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   setItem: (key, value) => {
   *     // Implement your own storage logic here
   *   },
   * };
   *
   * const walletWithOptions = new LocalWallet({
   *   storage: customStorage,
   * });
   * ```
   *
   */
  constructor(options) {
    super(_LocalWallet.id, options);
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options || {};
    this._storage = (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-ZIB7UPTH.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c7) => updateChainRPCs(c7, this.options.clientId));
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        ethersWallet: this.ethersWallet,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
  /**
   * Load the saved wallet data from storage, if it exists, or generate a new one and save it.
   *
   * @example
   * ```js
   * wallet.loadOrCreate({
   *   strategy: "encryptedJson",
   *   password: password,
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletLoadOrCreateOptions`. It takes a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Load the wallet from encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to decrypt the encrypted JSON
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Load the wallet from a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the private key. This is only required if the saved private key is encrypted.
   */
  async loadOrCreate(options) {
    if (await this.getSavedData(options.storage)) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  /**
   * Creates a new random wallet and returns the wallet address.
   *
   * @example
   * ```ts
   * const address = await wallet.generate();
   * ```
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const random = utils_exports.randomBytes(32);
    this.ethersWallet = new Wallet(random);
    return this.ethersWallet.address;
  }
  /**
   * Create local wallet by importing a private key, mnemonic or encrypted JSON.
   * @example
   * ```javascript
   * const address = await localWallet.import({
   *   privateKey: "...",
   *   encryption: false,
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletImportOptions` which can have either `privateKey`, `mnemonic` or `encryptedJson` as a property.
   * They all can be encrypted or un-encrypted. If encrypted, the `encryption` property must be provided with `password` property to decrypt the data.
   *
   * ### privateKey
   * The Private Key of the wallet.
   *
   * ### mnemonic
   * The mnemonic (seed phrase) of the wallet.
   *
   * ### encryptedJson
   * The encrypted JSON of the wallet.
   *
   * ### encryption
   * This is only required if the given `privateKey`, `mnemonic` or `encryptedJson` is encrypted.
   * The `encryption` object of type `DecryptOptions` can be provided to decrypt the data. It is an object with the following properties:
   *
   * #### password
   * The password to decrypt the data.
   *
   * #### decrypt
   * A custom decrypt function that takes the encrypted data and password as arguments and returns the decrypted data.
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  /**
   * Initialize the wallet from saved data on storage
   *
   * ```js
   * await wallet.load({
   *   strategy: "encryptedJson",
   *   password: "your-password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletLoadOptions` which contains a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Initialize the wallet from encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to decrypt the encrypted JSON
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Initialize the wallet from a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the private key. This is only required if the private key is encrypted.
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "mnemonic"
   * Initialize the wallet from a mnemonic (seed phrase). The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the mnemonic. This is only required if the mnemonic is encrypted.
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  /**
   * Save the wallet data to storage
   *
   * @example
   * ```javascript
   * wallet.save({
   *   strategy: "encryptedJson",
   *   password: "password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletSaveOptions`. It takes a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Save the wallet data as encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to encrypt the wallet data
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Save the wallet data as a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `EncryptOptions` to encrypt the private key. This is only required if you want to encrypt the private key.
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   * ### strategy "mnemonic"
   * Save the wallet data as a mnemonic (seed phrase). The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - optional encryption object of type `EncryptOptions` to encrypt the mnemonic. This is only required if you want to encrypt the mnemonic.
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   */
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await this._saveData({
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await this._saveData({
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await this._saveData({
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  /**
   * Check if the wallet data is saved in storage.
   *
   * @returns `true` if initialized wallet's data is saved in storage
   */
  async isSaved() {
    try {
      const data = await this.getSavedData();
      const address = await this.getAddress();
      if ((data == null ? void 0 : data.address) === address) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  /**
   * Delete the saved wallet from storage. This action is irreversible, use with caution.
   *
   * @example
   * ```ts
   * await wallet.deleteSaved();
   * ```
   */
  async deleteSaved() {
    await this._storage.removeItem(STORAGE_KEY_WALLET_DATA);
  }
  /**
   * Encrypts the wallet with a password in various formats and return it.
   *
   * @example
   * ```javascript
   * const data = await wallet.export({
   *   strategy: "encryptedJson",
   *   password: "password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletExportOptions`. It takes a `strategy` and other properties depending on the strategy.
   *
   * ### strategy - "encryptedJson"
   * Export wallet in encryptedJson format. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to encrypt the wallet data
   *
   * ### strategy - "privateKey"
   * Encrypt the private key of the wallet. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - encryption object of type `EncryptOptions` to encrypt the private key. It takes a `password` property to encrypt the private key and an optional `encrypt` function to encrypt the private key. If `encrypt` function is not provided, it uses the default encryption.
   *
   * ### strategy - "mnemonic"
   * Encrypt the mnemonic (seed phrase) of the wallet. The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - encryption object of type `EncryptOptions` to encrypt the mnemonic. It takes a `password` property to encrypt the mnemonic and an optional `encrypt` function to encrypt the mnemonic. If `encrypt` function is not provided, it uses the default encryption.
   *
   * @returns Promise that resolves to a `string` that contains encrypted wallet data
   */
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  /**
   * Get the saved wallet data from storage
   * @param storage - storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * @example
   * ```javascript
   * const someStorage = {
   *   getItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   removeItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   setItem: (key, value) => {
   *     // Implement your own storage logic here
   *   },
   * }
   *
   * wallet.getSaved(someStorage);
   * ```
   *
   * @returns `Promise` which resolves to a `WalletData` object containing the wallet data. It returns `null` if no wallet data is found in storage.
   * ```ts
   * {
   *     address: string;
   *     strategy: "mnemonic" | "privateKey" | "encryptedJson";
   *     data: string;
   *     isEncrypted: boolean;
   * }
   * ```
   */
  async getSavedData(storage) {
    const _storage = storage || this._storage;
    try {
      const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e) {
      return null;
    }
  }
  /**
   * store the wallet data to storage
   */
  async _saveData(data, storage) {
    const _storage = storage || this._storage;
    await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));
  }
  /**
   * Disconnect the wallet
   */
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function noop(msg) {
  return msg;
}
function getDecryptor(encryption) {
  return encryption ? (msg) => (
    // we're using aesDecryptCompat here because we want to support legacy crypto-js ciphertext for the moment
    (encryption.decrypt || aesDecryptCompat)(msg, encryption.password)
  ) : noop;
}
function getEncryptor(encryption) {
  return encryption ? (msg) => (encryption.encrypt || aesEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.browser.esm.js
init_lib3();
var SignerWallet = class extends AbstractClientWallet {
  constructor(options) {
    super("signerWallet", options);
    if (options.clientId && options.chain) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options;
    this.signer = options.signer;
    this._storage = (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SignerConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-signer.browser.esm-BGFRBBCK.js");
      if (!this.signer) {
        this.signer = this.options.signer;
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c7) => updateChainRPCs(c7, this.options.clientId));
      this.connector = new SignerConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        signer: this.signer,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
init_lib3();
var MagicLink = class _MagicLink extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Magic Link";
  }
  /**
   * @internal
   */
  /**
   * Create an instance of the `MagicLink` wallet
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### apiKey (required)
   * Your Magic Link apiKey. You can get an API key by signing up for an account on [Magic Link's website](https://magic.link/).
   *
   * Must be a `string`.
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### type (optional)
   * Whether to use [Magic Auth](https://magic.link/docs/auth/overview) or [Magic Connect](https://magic.link/docs/connect/overview) to connect to the wallet.
   *
   * Default is `"auth"`.
   *
   * ```ts
   * type: "auth" | "connect";
   * ```
   *
   * ### magicSdkConfiguration (optional)
   * Configuration for [Magic Auth](https://magic.link/docs/auth/overview) SDK.
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * ```ts
   * {
   *   locale?: string;
   *   endpoint?: string;
   *   testMode?: boolean;
   * }
   * ```
   *
   * * locale (optional) - Customize the language of Magic's modal, email and confirmation screen. See [Localization](https://magic.link/docs/auth/more/customization/localization) for more.
   *
   * * endpoint (optional) - A URL pointing to the Magic iframe application.
   *
   * * testMode (optional) - Enable [testMode](https://magic.link/docs/auth/introduction/test-mode) to assert the desired behavior through the email address so that you don't have to go through the auth flow.
   *
   *
   * ### smsLogin
   * Specify whether you want to allow users to log in with their phone number or not. It is `true` by default
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * Must be a `boolean`.
   *
   * ### emailLogin (optional)
   * Specify whether you want to allow users to log in with their email or not. It is `true` by default
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * Must be a `boolean`.
   *
   *
   * ### oauthOptions (optional)
   * Specify which oauth providers you support in `providers` array. This is only relevant if you are using `type: 'auth'`.
   *
   * Specify which URI to redirect to after the oauth flow is complete in `redirectURI` option. If no `redirectURI` is specified, the user will be redirected to the current page.
   *
   * You must pass full URL and not just a relative path. For example, `"https://example.com/foo"` is valid but `"/foo"` is not.
   * You can use `new URL("/foo", window.location.origin).href` to get the full URL from a relative path based on the current origin.
   *
   * You also need to enable the oauth providers for your apiKey from [Magic dashboard](https://dashboard.magic.link/).
   *
   * ```ts
   * type OauthOptions = {
   *   redirectURI?: string;
   *   providers: OauthProvider[];
   * };
   *
   * type OauthProvider =
   *   | "google"
   *   | "facebook"
   *   | "apple"
   *   | "github"
   *   | "bitbucket"
   *   | "gitlab"
   *   | "linkedin"
   *   | "twitter"
   *   | "discord"
   *   | "twitch"
   *   | "microsoft";
   * ```
   *
   * ```ts
   * const wallet = new MagicLink({
   *   apiKey: "YOUR_API_KEY",
   *   type: "auth",
   *   // specify which Oauth providers to enable
   *   oauthOptions: {
   *     redirectURI: new URL("/foo", window.location.origin).href,
   *     providers: ["google", "facebook", "github", "bitbucket"],
   *   },
   * });
   * ```
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   */
  constructor(options) {
    super(_MagicLink.id, options);
    this.options = options;
  }
  /**
   * @internal
   */
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-4EMRARUX.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  /**
   * Get Magic Auth SDK instance. Learn more about [Magic Auth SDK](https://magic.link/docs/auth/overview)
   *
   * you use all methods available in the Magic Auth SDK from the SDK instance. Refer to [Magic Auth API](https://magic.link/docs/auth/api-reference/client-side-sdks/web) for more details.
   *
   * ```javascript
   * const magicSDK = await wallet.getMagic();
   * ```
   */
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  /**
   * Auto connect wallet if the user is already logged in.
   * @returns
   */
  async autoConnect(options) {
    var _a;
    await this.initializeConnector();
    await ((_a = this.magicConnector) == null ? void 0 : _a.initializeMagicSDK(options));
    const magic = this.getMagic();
    {
      const url = new URL(window.location.href);
      const isMagicRedirect = url.searchParams.get("magic_credential");
      if (isMagicRedirect) {
        try {
          this.oAuthRedirectResult = await magic.oauth.getRedirectResult();
        } catch {
        }
      }
    }
    const isLoggedIn = await magic.user.isLoggedIn();
    if (isLoggedIn) {
      return super.autoConnect(options);
    }
    throw new Error("Magic user is not logged in");
  }
  /**
   * Disconnect wallet
   */
  async disconnect() {
    this.oAuthRedirectResult = void 0;
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  /**
   * Connect Wallet using Magic Auth or Magic Connect
   *
   * ### Magic Auth
   * There are three ways to call the `connect` function - `email` or `phoneNumber` or `oauthProvider`
   *
   * #### email
   * This opens the Magic Link's Modal and prompts the user to click on the link sent to their email.
   *
   * ```ts
   * await wallet.connect({
   *   email: "user@example.com",
   * });
   * ```
   *
   * #### phoneNumber
   * This opens the Magic Link's Modal and prompts the user to enter the OTP sent to their phone via SMS.
   *
   * ```ts
   * await wallet.connect({
   *   phoneNumber: "+123456789",
   * });
   * ```
   *
   * #### oauthProvider
   * This redirects the user to given provider's sign-in page and once the user is authenticated, it redirects the user back to the `redirectURI` provided in `MagicLink` constructor.
   *
   * ```ts
   * await magic.connect({
   *   oauthProvider: "google",
   * });
   * ```
   *
   * #### Additional Configuration
   *
   * ```typescript
   * wallet.connect({
   *   chainId: 5,
   * });
   * ```
   *
   * If `chainId` is provided, the wallet will be connected to the network with the given chainId, else it will be connected to the Ethereum Mainnet.
   *
   * ### Magic Connect
   * You can call the `connect` function without any arguments. Calling `connect` opens the Magic Link's Modal and prompts the user to login via Google or email.
   *
   * ```ts
   * await wallet.connect();
   * ```
   *
   * #### Additional Configuration
   *
   * ```typescript
   * wallet.connect({
   *   chainId: 5,
   * });
   * ```
   *
   * If `chainId` is provided, the wallet will be connected to the network with the given chainId, else it will be connected to the Ethereum Mainnet.
   *
   * @param options - The `options` object can include the following properties:
   * ### Magic Auth
   * If you are using `type: 'auth'`, you can pass any one of the following properties
   * - `email` - The email address of the user
   * - `phoneNumber` - The phone number of the user
   * - `oauthProvider` - The oauth provider to use for login
   *
   * ### Magic Connect
   * If you are using `type: 'connect'`, you don't need to pass any arguments to `connect` function.
   *
   * @returns
   */
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/wallets/evm/wallets/xdefi/dist/thirdweb-dev-wallets-evm-wallets-xdefi.browser.esm.js
init_lib3();
var XDEFIWallet = class _XDEFIWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "XDEFI";
  }
  /**
   * Create instance of `XDEFIWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { XDEFIWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new XDEFIWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_XDEFIWallet.id, options);
    this.isInjected = !!getInjectedXDEFIProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        XDEFIConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-xdefi.browser.esm-SM4IAF7N.js");
      const connector = new XDEFIConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.connector = new WagmiAdapter(connector);
    }
    return this.connector;
  }
};
_defineProperty(XDEFIWallet, "id", walletIds.xdefi);

// node_modules/@thirdweb-dev/wallets/evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.browser.esm.js
init_lib3();
var PhantomWallet = class _PhantomWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Phantom";
  }
  /**
   * Create a `PhantomWallet` instance
   * @param options -
   * The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { PhantomWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new PhantomWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_PhantomWallet.id, options);
    this.isInjected = !!getInjectedPhantomProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PhantomConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-phantom.browser.esm-4O6RU2NK.js");
      const phantomConnector = new PhantomConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.phantomConnector = phantomConnector;
      this.connector = new WagmiAdapter(phantomConnector);
    }
    return this.connector;
  }
};
_defineProperty(PhantomWallet, "meta", {
  name: "Phantom",
  iconURL: "ipfs://bafybeibkpca5nwxpsjrtuxmz2ckb5lyc2sl2abg5f7dnvxku637vvffjti",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
    // not specifiying theme because they can't be used to connect
    // android: "https://play.google.com/store/apps/details?id=app.phantom",
    // ios: "https://apps.apple.com/us/app/phantom-crypto-wallet/id1598432977",
  }
});
_defineProperty(PhantomWallet, "id", walletIds.phantom);

// node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
init_lib3();
var PrivateKeyWallet = class extends AbstractWallet {
  /**
   * Create instance of `PrivateKeyWallet`
   *
   * @param privateKey - The private key to use for signing transactions.
   *
   * @param chain - The chain or rpc url to connect to when querying the blockchain directly through this wallet.
   *
   * @param secretKey -
   * Provide `secretKey` to use the thirdweb RPCs for given `chain`
   *
   * You can create a secret key from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   */
  constructor(privateKey, chain, secretKey) {
    super();
    this._signer = new ethers_exports.Wallet(privateKey, chain ? getChainProvider(chain, {
      secretKey
    }) : void 0);
  }
  /**
   * Get the [ethers.js signer](https://docs.ethers.io/v5/api/signer/) object used by the wallet
   */
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.browser.esm.js
init_lib3();
var RainbowWallet = class _RainbowWallet extends AbstractClientWallet {
  get walletName() {
    return "Rainbow Wallet";
  }
  constructor(options) {
    super(_RainbowWallet.id, options);
    this.isInjected = !!getInjectedRainbowProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RainbowConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rainbow.browser.esm-UME6SZTH.js");
        const rainbowConnector = new RainbowConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.rainbowConnector = rainbowConnector;
        this.connector = new WagmiAdapter(rainbowConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * rainbow.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RainbowWallet, "meta", {
  name: "Rainbow Wallet",
  iconURL: "ipfs://QmSZn47p4DVVBfzvg9BAX2EqwnPxkT1YAE7rUnrtd9CybQ/rainbow-logo.png",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/rainbow/opfgelmcmbiajamepnmloijbpoleiama",
    android: "https://rnbwapp.com/e/Va41HWS6Oxb",
    ios: "https://rnbwapp.com/e/OeMdmkJ6Oxb"
  }
});
_defineProperty(RainbowWallet, "id", walletIds.rainbow);

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_lib3();
var SafeWallet = class _SafeWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Safe Wallet";
  }
  /**
   * Create a `SafeWallet` instance.
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   *
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   *
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { SafeWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new SafeWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   }
   * });
   * ```
   *
   */
  constructor(options) {
    super(_SafeWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-3BGIUXXX.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  /**
   * Get the personal wallet that is connected to the Safe wallet.
   * @returns
   */
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  /**
   * Auto connect the wallet if it was previously connected.
   */
  autoConnect(params) {
    return this.connect(params);
  }
  /**
   * Connect Safe wallet
   * @param connectOptions -
   * The `connectOptions` object includes the following properties:
   *
   * @example
   * ```javascript
   * import { CoinbaseWallet, SafeWallet } from "@thirdweb-dev/wallets";
   * import { Ethereum } from "@thirdweb-dev/chains";
   *
   * // First, connect the personal wallet
   * const personalWallet = new CoinbaseWallet();
   * await personalWallet.connect();
   *
   * // Then, connect the Safe wallet
   * const wallet = new SafeWallet();
   * await wallet.connect({
   *   personalWallet: personalWallet, // Wallet that can sign transactions on the Safe
   *   chain: Ethereum, // Chain that the Safe is on
   *   safeAddress: "{{contract_address}}", // Smart contract address of the Safe
   * });
   * ```
   *
   * ### personalWallet
   *
   * The instance of a personal wallet that can sign transactions on the Safe.
   *
   * Must be of type `EVMWallet` such as [`CoinbaseWallet`](/wallet/coinbase-wallet) or [`MetamaskWallet`](/wallet/metamask).
   *
   * ### chain
   *
   * The chain that the Safe smart contract is deployed to.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * ### safeAddress
   *
   * Smart contract address of the Safe wallet.
   *
   * Must be a `string`.
   *
   * @returns A Promise that resolves to the Safe address.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/wallets/evm/wallets/smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-smart-wallet.browser.esm.js
init_lib3();
var import_contracts = __toESM(require_dist());
var SmartWallet = class _SmartWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Smart Wallet";
  }
  /**
   *
   * @param options - The `options` object includes the following properties:
   * ### Required Properties
   *
   * #### chain
   * The chain that the Smart Wallet contract is deployed to.
   *
   * Either a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package, a chain name, or an RPC URL.
   *
   *
   * #### factoryAddress
   * The address of the Smart Wallet Factory contract.
   *
   * Must be a `string`.
   *
   *
   * #### gasless
   * Whether to turn on or off gasless transactions.
   *
   * - If set to `true`, all gas fees will be paid by a paymaster.
   * - If set to `false`, all gas fees will be paid by the Smart Wallet itself (needs to be funded).
   *
   * Must be a `boolean`.
   *
   *
   * ### Optional properties
   *
   * #### clientId or secretKey (recommended)
   * Your API key can be obtained from the [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * If you're using your own bundler and paymaster, you can set this to an empty string.
   *
   * You can use either the `clientId` or the `secretKey` depending on whether your application is client or server side.
   *
   * Must be a `string`.
   *
   * #### factoryInfo
   * Customize how the Smart Wallet Factory contract is interacted with. If not provided, the default functions will be used.
   *
   * Must be a `object`. The object can contain the following properties:
   *
   * - `createAccount` - a function that returns the transaction object to create a new Smart Wallet.
   * - `getAccountAddress` - a function that returns the address of the Smart Wallet contract given the owner address.
   * - `abi` - optional ABI. If not provided, the ABI will be auto-resolved.
   *
   * ```javascript
   *  const config: SmartWalletConfig = {
   *       chain,
   *       gasless,
   *       factoryAddress,
   *       clientId,
   *       factoryInfo: {
   *         createAccount: async (factory, owner) => {
   *           return factory.prepare("customCreateAccount", [
   *             owner,
   *             getExtraData(),
   *           ]);
   *         },
   *         getAccountAddress: async (factory, owner) => {
   *           return factory.call("getAccountAddress", [owner]);
   *         },
   *         abi: [...]
   *       },
   *     };
   * ```
   *
   *
   * #### accountInfo
   * Customize how the Smart Wallet Account contract is interacted with. If not provided, the default functions will be used.
   *
   * Must be a `object`. The object can contain the following properties:
   *
   * - `execute` - a function that returns the transaction object to execute an arbitrary transaction.
   * - `getNonce` - a function that returns the current nonce of the account.
   * - `abi` - optional ABI. If not provided, the ABI will be auto-resolved.
   *
   * ```javascript
   *  const config: SmartWalletConfig = {
   *       chain,
   *       gasless,
   *       factoryAddress,
   *       clientId,
   *       accountInfo: {
   *         execute: async (account, target, value, data) => {
   *           return account.prepare("customExecute", [
   *             target, value, data
   *           ]);
   *         },
   *         getNonce: async (account) => {
   *           return account.call("getNonce");
   *         },
   *         abi: [...]
   *       },
   *     };
   * ```
   *
   * #### bundlerUrl
   * Your own bundler URL to send user operations to. Uses thirdweb's bundler by default.
   *
   * Must be a `string`.
   *
   * #### paymasterUrl
   * Your own paymaster URL to send user operations to for gasless transactions. Uses thirdweb's paymaster by default.
   *
   * Must be a `string`.
   *
   * #### paymasterAPI
   * Fully customize how the paymaster data is computed.
   *
   * Must be a `PaymasterAPI` class.
   *
   * ```javascript
   * class MyPaymaster extends PaymasterAPI {
   *   async getPaymasterAndData(
   *     userOp: Partial<UserOperationStruct>,
   *   ): Promise<string> {
   *     // your implementation, must return the signed paymaster data
   *   }
   * }
   *
   * const config: SmartWalletConfig = {
   *   chain,
   *   gasless,
   *   factoryAddress,
   *   clientId,
   *   // highlight-start
   *   paymasterAPI: new MyPaymaster(),
   *   // highlight-end
   * };
   * ```
   *
   *
   * #### entryPointAddress
   * The entrypoint contract address. Uses v0.6 by default.
   *
   * Must be a `string`.
   *
   * #### deployOnSign
   * Whether to deploy the smart wallet when the user signs a message. Defaults to true.
   *
   * Must be a `boolean`.
   *
   * #### chains
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to thirdweb's [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * #### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url` and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { SmartWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new SmartWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp", // optional
   *     logoUrl: "https://thirdweb.com/favicon.ico", // optional
   *   },
   * });
   * ```
   *
   */
  constructor(options) {
    if (options.clientId && typeof options.chain === "object") {
      try {
        options.chain = {
          ...options.chain,
          rpc: getValidChainRPCs(options.chain, options.clientId)
        };
      } catch {
      }
    }
    super(_SmartWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      if (this.options && await isZkSyncChain(this.options.chain, this.options.clientId, this.options.secretKey)) {
        const {
          ZkSyncConnector
        } = await import("./zk-connector-fada2157.browser.esm-RIIKEXBO.js");
        this.connector = new ZkSyncConnector(this.options);
      } else {
        const {
          SmartWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-IWE3ZGVY.js");
        this.connector = new SmartWalletConnector(this.options);
      }
    }
    return this.connector;
  }
  /**
   * Get the personal wallet that is connected to the Smart Wallet.
   * @example
   * ```ts
   * const personalWallet = wallet.getPersonalWallet();
   * ```
   */
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  /**
   * Check whether the connected signer can execute a given transaction using the smart wallet.
   * @param transaction - The transaction to execute using the smart wallet.
   * @returns `Promise<true>` if connected signer can execute the transaction using the smart wallet.
   */
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }
  /**
   * Send a single transaction without waiting for confirmations
   * @param transaction - the transaction to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async send(transaction, options) {
    const connector = await this.getConnector();
    return connector.send(transaction, options);
  }
  /**
   * Execute a single transaction and wait for confirmations
   *
   * @example
   * ```javascript
   * const transaction = prepareTransaction();
   * await wallet.execute(transaction);
   * ```
   *
   * @param transaction -
   * The transaction to execute. Must be of type `Transaction` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](https://portal.thirdweb.com/typescript/v4/interact#prepare) from the thirdweb SDK.
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async execute(transaction, options) {
    const connector = await this.getConnector();
    return connector.execute(transaction, options);
  }
  /**
   * Send a multiple transaction in a batch without waiting for confirmations
   * @param transactions -
   * An array of transactions to send. Must be of type `Transaction[]` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](typescript/sdk.smartcontract.prepare) from the thirdweb SDK.
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async sendBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.sendBatch(transactions, options);
  }
  /**
   * Execute multiple transactions in a single batch and wait for confirmations, only requiring one signature from the personal wallet.
   *
   * ```javascript
   * // Then you can execute multiple transactions at once
   * const transactions = [
   *   prepareTransaction1(),
   *   prepareTransaction2(),
   *   prepareTransaction3(),
   * ];
   * await wallet.executeBatch(transactions);
   * ```
   *
   * @param transactions -
   * An array of transactions to execute. Must be of type `Transaction[]` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](typescript/sdk.smartcontract.prepare) from the thirdweb SDK.
   *
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async executeBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions, options);
  }
  /**
   * Send a single raw transaction without waiting for confirmations
   * @param transaction - the transaction to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async sendRaw(transaction, options) {
    const connector = await this.getConnector();
    return connector.sendRaw(transaction, options);
  }
  /**
   * Execute a single raw transaction and wait for confirmations
   * @param transaction - the transaction to execute
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async executeRaw(transaction, options) {
    const connector = await this.getConnector();
    return connector.executeRaw(transaction, options);
  }
  /**
   * Estimate the gas cost of a single transaction
   * @param transaction - the transaction to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimate(transaction, options) {
    const connector = await this.getConnector();
    return connector.estimate(transaction, options);
  }
  /**
   * Estimate the gas cost of a batch of transactions
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateBatch(transactions, options);
  }
  /**
   * Estimate the gas cost of a single raw transaction
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateRaw(transactions, options);
  }
  /**
   * Estimate the gas cost of a batch of raw transactions
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateBatchRaw(transactions, options);
  }
  /**
   * Send multiple raw transaction in a batch without waiting for confirmations
   * @param transactions - the transactions to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async sendBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.sendBatchRaw(transactions, options);
  }
  /**
   * Execute multiple raw transactions in a single batch and wait for confirmations
   * @param transactions - the transactions to execute
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async executeBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.executeBatchRaw(transactions, options);
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will throw an error.
   *
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   *
   * @example
   * ```ts
   * const tx = await wallet.deploy();
   * ```
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async deploy(options) {
    const connector = await this.getConnector();
    return connector.deploy(options);
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will do nothing.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   *
   * @example
   * ```ts
   * await wallet.deployIfNeeded();
   * ```
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async deployIfNeeded(options) {
    const connector = await this.getConnector();
    return connector.deployIfNeeded(options);
  }
  /**
   * Check if the smart wallet contract is deployed
   * @example
   * ```ts
   * const isDeployed = await wallet.isDeployed();
   * ```
   *
   * @returns `true` if the smart wallet contract is deployed
   */
  async isDeployed() {
    const connector = await this.getConnector();
    if (connector.chainId && await isZkSyncChain(connector.chainId)) {
      return true;
    }
    return connector.isDeployed();
  }
  /**
   * Create and add a session key to the Smart Wallet with specific permissions.
   * @example
   * ```javascript
   * // Then you can add session keys with permissions
   * await wallet.createSessionKey(
   *   "0x...", // the session key address
   *   {
   *       approvedCallTargets: ["0x..."], // the addresses of contracts that the session key can call
   *       nativeTokenLimitPerTransaction: 0.1, // the maximum amount of native token (in ETH) that the session key can spend per transaction
   *       startDate: new Date(), // the date when the session key becomes active
   *       expirationDate = new Date(Date.now() + 24 * 60 * 60 * 1000); // the date when the session key expires
   *   }
   * );
   * ```
   *
   * @param keyAddress - The address of the session key to add to the Smart Wallet.
   *
   * @param permissions -
   * The specific permissions to give to the session key.
   * Must be of type `SignerPermissionsInput` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * ```typescript
   * {
   *   startDate: Date;
   *   expirationDate: Date;
   *   nativeTokenLimitPerTransaction: number;
   *   approvedCallTargets: string[];
   * }
   * ```
   */
  async createSessionKey(keyAddress, permissions) {
    const connector = await this.getConnector();
    return connector.grantPermissions(keyAddress, permissions);
  }
  /**
   * Revoke a session key from the Smart Wallet.
   * @example
   * ```javascript
   * await wallet.revokeSessionKey(
   *   "0x...", // the session key address
   * );
   * ```
   *
   * @param keyAddress - The address of the session key to revoke.
   */
  async revokeSessionKey(keyAddress) {
    const connector = await this.getConnector();
    return connector.revokePermissions(keyAddress);
  }
  /**
   * Add another admin to the smart wallet.
   * @param adminAddress - The address of the admin to add.
   */
  async addAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.addAdmin(adminAddress);
  }
  /**
   * Remove an admin from the smart wallet.
   * @param adminAddress - The address of the admin to remove.
   */
  async removeAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.removeAdmin(adminAddress);
  }
  /**
   * Get all the admins and session keys active on the smart wallet.
   */
  async getAllActiveSigners() {
    const connector = await this.getConnector();
    return connector.getAllActiveSigners();
  }
  /**
   * Get the underlying account contract of the smart wallet.
   * @returns The account contract of the smart wallet.
   */
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }
  /**
   * Get the underlying account factory contract of the smart wallet.
   * @returns The account factory contract.
   */
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  async verifySignature(message, signature, address, chainId) {
    var _a, _b;
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        return await checkContractWalletSignature(message, signature, address, chainId || 1, (_a = this.options) == null ? void 0 : _a.clientId, (_b = this.options) == null ? void 0 : _b.secretKey);
      } catch {
      }
    }
    return false;
  }
  autoConnect(params) {
    return this.connect(params);
  }
  /**
   * Connect the SmartWallet with given personalWallet
   * @param connectOptions -
   * The `connectOptions` object includes the following properties:
   *
   * #### personalWallet
   * The instance of a personal wallet that can sign transactions on the Smart Wallet.
   * Must be of type `EVMWallet` instance such as `CoinbaseWallet` or `MetamaskWallet`.
   *
   * @returns A Promise that resolves to the address of the Smart Wallet.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.browser.esm.js
init_lib3();
var TrustWallet = class _TrustWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Trust Wallet";
  }
  /**
   * Create instance of `TrustWallet`
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    var _a;
    super(_TrustWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isTrust);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          TrustConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-trust.browser.esm-XQ5QQO5B.js");
        const trustConnector = new TrustConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.trustConnector = trustConnector;
        this.connector = new WagmiAdapter(trustConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Trust Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(TrustWallet, "meta", {
  name: "Trust Wallet",
  iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
  }
});
_defineProperty(TrustWallet, "id", walletIds.trust);

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_lib3();
var WalletConnect = class _WalletConnect extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  /**
   *
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### projectId (recommended)
   * Your project's unique identifier. It can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * It enables the following functionalities within WalletConnect's web3modal:
   *
   * - wallet and chain logos
   * - optional WalletConnect RPC
   * - support for all wallets from our Explorer and WalletConnect v2 support
   *
   * Defaults to thirdweb's common project id.
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { WalletConnect } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new WalletConnect({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrcode (optional)
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || _WalletConnect.id, options);
    _defineProperty(this, "_maybeThrowError", (error) => {
      if (error) {
        throw error;
      }
    });
    _defineProperty(this, "_onConnect", (data) => {
      this._provider = data.provider;
      if (!this._provider) {
        throw new Error("WalletConnect provider not found after connecting.");
      }
    });
    _defineProperty(this, "_onDisconnect", () => {
      this._removeListeners();
    });
    _defineProperty(this, "_onChange", async (payload) => {
      if (payload.chain) ;
      else if (payload.account) ;
    });
    _defineProperty(this, "_onMessage", (payload) => {
      switch (payload.type) {
        case "display_uri":
          this.emit("display_uri", payload.data);
          break;
      }
    });
    _defineProperty(this, "_onSessionRequestSent", () => {
      this.emit("wc_session_request_sent");
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
      this._walletConnectConnector = new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a = this.options) == null ? void 0 : _a.qrModalOptions
        }
      });
      this.connector = new WagmiAdapter(this._walletConnectConnector);
      this._provider = await this._walletConnectConnector.getProvider();
      this._setupListeners();
    }
    return this.connector;
  }
  _setupListeners() {
    var _a;
    if (!this._walletConnectConnector) {
      return;
    }
    this._removeListeners();
    this._walletConnectConnector.on("connect", this._onConnect);
    this._walletConnectConnector.on("disconnect", this._onDisconnect);
    this._walletConnectConnector.on("change", this._onChange);
    this._walletConnectConnector.on("message", this._onMessage);
    (_a = this._provider) == null ? void 0 : _a.signer.client.on("session_request_sent", this._onSessionRequestSent);
  }
  _removeListeners() {
    var _a;
    if (!this._walletConnectConnector) {
      return;
    }
    this._walletConnectConnector.removeListener("connect", this._onConnect);
    this._walletConnectConnector.removeListener("disconnect", this._onDisconnect);
    this._walletConnectConnector.removeListener("change", this._onChange);
    this._walletConnectConnector.removeListener("message", this._onMessage);
    (_a = this._provider) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", this._onSessionRequestSent);
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. User can scan this QR code from the Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this._walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    wcConnector.showWalletConnectModal = false;
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  /**
   * @internal
   */
  async connectWithModal(options) {
    await this.getConnector();
    const wcConnector = this._walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    wcConnector.showWalletConnectModal = true;
    await wcConnector.initProvider();
    await this.connect({
      chainId: options == null ? void 0 : options.chainId
    });
  }
};
_defineProperty(WalletConnect, "id", walletIds.walletConnect);
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_lib3();
var WalletConnectV1 = WalletConnect;

// node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
init_lib3();
var ZerionWallet = class _ZerionWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Zerion Wallet";
  }
  /**
   * Create an instance of `ZerionWallet`.
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   *
   * ### projectId (recommended)
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### qrcode
   * Whether to open the default Wallet Connect QR code Modal for connecting to Zerion Wallet on mobile
   * (if Zerion is not injected when calling `connect()`).
   *
   * Must be a `boolean`. Defaults to `false`.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   * ```javascript
   * import { ZerionWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new ZerionWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   */
  constructor(options) {
    var _a;
    super(_ZerionWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-PAMTM4PZ.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-4SQXADCD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Zerion Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-token-bound-smart-wallet.browser.esm.js
init_lib3();
var import_contracts2 = __toESM(require_dist());
var TokenBoundSmartWallet = class extends SmartWallet {
  get walletName() {
    return "Token Bound Smart Wallet";
  }
  constructor(options) {
    super({
      ...options,
      factoryAddress: options.registryAddress || ERC6551_REGISTRY
    });
    this.tbaOptions = options;
  }
  async getConnector() {
    if (!this.tbaConnector) {
      const {
        TokenBoundSmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm-M3OZHNKK.js");
      this.tbaConnector = new TokenBoundSmartWalletConnector(this.tbaOptions);
    }
    return this.tbaConnector;
  }
};
_defineProperty(TokenBoundSmartWallet, "meta", {
  name: "Token Bound Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(TokenBoundSmartWallet, "id", walletIds.tokenBoundSmartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic-eden/dist/thirdweb-dev-wallets-evm-wallets-magic-eden.browser.esm.js
init_lib3();
var MagicEdenWallet = class _MagicEdenWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Magic Eden";
  }
  /**
   * Create instance of `MagicEdenWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { MagicEdenWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new MagicEdenWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_MagicEdenWallet.id, options);
    this.isInjected = !!getInjectedMagicEdenProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        MagicEdenConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-magic-eden.browser.esm-7TK2VS7M.js");
      const connector = new MagicEdenConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.connector = new WagmiAdapter(connector);
    }
    return this.connector;
  }
};
_defineProperty(MagicEdenWallet, "id", walletIds.magicEden);

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
var import_contracts3 = __toESM(require_dist());
var import_buffer2 = __toESM(require_buffer2());
var import_utils6 = __toESM(require_utils());
var PREFIX2 = "__TW__";
var LocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return localStorage.getItem(`${PREFIX2}/${this.name}/${key}`);
  }
  setItem(key, value) {
    return localStorage.setItem(`${PREFIX2}/${this.name}/${key}`, value);
  }
  removeItem(key) {
    return localStorage.removeItem(`${PREFIX2}/${this.name}/${key}`);
  }
};
function createLocalStorage(name) {
  return new LocalStorage(name);
}
var WalletConnectHandler = class extends eventemitter3_default {
  constructor(wallet) {
    super();
    this.wallet = wallet;
  }
};
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options, wallet) {
    super(wallet);
    const defaultWCReceiverConfig = {
      walletConnectWalletMetadata: {
        name: "thirdweb Smart Account",
        description: "thirdweb Smart Account",
        url: "https://thirdweb.com",
        icons: ["https://thirdweb.com/favicon.ico"]
      },
      walletConnectV2ProjectId: TW_WC_PROJECT_ID,
      walletConnectV2RelayUrl: WC_RELAY_URL,
      ...(options == null ? void 0 : options.walletConnectReceiver) === true ? {} : options == null ? void 0 : options.walletConnectReceiver
    };
    this._wcMetadata = defaultWCReceiverConfig.walletConnectWalletMetadata;
    this._core = new co2({
      projectId: defaultWCReceiverConfig.walletConnectV2ProjectId,
      relayUrl: defaultWCReceiverConfig.walletConnectV2RelayUrl
    });
  }
  async init() {
    this._wcWallet = await ie5.init({
      core: this._core,
      metadata: this._wcMetadata
    });
    const sessions = this._wcWallet.getActiveSessions();
    const keys2 = Object.keys(sessions);
    if (keys2[0]) {
      this._session = sessions[keys2[0]];
    }
    this._setupWalletConnectEventsListeners();
  }
  async connectApp(wcUri) {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await this._wcWallet.core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession() {
    var _a;
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!this._activeProposal) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await this.wallet.getAddress();
    const {
      id,
      params
    } = this._activeProposal;
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a2;
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        (_a2 = namespace.chains) == null ? void 0 : _a2.map((chain) => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    this._session = await this._wcWallet.approveSession({
      id,
      relayProtocol: (_a = relays[0]) == null ? void 0 : _a.protocol,
      namespaces
    });
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!this._activeProposal) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = this._activeProposal;
    await this._wcWallet.rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request() {
    var _a, _b;
    if (!this._activeRequestEvent) {
      return;
    }
    const {
      topic,
      params,
      id
    } = this._activeRequestEvent;
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = this._getSignParamsMessage(request.params);
        const signedMessage = await this.wallet.signMessage(message || "");
        response = formatJsonRpcResult(id, signedMessage);
        break;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await this.wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await this.wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
        break;
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a = this._wcWallet) == null ? void 0 : _a.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = this._wcWallet) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a;
    if (!this._activeRequestEvent) {
      return;
    }
    const {
      topic,
      id
    } = this._activeRequestEvent;
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a = this._wcWallet) == null ? void 0 : _a.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = this._wcWallet.getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a;
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!this._session) {
      return Promise.resolve();
    }
    const params = {
      topic: this._session.topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a = this._wcWallet) == null ? void 0 : _a.disconnectSession(params);
  }
  _setupWalletConnectEventsListeners() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    this._wcWallet.on("session_proposal", (proposal) => {
      this._activeProposal = proposal;
      this.emit("session_proposal", {
        proposer: {
          metadata: proposal.params.proposer.metadata
        }
      });
    });
    this._wcWallet.on("session_delete", (session) => {
      this._session = void 0;
      this._activeProposal = void 0;
      this.emit("session_delete", {
        topic: session.topic
      });
    });
    this._wcWallet.on("session_request", async (requestEvent) => {
      if (!this._session) {
        return;
      }
      const {
        params: requestParams
      } = requestEvent;
      const {
        request
      } = requestParams;
      const {
        params
      } = request;
      switch (request.method) {
        case EIP155_SIGNING_METHODS.ETH_SIGN:
        case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
          this._activeRequestEvent = requestEvent;
          const message = params[0];
          const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
          const paramsCopy = [...params];
          paramsCopy[0] = decodedMessage;
          this.emit("session_request", {
            topic: this._session.topic,
            params: paramsCopy,
            peer: {
              metadata: this._session.peer.metadata
            },
            method: request.method
          });
          return;
        case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
          this._activeRequestEvent = requestEvent;
          this.emit("session_request", {
            topic: this._session.topic,
            params: requestEvent.params.request.params,
            peer: {
              metadata: this._session.peer.metadata
            },
            method: request.method
          });
          return;
        default:
          throw new Error(`WCV2.Method not supported: ${request.method}`);
      }
    });
  }
  /**
   * Gets message from various signing request methods by filtering out
   * a value that is not an address (thus is a message).
   * If it is a hex string, it gets converted to utf8 string
   */
  _getSignParamsMessage(params) {
    const message = params.filter((p5) => !utils_exports.isAddress(p5))[0] || "";
    if (utils_exports.isHexString(message)) {
      return utils_exports.toUtf8String(message);
    }
    return message;
  }
};

export {
  EIP155_SIGNING_METHODS,
  AsyncLocalStorage,
  createAsyncLocalStorage,
  DEFAULT_DAPP_META,
  isWalletAnalyticsEnabled,
  setWalletAnalyticsEnabled,
  AbstractClientWallet,
  BloctoWallet,
  EmbeddedWallet,
  MetaMaskWallet,
  OKXWallet,
  CoreWallet,
  OneKeyWallet,
  CryptoDefiWallet,
  RabbyWallet,
  Coin98Wallet,
  getInjectedCoinbaseProvider,
  EngineSigner,
  EngineWallet,
  PaperWallet,
  CoinbaseWallet,
  EthersWallet,
  FrameWallet,
  ImTokenWallet,
  InjectedWallet,
  LocalWallet,
  isValidPrivateKey,
  SignerWallet,
  MagicLink,
  XDEFIWallet,
  PhantomWallet,
  PrivateKeyWallet,
  RainbowWallet,
  SafeWallet,
  SmartWallet,
  TrustWallet,
  WalletConnect,
  WalletConnectV1,
  ZerionWallet,
  TokenBoundSmartWallet,
  MagicEdenWallet,
  LocalStorage,
  createLocalStorage,
  WalletConnectHandler,
  WalletConnectV2Handler
};
/*! Bundled license information:

@walletconnect/utils/dist/index.es.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-II57M3SS.js.map
