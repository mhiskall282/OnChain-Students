import{RELAYER_EVENTS as ze,TRANSPORT_TYPES as q,EXPIRER_EVENTS as vt,PAIRING_EVENTS as Ye,RELAYER_DEFAULT_PROTOCOL as Tt,EVENT_CLIENT_SESSION_TRACES as L,EVENT_CLIENT_SESSION_ERRORS as H,EVENT_CLIENT_AUTHENTICATE_TRACES as z,EVENT_CLIENT_AUTHENTICATE_ERRORS as re,EVENT_CLIENT_PAIRING_ERRORS as qt,EVENT_CLIENT_PAIRING_TRACES as Nt,VERIFY_SERVER as Pt,Store as J,Core as Ot}from"@walletconnect/core";import{pino as bt,getDefaultLoggerOptions as At,generateChildLogger as Ct,getLoggerContext as xt}from"@walletconnect/logger";import{IEngine as Vt,ISignClient as Dt}from"@walletconnect/types";import{THIRTY_DAYS as Lt,SEVEN_DAYS as Xe,FIVE_MINUTES as C,ONE_DAY as K,ONE_HOUR as Je,ONE_SECOND as Be,toMiliseconds as Pe}from"@walletconnect/time";import{getInternalError as y,BASE64URL as ne,BASE64 as ue,hashMessage as B,parseExpirerTarget as Mt,isValidString as U,isExpired as W,isValidId as kt,calcExpiry as x,createDelayedPromise as Z,engineEvent as E,getSdkError as b,getDeepLink as $t,handleDeeplinkRedirect as Kt,isSessionCompatible as Ut,hashKey as Oe,parseChainId as be,createEncodedRecap as Gt,getRecapFromResources as Ae,mergeEncodedRecaps as Ft,TYPE_2 as jt,getLinkModeURL as ge,validateSignedCacao as We,getNamespacedDidChainId as Ze,getDidAddress as et,getMethodsFromRecap as tt,getChainsFromRecap as st,buildNamespacesFromAuth as it,formatMessage as Qt,MemoryStore as oe,isValidParams as M,isUndefined as ae,isValidRelays as Ht,isValidObject as rt,isValidRequiredNamespaces as zt,isValidNamespaces as Ce,isConformingNamespaces as nt,isValidErrorReason as Yt,isValidRelay as Xt,isValidController as Jt,isValidNamespacesChainId as ot,isValidRequest as Bt,isValidNamespacesRequest as Wt,isValidRequestExpiry as Zt,isValidResponse as es,isValidEvent as ts,isValidNamespacesEvent as ss,getSearchParamFromURL as at,isTestRun as is,isReactNative as rs,isValidArray as ns,TYPE_1 as xe,getAppMetadata as os}from"@walletconnect/utils";import as,{EventEmitter as cs}from"events";import{isJsonRpcRequest as ls,isJsonRpcResponse as ps,payloadId as Y,getBigIntRpcId as ye,isJsonRpcResult as G,isJsonRpcError as F,formatJsonRpcRequest as we,formatJsonRpcResult as hs,formatJsonRpcError as ds}from"@walletconnect/jsonrpc-utils";const Ve="wc",De=2,Le="client",me=`${Ve}@${De}:${Le}:`,_e={name:Le,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"},us={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire"},gs={database:":memory:"},Me="WALLETCONNECT_DEEPLINK_CHOICE",ys={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},ws="history",ms="0.3",ct="proposal",_s=Lt,lt="Proposal expired",pt="session",X=Xe,ht="engine",N={wc_sessionPropose:{req:{ttl:C,prompt:!0,tag:1100},res:{ttl:C,prompt:!1,tag:1101},reject:{ttl:C,prompt:!1,tag:1120},autoReject:{ttl:C,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:C,prompt:!1,tag:1102},res:{ttl:C,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:K,prompt:!1,tag:1104},res:{ttl:K,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:K,prompt:!1,tag:1106},res:{ttl:K,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:C,prompt:!0,tag:1108},res:{ttl:C,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:C,prompt:!0,tag:1110},res:{ttl:C,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:K,prompt:!1,tag:1112},res:{ttl:K,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:K,prompt:!1,tag:1114},res:{ttl:K,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:Je,prompt:!0,tag:1116},res:{ttl:Je,prompt:!1,tag:1117},reject:{ttl:C,prompt:!1,tag:1118},autoReject:{ttl:C,prompt:!1,tag:1119}}},Ee={min:C,max:Xe},k={idle:"IDLE",active:"ACTIVE"},ke={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"}},dt="request",ut=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],gt="wc",Es=1.5,yt="auth",wt="authKeys",mt="pairingTopics",_t="requests",ce=`${gt}@${1.5}:${yt}:`,le=`${ce}:PUB_KEY`;var Rs=Object.defineProperty,Ss=Object.defineProperties,fs=Object.getOwnPropertyDescriptors,Et=Object.getOwnPropertySymbols,Is=Object.prototype.hasOwnProperty,vs=Object.prototype.propertyIsEnumerable,$e=(R,n,e)=>n in R?Rs(R,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):R[n]=e,I=(R,n)=>{for(var e in n||(n={}))Is.call(n,e)&&$e(R,e,n[e]);if(Et)for(var e of Et(n))vs.call(n,e)&&$e(R,e,n[e]);return R},V=(R,n)=>Ss(R,fs(n)),c=(R,n,e)=>$e(R,typeof n!="symbol"?n+"":n,e);class Ts extends Vt{constructor(n){super(n),c(this,"name",ht),c(this,"events",new as),c(this,"initialized",!1),c(this,"requestQueue",{state:k.idle,queue:[]}),c(this,"sessionRequestQueue",{state:k.idle,queue:[]}),c(this,"requestQueueDelay",Be),c(this,"expectedPairingMethodMap",new Map),c(this,"recentlyDeletedMap",new Map),c(this,"recentlyDeletedLimit",200),c(this,"relayMessageCache",[]),c(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(N)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},Pe(this.requestQueueDelay)))}),c(this,"connect",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const t=V(I({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(t);const{pairingTopic:s,requiredNamespaces:i,optionalNamespaces:r,sessionProperties:o,relays:a}=t;let l=s,d,u=!1;try{if(l){const f=this.client.core.pairing.pairings.get(l);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),u=f.active}}catch(f){throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`),f}if(!l||!u){const{topic:f,uri:v}=await this.client.core.pairing.create();l=f,d=v}if(!l){const{message:f}=y("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(f)}const g=await this.client.core.crypto.generateKeyPair(),h=N.wc_sessionPropose.req.ttl||C,w=x(h),S=I({requiredNamespaces:i,optionalNamespaces:r,relays:a??[{protocol:Tt}],proposer:{publicKey:g,metadata:this.client.metadata},expiryTimestamp:w,pairingTopic:l},o&&{sessionProperties:o}),{reject:T,resolve:p,done:m}=Z(h,lt);this.events.once(E("session_connect"),async({error:f,session:v})=>{if(f)T(f);else if(v){v.self.publicKey=g;const $=V(I({},v),{pairingTopic:S.pairingTopic,requiredNamespaces:S.requiredNamespaces,optionalNamespaces:S.optionalNamespaces,transportType:q.relay});await this.client.session.set(v.topic,$),await this.setExpiry(v.topic,v.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:v.peer.metadata}),this.cleanupDuplicatePairings($),p($)}});const D=await this.sendRequest({topic:l,method:"wc_sessionPropose",params:S,throwOnFailedPublish:!0});return await this.setProposal(D,I({id:D},S)),{uri:d,approval:m}}),c(this,"pair",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(e)}catch(t){throw this.client.logger.error("pair() failed"),t}}),c(this,"approve",async e=>{var t,s,i;const r=this.client.core.eventClient.createEvent({properties:{topic:(t=e?.id)==null?void 0:t.toString(),trace:[L.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(O){throw r.setError(H.no_internet_connection),O}try{await this.isValidProposalId(e?.id)}catch(O){throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`),r.setError(H.proposal_not_found),O}try{await this.isValidApprove(e)}catch(O){throw this.client.logger.error("approve() -> isValidApprove() failed"),r.setError(H.session_approve_namespace_validation_failure),O}const{id:o,relayProtocol:a,namespaces:l,sessionProperties:d,sessionConfig:u}=e,g=this.client.proposal.get(o);this.client.core.eventClient.deleteEvent({eventId:r.eventId});const{pairingTopic:h,proposer:w,requiredNamespaces:S,optionalNamespaces:T}=g;let p=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:h});p||(p=(i=this.client.core.eventClient)==null?void 0:i.createEvent({type:L.session_approve_started,properties:{topic:h,trace:[L.session_approve_started,L.session_namespaces_validation_success]}}));const m=await this.client.core.crypto.generateKeyPair(),D=w.publicKey,f=await this.client.core.crypto.generateSharedKey(m,D),v=I(I({relay:{protocol:a??"irn"},namespaces:l,controller:{publicKey:m,metadata:this.client.metadata},expiry:x(X)},d&&{sessionProperties:d}),u&&{sessionConfig:u}),$=q.relay;p.addTrace(L.subscribing_session_topic);try{await this.client.core.relayer.subscribe(f,{transportType:$})}catch(O){throw p.setError(H.subscribe_session_topic_failure),O}p.addTrace(L.subscribe_session_topic_success);const ee=V(I({},v),{topic:f,requiredNamespaces:S,optionalNamespaces:T,pairingTopic:h,acknowledged:!1,self:v.controller,peer:{publicKey:w.publicKey,metadata:w.metadata},controller:m,transportType:q.relay});await this.client.session.set(f,ee),p.addTrace(L.store_session);try{p.addTrace(L.publishing_session_settle),await this.sendRequest({topic:f,method:"wc_sessionSettle",params:v,throwOnFailedPublish:!0}).catch(O=>{throw p?.setError(H.session_settle_publish_failure),O}),p.addTrace(L.session_settle_publish_success),p.addTrace(L.publishing_session_approve),await this.sendResult({id:o,topic:h,result:{relay:{protocol:a??"irn"},responderPublicKey:m},throwOnFailedPublish:!0}).catch(O=>{throw p?.setError(H.session_approve_publish_failure),O}),p.addTrace(L.session_approve_publish_success)}catch(O){throw this.client.logger.error(O),this.client.session.delete(f,b("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(f),O}return this.client.core.eventClient.deleteEvent({eventId:p.eventId}),await this.client.core.pairing.updateMetadata({topic:h,metadata:w.metadata}),await this.client.proposal.delete(o,b("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:h}),await this.setExpiry(f,x(X)),{topic:f,acknowledged:()=>Promise.resolve(this.client.session.get(f))}}),c(this,"reject",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(e)}catch(r){throw this.client.logger.error("reject() -> isValidReject() failed"),r}const{id:t,reason:s}=e;let i;try{i=this.client.proposal.get(t).pairingTopic}catch(r){throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`),r}i&&(await this.sendError({id:t,topic:i,error:s,rpcOpts:N.wc_sessionPropose.reject}),await this.client.proposal.delete(t,b("USER_DISCONNECTED")))}),c(this,"update",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(e)}catch(u){throw this.client.logger.error("update() -> isValidUpdate() failed"),u}const{topic:t,namespaces:s}=e,{done:i,resolve:r,reject:o}=Z(),a=Y(),l=ye().toString(),d=this.client.session.get(t).namespaces;return this.events.once(E("session_update",a),({error:u})=>{u?o(u):r()}),await this.client.session.update(t,{namespaces:s}),await this.sendRequest({topic:t,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:a,relayRpcId:l}).catch(u=>{this.client.logger.error(u),this.client.session.update(t,{namespaces:d}),o(u)}),{acknowledged:i}}),c(this,"extend",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(e)}catch(a){throw this.client.logger.error("extend() -> isValidExtend() failed"),a}const{topic:t}=e,s=Y(),{done:i,resolve:r,reject:o}=Z();return this.events.once(E("session_extend",s),({error:a})=>{a?o(a):r()}),await this.setExpiry(t,x(X)),this.sendRequest({topic:t,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(a=>{o(a)}),{acknowledged:i}}),c(this,"request",async e=>{this.isInitialized();try{await this.isValidRequest(e)}catch(p){throw this.client.logger.error("request() -> isValidRequest() failed"),p}const{chainId:t,request:s,topic:i,expiry:r=N.wc_sessionRequest.req.ttl}=e,o=this.client.session.get(i);o?.transportType===q.relay&&await this.confirmOnlineStateOrThrow();const a=Y(),l=ye().toString(),{done:d,resolve:u,reject:g}=Z(r,"Request expired. Please try again.");this.events.once(E("session_request",a),({error:p,result:m})=>{p?g(p):u(m)});const h="wc_sessionRequest",w=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);if(w)return await this.sendRequest({clientRpcId:a,relayRpcId:l,topic:i,method:h,params:{request:V(I({},s),{expiryTimestamp:x(r)}),chainId:t},expiry:r,throwOnFailedPublish:!0,appLink:w}).catch(p=>g(p)),this.client.events.emit("session_request_sent",{topic:i,request:s,chainId:t,id:a}),await d();const S={request:V(I({},s),{expiryTimestamp:x(r)}),chainId:t},T=this.shouldSetTVF(h,S);return await Promise.all([new Promise(async p=>{await this.sendRequest(I({clientRpcId:a,relayRpcId:l,topic:i,method:h,params:S,expiry:r,throwOnFailedPublish:!0},T&&{tvf:this.getTVFParams(a,S)})).catch(m=>g(m)),this.client.events.emit("session_request_sent",{topic:i,request:s,chainId:t,id:a}),p()}),new Promise(async p=>{var m;if(!((m=o.sessionConfig)!=null&&m.disableDeepLink)){const D=await $t(this.client.core.storage,Me);await Kt({id:a,topic:i,wcDeepLink:D})}p()}),d()]).then(p=>p[2])}),c(this,"respond",async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:t,response:s}=e,{id:i}=s,r=this.client.session.get(t);r.transportType===q.relay&&await this.confirmOnlineStateOrThrow();const o=this.getAppLinkIfEnabled(r.peer.metadata,r.transportType);G(s)?await this.sendResult({id:i,topic:t,result:s.result,throwOnFailedPublish:!0,appLink:o}):F(s)&&await this.sendError({id:i,topic:t,error:s.error,appLink:o}),this.cleanupAfterResponse(e)}),c(this,"ping",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(e)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:t}=e;if(this.client.session.keys.includes(t)){const s=Y(),i=ye().toString(),{done:r,resolve:o,reject:a}=Z();this.events.once(E("session_ping",s),({error:l})=>{l?a(l):o()}),await Promise.all([this.sendRequest({topic:t,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:i}),r()])}else this.client.core.pairing.pairings.keys.includes(t)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:t}))}),c(this,"emit",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(e);const{topic:t,event:s,chainId:i}=e,r=ye().toString(),o=Y();await this.sendRequest({topic:t,method:"wc_sessionEvent",params:{event:s,chainId:i},throwOnFailedPublish:!0,relayRpcId:r,clientRpcId:o})}),c(this,"disconnect",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(e);const{topic:t}=e;if(this.client.session.keys.includes(t))await this.sendRequest({topic:t,method:"wc_sessionDelete",params:b("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:t,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(t))await this.client.core.pairing.disconnect({topic:t});else{const{message:s}=y("MISMATCHED_TOPIC",`Session or pairing topic not found: ${t}`);throw new Error(s)}}),c(this,"find",e=>(this.isInitialized(),this.client.session.getAll().filter(t=>Ut(t,e)))),c(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),c(this,"authenticate",async(e,t)=>{var s;this.isInitialized(),this.isValidAuthenticate(e);const i=t&&this.client.core.linkModeSupportedApps.includes(t)&&((s=this.client.metadata.redirect)==null?void 0:s.linkMode),r=i?q.link_mode:q.relay;r===q.relay&&await this.confirmOnlineStateOrThrow();const{chains:o,statement:a="",uri:l,domain:d,nonce:u,type:g,exp:h,nbf:w,methods:S=[],expiry:T}=e,p=[...e.resources||[]],{topic:m,uri:D}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:r});this.client.logger.info({message:"Generated new pairing",pairing:{topic:m,uri:D}});const f=await this.client.core.crypto.generateKeyPair(),v=Oe(f);if(await Promise.all([this.client.auth.authKeys.set(le,{responseTopic:v,publicKey:f}),this.client.auth.pairingTopics.set(v,{topic:v,pairingTopic:m})]),await this.client.core.relayer.subscribe(v,{transportType:r}),this.client.logger.info(`sending request to new pairing topic: ${m}`),S.length>0){const{namespace:A}=be(o[0]);let P=Gt(A,"request",S);Ae(p)&&(P=Ft(P,p.pop())),p.push(P)}const $=T&&T>N.wc_sessionAuthenticate.req.ttl?T:N.wc_sessionAuthenticate.req.ttl,ee={authPayload:{type:g??"caip122",chains:o,statement:a,aud:l,domain:d,version:"1",nonce:u,iat:new Date().toISOString(),exp:h,nbf:w,resources:p},requester:{publicKey:f,metadata:this.client.metadata},expiryTimestamp:x($)},O={eip155:{chains:o,methods:[...new Set(["personal_sign",...S])],events:["chainChanged","accountsChanged"]}},Ue={requiredNamespaces:{},optionalNamespaces:O,relays:[{protocol:"irn"}],pairingTopic:m,proposer:{publicKey:f,metadata:this.client.metadata},expiryTimestamp:x(N.wc_sessionPropose.req.ttl)},{done:St,resolve:Ge,reject:Se}=Z($,"Request expired"),pe=async({error:A,session:P})=>{if(this.events.off(E("session_request",j),fe),A)Se(A);else if(P){P.self.publicKey=f,await this.client.session.set(P.topic,P),await this.setExpiry(P.topic,P.expiry),m&&await this.client.core.pairing.updateMetadata({topic:m,metadata:P.peer.metadata});const he=this.client.session.get(P.topic);await this.deleteProposal(te),Ge({session:he})}},fe=async A=>{var P,he,Fe;if(await this.deletePendingAuthRequest(j,{message:"fulfilled",code:0}),A.error){const ie=b("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return A.error.code===ie.code?void 0:(this.events.off(E("session_connect"),pe),Se(A.error.message))}await this.deleteProposal(te),this.events.off(E("session_connect"),pe);const{cacaos:je,responder:Q}=A.result,ve=[],Qe=[];for(const ie of je){await We({cacao:ie,projectId:this.client.core.projectId})||(this.client.logger.error(ie,"Signature verification failed"),Se(b("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:Te}=ie,qe=Ae(Te.resources),He=[Ze(Te.iss)],ft=et(Te.iss);if(qe){const Ne=tt(qe),It=st(qe);ve.push(...Ne),He.push(...It)}for(const Ne of He)Qe.push(`${Ne}:${ft}`)}const se=await this.client.core.crypto.generateSharedKey(f,Q.publicKey);let de;ve.length>0&&(de={topic:se,acknowledged:!0,self:{publicKey:f,metadata:this.client.metadata},peer:Q,controller:Q.publicKey,expiry:x(X),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:m,namespaces:it([...new Set(ve)],[...new Set(Qe)]),transportType:r},await this.client.core.relayer.subscribe(se,{transportType:r}),await this.client.session.set(se,de),m&&await this.client.core.pairing.updateMetadata({topic:m,metadata:Q.metadata}),de=this.client.session.get(se)),(P=this.client.metadata.redirect)!=null&&P.linkMode&&(he=Q.metadata.redirect)!=null&&he.linkMode&&(Fe=Q.metadata.redirect)!=null&&Fe.universal&&t&&(this.client.core.addLinkModeSupportedApp(Q.metadata.redirect.universal),this.client.session.update(se,{transportType:q.link_mode})),Ge({auths:je,session:de})},j=Y(),te=Y();this.events.once(E("session_connect"),pe),this.events.once(E("session_request",j),fe);let Ie;try{if(i){const A=we("wc_sessionAuthenticate",ee,j);this.client.core.history.set(m,A);const P=await this.client.core.crypto.encode("",A,{type:jt,encoding:ne});Ie=ge(t,m,P)}else await Promise.all([this.sendRequest({topic:m,method:"wc_sessionAuthenticate",params:ee,expiry:e.expiry,throwOnFailedPublish:!0,clientRpcId:j}),this.sendRequest({topic:m,method:"wc_sessionPropose",params:Ue,expiry:N.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:te})])}catch(A){throw this.events.off(E("session_connect"),pe),this.events.off(E("session_request",j),fe),A}return await this.setProposal(te,I({id:te},Ue)),await this.setAuthRequest(j,{request:V(I({},ee),{verifyContext:{}}),pairingTopic:m,transportType:r}),{uri:Ie??D,response:St}}),c(this,"approveSessionAuthenticate",async e=>{const{id:t,auths:s}=e,i=this.client.core.eventClient.createEvent({properties:{topic:t.toString(),trace:[z.authenticated_session_approve_started]}});try{this.isInitialized()}catch(T){throw i.setError(re.no_internet_connection),T}const r=this.getPendingAuthRequest(t);if(!r)throw i.setError(re.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${t}`);const o=r.transportType||q.relay;o===q.relay&&await this.confirmOnlineStateOrThrow();const a=r.requester.publicKey,l=await this.client.core.crypto.generateKeyPair(),d=Oe(a),u={type:xe,receiverPublicKey:a,senderPublicKey:l},g=[],h=[];for(const T of s){if(!await We({cacao:T,projectId:this.client.core.projectId})){i.setError(re.invalid_cacao);const v=b("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:t,topic:d,error:v,encodeOpts:u}),new Error(v.message)}i.addTrace(z.cacaos_verified);const{p}=T,m=Ae(p.resources),D=[Ze(p.iss)],f=et(p.iss);if(m){const v=tt(m),$=st(m);g.push(...v),D.push(...$)}for(const v of D)h.push(`${v}:${f}`)}const w=await this.client.core.crypto.generateSharedKey(l,a);i.addTrace(z.create_authenticated_session_topic);let S;if(g?.length>0){S={topic:w,acknowledged:!0,self:{publicKey:l,metadata:this.client.metadata},peer:{publicKey:a,metadata:r.requester.metadata},controller:a,expiry:x(X),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:r.pairingTopic,namespaces:it([...new Set(g)],[...new Set(h)]),transportType:o},i.addTrace(z.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(w,{transportType:o})}catch(T){throw i.setError(re.subscribe_authenticated_session_topic_failure),T}i.addTrace(z.subscribe_authenticated_session_topic_success),await this.client.session.set(w,S),i.addTrace(z.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:r.pairingTopic,metadata:r.requester.metadata})}i.addTrace(z.publishing_authenticated_session_approve);try{await this.sendResult({topic:d,id:t,result:{cacaos:s,responder:{publicKey:l,metadata:this.client.metadata}},encodeOpts:u,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(r.requester.metadata,o)})}catch(T){throw i.setError(re.authenticated_session_approve_publish_failure),T}return await this.client.auth.requests.delete(t,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:r.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:i.eventId}),{session:S}}),c(this,"rejectSessionAuthenticate",async e=>{this.isInitialized();const{id:t,reason:s}=e,i=this.getPendingAuthRequest(t);if(!i)throw new Error(`Could not find pending auth request with id ${t}`);i.transportType===q.relay&&await this.confirmOnlineStateOrThrow();const r=i.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),a=Oe(r),l={type:xe,receiverPublicKey:r,senderPublicKey:o};await this.sendError({id:t,topic:a,error:s,encodeOpts:l,rpcOpts:N.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(i.requester.metadata,i.transportType)}),await this.client.auth.requests.delete(t,{message:"rejected",code:0}),await this.client.proposal.delete(t,b("USER_DISCONNECTED"))}),c(this,"formatAuthMessage",e=>{this.isInitialized();const{request:t,iss:s}=e;return Qt(t,s)}),c(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const e=this.relayMessageCache.shift();e&&await this.onRelayMessage(e)}catch(e){this.client.logger.error(e)}},50)}),c(this,"cleanupDuplicatePairings",async e=>{if(e.pairingTopic)try{const t=this.client.core.pairing.pairings.get(e.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(i=>{var r,o;return((r=i.peerMetadata)==null?void 0:r.url)&&((o=i.peerMetadata)==null?void 0:o.url)===e.peer.metadata.url&&i.topic&&i.topic!==t.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(i=>this.client.core.pairing.disconnect({topic:i.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(t){this.client.logger.error(t)}}),c(this,"deleteSession",async e=>{var t;const{topic:s,expirerHasDeleted:i=!1,emitEvent:r=!0,id:o=0}=e,{self:a}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,b("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(a.publicKey)&&await this.client.core.crypto.deleteKeyPair(a.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),i||this.client.core.expirer.del(s),this.client.core.storage.removeItem(Me).catch(l=>this.client.logger.warn(l)),this.getPendingSessionRequests().forEach(l=>{l.topic===s&&this.deletePendingSessionRequest(l.id,b("USER_DISCONNECTED"))}),s===((t=this.sessionRequestQueue.queue[0])==null?void 0:t.topic)&&(this.sessionRequestQueue.state=k.idle),r&&this.client.events.emit("session_delete",{id:o,topic:s})}),c(this,"deleteProposal",async(e,t)=>{if(t)try{const s=this.client.proposal.get(e),i=this.client.core.eventClient.getEvent({topic:s.pairingTopic});i?.setError(H.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(e,b("USER_DISCONNECTED")),t?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"proposal")}),c(this,"deletePendingSessionRequest",async(e,t,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(i=>i.id!==e),s&&(this.sessionRequestQueue.state=k.idle,this.client.events.emit("session_request_expire",{id:e}))}),c(this,"deletePendingAuthRequest",async(e,t,s=!1)=>{await Promise.all([this.client.auth.requests.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)])}),c(this,"setExpiry",async(e,t)=>{this.client.session.keys.includes(e)&&(this.client.core.expirer.set(e,t),await this.client.session.update(e,{expiry:t}))}),c(this,"setProposal",async(e,t)=>{this.client.core.expirer.set(e,x(N.wc_sessionPropose.req.ttl)),await this.client.proposal.set(e,t)}),c(this,"setAuthRequest",async(e,t)=>{const{request:s,pairingTopic:i,transportType:r=q.relay}=t;this.client.core.expirer.set(e,s.expiryTimestamp),await this.client.auth.requests.set(e,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:e,pairingTopic:i,verifyContext:s.verifyContext,transportType:r})}),c(this,"setPendingSessionRequest",async e=>{const{id:t,topic:s,params:i,verifyContext:r}=e,o=i.request.expiryTimestamp||x(N.wc_sessionRequest.req.ttl);this.client.core.expirer.set(t,o),await this.client.pendingRequest.set(t,{id:t,topic:s,params:i,verifyContext:r})}),c(this,"sendRequest",async e=>{const{topic:t,method:s,params:i,expiry:r,relayRpcId:o,clientRpcId:a,throwOnFailedPublish:l,appLink:d,tvf:u}=e,g=we(s,i,a);let h;const w=!!d;try{const p=w?ne:ue;h=await this.client.core.crypto.encode(t,g,{encoding:p})}catch(p){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`),p}let S;if(ut.includes(s)){const p=B(JSON.stringify(g)),m=B(h);S=await this.client.core.verify.register({id:m,decryptedId:p})}const T=N[s].req;if(T.attestation=S,r&&(T.ttl=r),o&&(T.id=o),this.client.core.history.set(t,g),w){const p=ge(d,t,h);await global.Linking.openURL(p,this.client.name)}else{const p=N[s].req;r&&(p.ttl=r),o&&(p.id=o),p.tvf=V(I({},u),{correlationId:g.id}),l?(p.internal=V(I({},p.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,h,p)):this.client.core.relayer.publish(t,h,p).catch(m=>this.client.logger.error(m))}return g.id}),c(this,"sendResult",async e=>{const{id:t,topic:s,result:i,throwOnFailedPublish:r,encodeOpts:o,appLink:a}=e,l=hs(t,i);let d;const u=a&&typeof(global==null?void 0:global.Linking)<"u";try{const w=u?ne:ue;d=await this.client.core.crypto.encode(s,l,V(I({},o||{}),{encoding:w}))}catch(w){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),w}let g,h;try{g=await this.client.core.history.get(s,t);const w=g.request;try{this.shouldSetTVF(w.method,w.params)&&(h=this.getTVFParams(t,w.params,i))}catch(S){this.client.logger.warn("sendResult() -> getTVFParams() failed",S)}}catch(w){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`),w}if(u){const w=ge(a,s,d);await global.Linking.openURL(w,this.client.name)}else{const w=N[g.request.method].res;w.tvf=V(I({},h),{correlationId:t}),r?(w.internal=V(I({},w.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,d,w)):this.client.core.relayer.publish(s,d,w).catch(S=>this.client.logger.error(S))}await this.client.core.history.resolve(l)}),c(this,"sendError",async e=>{const{id:t,topic:s,error:i,encodeOpts:r,rpcOpts:o,appLink:a}=e,l=ds(t,i);let d;const u=a&&typeof(global==null?void 0:global.Linking)<"u";try{const h=u?ne:ue;d=await this.client.core.crypto.encode(s,l,V(I({},r||{}),{encoding:h}))}catch(h){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),h}let g;try{g=await this.client.core.history.get(s,t)}catch(h){throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`),h}if(u){const h=ge(a,s,d);await global.Linking.openURL(h,this.client.name)}else{const h=o||N[g.request.method].res;this.client.core.relayer.publish(s,d,h)}await this.client.core.history.resolve(l)}),c(this,"cleanup",async()=>{const e=[],t=[];this.client.session.getAll().forEach(s=>{let i=!1;W(s.expiry)&&(i=!0),this.client.core.crypto.keychain.has(s.topic)||(i=!0),i&&e.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{W(s.expiryTimestamp)&&t.push(s.id)}),await Promise.all([...e.map(s=>this.deleteSession({topic:s})),...t.map(s=>this.deleteProposal(s))])}),c(this,"onRelayEventRequest",async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue()}),c(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===k.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=k.active;const e=this.requestQueue.queue.shift();if(e)try{await this.processRequest(e)}catch(t){this.client.logger.warn(t)}}this.requestQueue.state=k.idle}),c(this,"processRequest",async e=>{const{topic:t,payload:s,attestation:i,transportType:r,encryptedId:o}=e,a=s.method;if(!this.shouldIgnorePairingRequest({topic:t,requestMethod:a}))switch(a){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:t,payload:s,attestation:i,encryptedId:o});case"wc_sessionSettle":return await this.onSessionSettleRequest(t,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(t,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(t,s);case"wc_sessionPing":return await this.onSessionPingRequest(t,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(t,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:t,payload:s,attestation:i,encryptedId:o,transportType:r});case"wc_sessionEvent":return await this.onSessionEventRequest(t,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:t,payload:s,attestation:i,encryptedId:o,transportType:r});default:return this.client.logger.info(`Unsupported request method ${a}`)}}),c(this,"onRelayEventResponse",async e=>{const{topic:t,payload:s,transportType:i}=e,r=(await this.client.core.history.get(t,s.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(t,s,i);case"wc_sessionSettle":return this.onSessionSettleResponse(t,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(t,s);case"wc_sessionExtend":return this.onSessionExtendResponse(t,s);case"wc_sessionPing":return this.onSessionPingResponse(t,s);case"wc_sessionRequest":return this.onSessionRequestResponse(t,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(t,s);default:return this.client.logger.info(`Unsupported response method ${r}`)}}),c(this,"onRelayEventUnknownPayload",e=>{const{topic:t}=e,{message:s}=y("MISSING_OR_INVALID",`Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)}),c(this,"shouldIgnorePairingRequest",e=>{const{topic:t,requestMethod:s}=e,i=this.expectedPairingMethodMap.get(t);return!i||i.includes(s)?!1:!!(i.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),c(this,"onSessionProposeRequest",async e=>{const{topic:t,payload:s,attestation:i,encryptedId:r}=e,{params:o,id:a}=s;try{const l=this.client.core.eventClient.getEvent({topic:t});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),l?.setError(qt.proposal_listener_not_found)),this.isValidConnect(I({},s.params));const d=o.expiryTimestamp||x(N.wc_sessionPropose.req.ttl),u=I({id:a,pairingTopic:t,expiryTimestamp:d},o);await this.setProposal(a,u);const g=await this.getVerifyContext({attestationId:i,hash:B(JSON.stringify(s)),encryptedId:r,metadata:u.proposer.metadata});l?.addTrace(Nt.emit_session_proposal),this.client.events.emit("session_proposal",{id:a,params:u,verifyContext:g})}catch(l){await this.sendError({id:a,topic:t,error:l,rpcOpts:N.wc_sessionPropose.autoReject}),this.client.logger.error(l)}}),c(this,"onSessionProposeResponse",async(e,t,s)=>{const{id:i}=t;if(G(t)){const{result:r}=t;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});const o=this.client.proposal.get(i);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:o});const a=o.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});const l=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:l});const d=await this.client.core.crypto.generateSharedKey(a,l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:d});const u=await this.client.core.relayer.subscribe(d,{transportType:s});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:u}),await this.client.core.pairing.activate({topic:e})}else if(F(t)){await this.client.proposal.delete(i,b("USER_DISCONNECTED"));const r=E("session_connect");if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners, 954`);this.events.emit(E("session_connect"),{error:t.error})}}),c(this,"onSessionSettleRequest",async(e,t)=>{const{id:s,params:i}=t;try{this.isValidSessionSettleRequest(i);const{relay:r,controller:o,expiry:a,namespaces:l,sessionProperties:d,sessionConfig:u}=t.params,g=V(I(I({topic:e,relay:r,expiry:a,namespaces:l,acknowledged:!0,pairingTopic:"",requiredNamespaces:{},optionalNamespaces:{},controller:o.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},d&&{sessionProperties:d}),u&&{sessionConfig:u}),{transportType:q.relay}),h=E("session_connect");if(this.events.listenerCount(h)===0)throw new Error(`emitting ${h} without any listeners 997`);this.events.emit(E("session_connect"),{session:g}),await this.sendResult({id:t.id,topic:e,result:!0,throwOnFailedPublish:!0})}catch(r){await this.sendError({id:s,topic:e,error:r}),this.client.logger.error(r)}}),c(this,"onSessionSettleResponse",async(e,t)=>{const{id:s}=t;G(t)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(E("session_approve",s),{})):F(t)&&(await this.client.session.delete(e,b("USER_DISCONNECTED")),this.events.emit(E("session_approve",s),{error:t.error}))}),c(this,"onSessionUpdateRequest",async(e,t)=>{const{params:s,id:i}=t;try{const r=`${e}_session_update`,o=oe.get(r);if(o&&this.isRequestOutOfSync(o,i)){this.client.logger.warn(`Discarding out of sync request - ${i}`),this.sendError({id:i,topic:e,error:b("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(I({topic:e},s));try{oe.set(r,i),await this.client.session.update(e,{namespaces:s.namespaces}),await this.sendResult({id:i,topic:e,result:!0,throwOnFailedPublish:!0})}catch(a){throw oe.delete(r),a}this.client.events.emit("session_update",{id:i,topic:e,params:s})}catch(r){await this.sendError({id:i,topic:e,error:r}),this.client.logger.error(r)}}),c(this,"isRequestOutOfSync",(e,t)=>t.toString().slice(0,-3)<e.toString().slice(0,-3)),c(this,"onSessionUpdateResponse",(e,t)=>{const{id:s}=t,i=E("session_update",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);G(t)?this.events.emit(E("session_update",s),{}):F(t)&&this.events.emit(E("session_update",s),{error:t.error})}),c(this,"onSessionExtendRequest",async(e,t)=>{const{id:s}=t;try{this.isValidExtend({topic:e}),await this.setExpiry(e,x(X)),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:e})}catch(i){await this.sendError({id:s,topic:e,error:i}),this.client.logger.error(i)}}),c(this,"onSessionExtendResponse",(e,t)=>{const{id:s}=t,i=E("session_extend",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);G(t)?this.events.emit(E("session_extend",s),{}):F(t)&&this.events.emit(E("session_extend",s),{error:t.error})}),c(this,"onSessionPingRequest",async(e,t)=>{const{id:s}=t;try{this.isValidPing({topic:e}),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:e})}catch(i){await this.sendError({id:s,topic:e,error:i}),this.client.logger.error(i)}}),c(this,"onSessionPingResponse",(e,t)=>{const{id:s}=t,i=E("session_ping",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);setTimeout(()=>{G(t)?this.events.emit(E("session_ping",s),{}):F(t)&&this.events.emit(E("session_ping",s),{error:t.error})},500)}),c(this,"onSessionDeleteRequest",async(e,t)=>{const{id:s}=t;try{this.isValidDisconnect({topic:e,reason:t.params}),Promise.all([new Promise(i=>{this.client.core.relayer.once(ze.publish,async()=>{i(await this.deleteSession({topic:e,id:s}))})}),this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:e,error:b("USER_DISCONNECTED")})]).catch(i=>this.client.logger.error(i))}catch(i){this.client.logger.error(i)}}),c(this,"onSessionRequest",async e=>{var t,s,i;const{topic:r,payload:o,attestation:a,encryptedId:l,transportType:d}=e,{id:u,params:g}=o;try{await this.isValidRequest(I({topic:r},g));const h=this.client.session.get(r),w=await this.getVerifyContext({attestationId:a,hash:B(JSON.stringify(we("wc_sessionRequest",g,u))),encryptedId:l,metadata:h.peer.metadata,transportType:d}),S={id:u,topic:r,params:g,verifyContext:w};await this.setPendingSessionRequest(S),d===q.link_mode&&(t=h.peer.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp((s=h.peer.metadata.redirect)==null?void 0:s.universal),(i=this.client.signConfig)!=null&&i.disableRequestQueue?this.emitSessionRequest(S):(this.addSessionRequestToSessionRequestQueue(S),this.processSessionRequestQueue())}catch(h){await this.sendError({id:u,topic:r,error:h}),this.client.logger.error(h)}}),c(this,"onSessionRequestResponse",(e,t)=>{const{id:s}=t,i=E("session_request",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);G(t)?this.events.emit(E("session_request",s),{result:t.result}):F(t)&&this.events.emit(E("session_request",s),{error:t.error})}),c(this,"onSessionEventRequest",async(e,t)=>{const{id:s,params:i}=t;try{const r=`${e}_session_event_${i.event.name}`,o=oe.get(r);if(o&&this.isRequestOutOfSync(o,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(I({topic:e},i)),this.client.events.emit("session_event",{id:s,topic:e,params:i}),oe.set(r,s)}catch(r){await this.sendError({id:s,topic:e,error:r}),this.client.logger.error(r)}}),c(this,"onSessionAuthenticateResponse",(e,t)=>{const{id:s}=t;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:e,payload:t}),G(t)?this.events.emit(E("session_request",s),{result:t.result}):F(t)&&this.events.emit(E("session_request",s),{error:t.error})}),c(this,"onSessionAuthenticateRequest",async e=>{var t;const{topic:s,payload:i,attestation:r,encryptedId:o,transportType:a}=e;try{const{requester:l,authPayload:d,expiryTimestamp:u}=i.params,g=await this.getVerifyContext({attestationId:r,hash:B(JSON.stringify(i)),encryptedId:o,metadata:l.metadata,transportType:a}),h={requester:l,pairingTopic:s,id:i.id,authPayload:d,verifyContext:g,expiryTimestamp:u};await this.setAuthRequest(i.id,{request:h,pairingTopic:s,transportType:a}),a===q.link_mode&&(t=l.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:s,params:i.params,id:i.id,verifyContext:g})}catch(l){this.client.logger.error(l);const d=i.params.requester.publicKey,u=await this.client.core.crypto.generateKeyPair(),g=this.getAppLinkIfEnabled(i.params.requester.metadata,a),h={type:xe,receiverPublicKey:d,senderPublicKey:u};await this.sendError({id:i.id,topic:s,error:l,encodeOpts:h,rpcOpts:N.wc_sessionAuthenticate.autoReject,appLink:g})}}),c(this,"addSessionRequestToSessionRequestQueue",e=>{this.sessionRequestQueue.queue.push(e)}),c(this,"cleanupAfterResponse",e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=k.idle,this.processSessionRequestQueue()},Pe(this.requestQueueDelay))}),c(this,"cleanupPendingSentRequestsForTopic",({topic:e,error:t})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(i=>i.topic===e&&i.request.method==="wc_sessionRequest").forEach(i=>{const r=i.request.id,o=E("session_request",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);this.events.emit(E("session_request",i.request.id),{error:t})})}),c(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===k.active){this.client.logger.info("session request queue is already active.");return}const e=this.sessionRequestQueue.queue[0];if(!e){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=k.active,this.emitSessionRequest(e)}catch(t){this.client.logger.error(t)}}),c(this,"emitSessionRequest",e=>{this.client.events.emit("session_request",e)}),c(this,"onPairingCreated",e=>{if(e.methods&&this.expectedPairingMethodMap.set(e.topic,e.methods),e.active)return;const t=this.client.proposal.getAll().find(s=>s.pairingTopic===e.topic);t&&this.onSessionProposeRequest({topic:e.topic,payload:we("wc_sessionPropose",{requiredNamespaces:t.requiredNamespaces,optionalNamespaces:t.optionalNamespaces,relays:t.relays,proposer:t.proposer,sessionProperties:t.sessionProperties},t.id)})}),c(this,"isValidConnect",async e=>{if(!M(e)){const{message:a}=y("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(a)}const{pairingTopic:t,requiredNamespaces:s,optionalNamespaces:i,sessionProperties:r,relays:o}=e;if(ae(t)||await this.isValidPairingTopic(t),!Ht(o,!0)){const{message:a}=y("MISSING_OR_INVALID",`connect() relays: ${o}`);throw new Error(a)}!ae(s)&&rt(s)!==0&&this.validateNamespaces(s,"requiredNamespaces"),!ae(i)&&rt(i)!==0&&this.validateNamespaces(i,"optionalNamespaces"),ae(r)||this.validateSessionProps(r,"sessionProperties")}),c(this,"validateNamespaces",(e,t)=>{const s=zt(e,"connect()",t);if(s)throw new Error(s.message)}),c(this,"isValidApprove",async e=>{if(!M(e))throw new Error(y("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:t,namespaces:s,relayProtocol:i,sessionProperties:r}=e;this.checkRecentlyDeleted(t),await this.isValidProposalId(t);const o=this.client.proposal.get(t),a=Ce(s,"approve()");if(a)throw new Error(a.message);const l=nt(o.requiredNamespaces,s,"approve()");if(l)throw new Error(l.message);if(!U(i,!0)){const{message:d}=y("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(d)}ae(r)||this.validateSessionProps(r,"sessionProperties")}),c(this,"isValidReject",async e=>{if(!M(e)){const{message:i}=y("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(i)}const{id:t,reason:s}=e;if(this.checkRecentlyDeleted(t),await this.isValidProposalId(t),!Yt(s)){const{message:i}=y("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(i)}}),c(this,"isValidSessionSettleRequest",e=>{if(!M(e)){const{message:l}=y("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(l)}const{relay:t,controller:s,namespaces:i,expiry:r}=e;if(!Xt(t)){const{message:l}=y("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const o=Jt(s,"onSessionSettleRequest()");if(o)throw new Error(o.message);const a=Ce(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(W(r)){const{message:l}=y("EXPIRED","onSessionSettleRequest()");throw new Error(l)}}),c(this,"isValidUpdate",async e=>{if(!M(e)){const{message:a}=y("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(a)}const{topic:t,namespaces:s}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const i=this.client.session.get(t),r=Ce(s,"update()");if(r)throw new Error(r.message);const o=nt(i.requiredNamespaces,s,"update()");if(o)throw new Error(o.message)}),c(this,"isValidExtend",async e=>{if(!M(e)){const{message:s}=y("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(s)}const{topic:t}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t)}),c(this,"isValidRequest",async e=>{if(!M(e)){const{message:a}=y("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(a)}const{topic:t,request:s,chainId:i,expiry:r}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const{namespaces:o}=this.client.session.get(t);if(!ot(o,i)){const{message:a}=y("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(a)}if(!Bt(s)){const{message:a}=y("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(a)}if(!Wt(o,i,s.method)){const{message:a}=y("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(a)}if(r&&!Zt(r,Ee)){const{message:a}=y("MISSING_OR_INVALID",`request() expiry: ${r}. Expiry must be a number (in seconds) between ${Ee.min} and ${Ee.max}`);throw new Error(a)}}),c(this,"isValidRespond",async e=>{var t;if(!M(e)){const{message:r}=y("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(r)}const{topic:s,response:i}=e;try{await this.isValidSessionTopic(s)}catch(r){throw(t=e?.response)!=null&&t.id&&this.cleanupAfterResponse(e),r}if(!es(i)){const{message:r}=y("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(i)}`);throw new Error(r)}}),c(this,"isValidPing",async e=>{if(!M(e)){const{message:s}=y("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}),c(this,"isValidEmit",async e=>{if(!M(e)){const{message:o}=y("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(o)}const{topic:t,event:s,chainId:i}=e;await this.isValidSessionTopic(t);const{namespaces:r}=this.client.session.get(t);if(!ot(r,i)){const{message:o}=y("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(o)}if(!ts(s)){const{message:o}=y("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}if(!ss(r,i,s.name)){const{message:o}=y("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}}),c(this,"isValidDisconnect",async e=>{if(!M(e)){const{message:s}=y("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}),c(this,"isValidAuthenticate",e=>{const{chains:t,uri:s,domain:i,nonce:r}=e;if(!Array.isArray(t)||t.length===0)throw new Error("chains is required and must be a non-empty array");if(!U(s,!1))throw new Error("uri is required parameter");if(!U(i,!1))throw new Error("domain is required parameter");if(!U(r,!1))throw new Error("nonce is required parameter");if([...new Set(t.map(a=>be(a).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:o}=be(t[0]);if(o!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),c(this,"getVerifyContext",async e=>{const{attestationId:t,hash:s,encryptedId:i,metadata:r,transportType:o}=e,a={verified:{verifyUrl:r.verifyUrl||Pt,validation:"UNKNOWN",origin:r.url||""}};try{if(o===q.link_mode){const d=this.getAppLinkIfEnabled(r,o);return a.verified.validation=d&&new URL(d).origin===new URL(r.url).origin?"VALID":"INVALID",a}const l=await this.client.core.verify.resolve({attestationId:t,hash:s,encryptedId:i,verifyUrl:r.verifyUrl});l&&(a.verified.origin=l.origin,a.verified.isScam=l.isScam,a.verified.validation=l.origin===new URL(r.url).origin?"VALID":"INVALID")}catch(l){this.client.logger.warn(l)}return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`),a}),c(this,"validateSessionProps",(e,t)=>{Object.values(e).forEach(s=>{if(!U(s,!1)){const{message:i}=y("MISSING_OR_INVALID",`${t} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);throw new Error(i)}})}),c(this,"getPendingAuthRequest",e=>{const t=this.client.auth.requests.get(e);return typeof t=="object"?t:void 0}),c(this,"addToRecentlyDeleted",(e,t)=>{if(this.recentlyDeletedMap.set(e,t),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const i=this.recentlyDeletedLimit/2;for(const r of this.recentlyDeletedMap.keys()){if(s++>=i)break;this.recentlyDeletedMap.delete(r)}}}),c(this,"checkRecentlyDeleted",e=>{const t=this.recentlyDeletedMap.get(e);if(t){const{message:s}=y("MISSING_OR_INVALID",`Record was recently deleted - ${t}: ${e}`);throw new Error(s)}}),c(this,"isLinkModeEnabled",(e,t)=>{var s,i,r,o,a,l,d,u,g;return!e||t!==q.link_mode?!1:((i=(s=this.client.metadata)==null?void 0:s.redirect)==null?void 0:i.linkMode)===!0&&((o=(r=this.client.metadata)==null?void 0:r.redirect)==null?void 0:o.universal)!==void 0&&((l=(a=this.client.metadata)==null?void 0:a.redirect)==null?void 0:l.universal)!==""&&((d=e?.redirect)==null?void 0:d.universal)!==void 0&&((u=e?.redirect)==null?void 0:u.universal)!==""&&((g=e?.redirect)==null?void 0:g.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(e.redirect.universal)&&typeof(global==null?void 0:global.Linking)<"u"}),c(this,"getAppLinkIfEnabled",(e,t)=>{var s;return this.isLinkModeEnabled(e,t)?(s=e?.redirect)==null?void 0:s.universal:void 0}),c(this,"handleLinkModeMessage",({url:e})=>{if(!e||!e.includes("wc_ev")||!e.includes("topic"))return;const t=at(e,"topic")||"",s=decodeURIComponent(at(e,"wc_ev")||""),i=this.client.session.keys.includes(t);i&&this.client.session.update(t,{transportType:q.link_mode}),this.client.core.dispatchEnvelope({topic:t,message:s,sessionExists:i})}),c(this,"registerLinkModeListeners",async()=>{var e;if(is()||rs()&&(e=this.client.metadata.redirect)!=null&&e.linkMode){const t=global==null?void 0:global.Linking;if(typeof t<"u"){t.addEventListener("url",this.handleLinkModeMessage,this.client.name);const s=await t.getInitialURL();s&&setTimeout(()=>{this.handleLinkModeMessage({url:s})},50)}}}),c(this,"shouldSetTVF",(e,t)=>{if(!t||e!=="wc_sessionRequest")return!1;const{request:s}=t;return Object.keys(ke).includes(s.method)}),c(this,"getTVFParams",(e,t,s)=>{var i,r;try{const o=t.request.method,a=this.extractTxHashesFromResult(o,s);return V(I({correlationId:e,rpcMethods:[o],chainId:t.chainId},this.isValidContractData(t.request.params)&&{contractAddresses:[(r=(i=t.request.params)==null?void 0:i[0])==null?void 0:r.to]}),{txHashes:a})}catch(o){this.client.logger.warn("Error getting TVF params",o)}return{}}),c(this,"isValidContractData",e=>{var t;if(!e)return!1;try{const s=e?.data||((t=e?.[0])==null?void 0:t.data);if(!s.startsWith("0x"))return!1;const i=s.slice(2);return/^[0-9a-fA-F]*$/.test(i)?i.length%2===0:!1}catch{}return!1}),c(this,"extractTxHashesFromResult",(e,t)=>{try{const s=ke[e];if(typeof t=="string")return[t];const i=t[s.key];if(ns(i))return i;if(typeof i=="string")return[i]}catch(s){this.client.logger.warn("Error extracting tx hashes from result",s)}return[]})}isInitialized(){if(!this.initialized){const{message:n}=y("NOT_INITIALIZED",this.name);throw new Error(n)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(ze.message,n=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(n):this.onRelayMessage(n)})}async onRelayMessage(n){const{topic:e,message:t,attestation:s,transportType:i}=n,{publicKey:r}=this.client.auth.authKeys.keys.includes(le)?this.client.auth.authKeys.get(le):{responseTopic:void 0,publicKey:void 0},o=await this.client.core.crypto.decode(e,t,{receiverPublicKey:r,encoding:i===q.link_mode?ne:ue});try{ls(o)?(this.client.core.history.set(e,o),this.onRelayEventRequest({topic:e,payload:o,attestation:s,transportType:i,encryptedId:B(t)})):ps(o)?(await this.client.core.history.resolve(o),await this.onRelayEventResponse({topic:e,payload:o,transportType:i}),this.client.core.history.delete(e,o.id)):this.onRelayEventUnknownPayload({topic:e,payload:o,transportType:i})}catch(a){this.client.logger.error(a)}}registerExpirerEvents(){this.client.core.expirer.on(vt.expired,async n=>{const{topic:e,id:t}=Mt(n.target);if(t&&this.client.pendingRequest.keys.includes(t))return await this.deletePendingSessionRequest(t,y("EXPIRED"),!0);if(t&&this.client.auth.requests.keys.includes(t))return await this.deletePendingAuthRequest(t,y("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession({topic:e,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:e})):t&&(await this.deleteProposal(t,!0),this.client.events.emit("proposal_expire",{id:t}))})}registerPairingEvents(){this.client.core.pairing.events.on(Ye.create,n=>this.onPairingCreated(n)),this.client.core.pairing.events.on(Ye.delete,n=>{this.addToRecentlyDeleted(n.topic,"pairing")})}isValidPairingTopic(n){if(!U(n,!1)){const{message:e}=y("MISSING_OR_INVALID",`pairing topic should be a string: ${n}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(n)){const{message:e}=y("NO_MATCHING_KEY",`pairing topic doesn't exist: ${n}`);throw new Error(e)}if(W(this.client.core.pairing.pairings.get(n).expiry)){const{message:e}=y("EXPIRED",`pairing topic: ${n}`);throw new Error(e)}}async isValidSessionTopic(n){if(!U(n,!1)){const{message:e}=y("MISSING_OR_INVALID",`session topic should be a string: ${n}`);throw new Error(e)}if(this.checkRecentlyDeleted(n),!this.client.session.keys.includes(n)){const{message:e}=y("NO_MATCHING_KEY",`session topic doesn't exist: ${n}`);throw new Error(e)}if(W(this.client.session.get(n).expiry)){await this.deleteSession({topic:n});const{message:e}=y("EXPIRED",`session topic: ${n}`);throw new Error(e)}if(!this.client.core.crypto.keychain.has(n)){const{message:e}=y("MISSING_OR_INVALID",`session topic does not exist in keychain: ${n}`);throw await this.deleteSession({topic:n}),new Error(e)}}async isValidSessionOrPairingTopic(n){if(this.checkRecentlyDeleted(n),this.client.session.keys.includes(n))await this.isValidSessionTopic(n);else if(this.client.core.pairing.pairings.keys.includes(n))this.isValidPairingTopic(n);else if(U(n,!1)){const{message:e}=y("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${n}`);throw new Error(e)}else{const{message:e}=y("MISSING_OR_INVALID",`session or pairing topic should be a string: ${n}`);throw new Error(e)}}async isValidProposalId(n){if(!kt(n)){const{message:e}=y("MISSING_OR_INVALID",`proposal id should be a number: ${n}`);throw new Error(e)}if(!this.client.proposal.keys.includes(n)){const{message:e}=y("NO_MATCHING_KEY",`proposal id doesn't exist: ${n}`);throw new Error(e)}if(W(this.client.proposal.get(n).expiryTimestamp)){await this.deleteProposal(n);const{message:e}=y("EXPIRED",`proposal id: ${n}`);throw new Error(e)}}}class qs extends J{constructor(n,e){super(n,e,ct,me),this.core=n,this.logger=e}}class Rt extends J{constructor(n,e){super(n,e,pt,me),this.core=n,this.logger=e}}class Ns extends J{constructor(n,e){super(n,e,dt,me,t=>t.id),this.core=n,this.logger=e}}class Ps extends J{constructor(n,e){super(n,e,wt,ce,()=>le),this.core=n,this.logger=e}}class Os extends J{constructor(n,e){super(n,e,mt,ce),this.core=n,this.logger=e}}class bs extends J{constructor(n,e){super(n,e,_t,ce,t=>t.id),this.core=n,this.logger=e}}var As=Object.defineProperty,Cs=(R,n,e)=>n in R?As(R,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):R[n]=e,Ke=(R,n,e)=>Cs(R,typeof n!="symbol"?n+"":n,e);class xs{constructor(n,e){this.core=n,this.logger=e,Ke(this,"authKeys"),Ke(this,"pairingTopics"),Ke(this,"requests"),this.authKeys=new Ps(this.core,this.logger),this.pairingTopics=new Os(this.core,this.logger),this.requests=new bs(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var Vs=Object.defineProperty,Ds=(R,n,e)=>n in R?Vs(R,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):R[n]=e,_=(R,n,e)=>Ds(R,typeof n!="symbol"?n+"":n,e);class Re extends Dt{constructor(n){super(n),_(this,"protocol",Ve),_(this,"version",De),_(this,"name",_e.name),_(this,"metadata"),_(this,"core"),_(this,"logger"),_(this,"events",new cs),_(this,"engine"),_(this,"session"),_(this,"proposal"),_(this,"pendingRequest"),_(this,"auth"),_(this,"signConfig"),_(this,"on",(t,s)=>this.events.on(t,s)),_(this,"once",(t,s)=>this.events.once(t,s)),_(this,"off",(t,s)=>this.events.off(t,s)),_(this,"removeListener",(t,s)=>this.events.removeListener(t,s)),_(this,"removeAllListeners",t=>this.events.removeAllListeners(t)),_(this,"connect",async t=>{try{return await this.engine.connect(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"pair",async t=>{try{return await this.engine.pair(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"approve",async t=>{try{return await this.engine.approve(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"reject",async t=>{try{return await this.engine.reject(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"update",async t=>{try{return await this.engine.update(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"extend",async t=>{try{return await this.engine.extend(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"request",async t=>{try{return await this.engine.request(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"respond",async t=>{try{return await this.engine.respond(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"ping",async t=>{try{return await this.engine.ping(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"emit",async t=>{try{return await this.engine.emit(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"disconnect",async t=>{try{return await this.engine.disconnect(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"find",t=>{try{return this.engine.find(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(t){throw this.logger.error(t.message),t}}),_(this,"authenticate",async(t,s)=>{try{return await this.engine.authenticate(t,s)}catch(i){throw this.logger.error(i.message),i}}),_(this,"formatAuthMessage",t=>{try{return this.engine.formatAuthMessage(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"approveSessionAuthenticate",async t=>{try{return await this.engine.approveSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}}),_(this,"rejectSessionAuthenticate",async t=>{try{return await this.engine.rejectSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}}),this.name=n?.name||_e.name,this.metadata=n?.metadata||os(),this.signConfig=n?.signConfig;const e=typeof n?.logger<"u"&&typeof n?.logger!="string"?n.logger:bt(At({level:n?.logger||_e.logger}));this.core=n?.core||new Ot(n),this.logger=Ct(e,this.name),this.session=new Rt(this.core,this.logger),this.proposal=new qs(this.core,this.logger),this.pendingRequest=new Ns(this.core,this.logger),this.engine=new Ts(this),this.auth=new xs(this.core,this.logger)}static async init(n){const e=new Re(n);return await e.initialize(),e}get context(){return xt(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),setTimeout(()=>{this.engine.processRelayMessageCache()},Pe(Be))}catch(n){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(n.message),n}}}const Ls=Rt,Ms=Re;export{yt as AUTH_CONTEXT,wt as AUTH_KEYS_CONTEXT,mt as AUTH_PAIRING_TOPIC_CONTEXT,gt as AUTH_PROTOCOL,le as AUTH_PUBLIC_KEY_NAME,_t as AUTH_REQUEST_CONTEXT,ce as AUTH_STORAGE_PREFIX,Es as AUTH_VERSION,ht as ENGINE_CONTEXT,k as ENGINE_QUEUE_STATES,N as ENGINE_RPC_OPTS,ws as HISTORY_CONTEXT,ys as HISTORY_EVENTS,ms as HISTORY_STORAGE_VERSION,ut as METHODS_TO_VERIFY,ct as PROPOSAL_CONTEXT,_s as PROPOSAL_EXPIRY,lt as PROPOSAL_EXPIRY_MESSAGE,dt as REQUEST_CONTEXT,pt as SESSION_CONTEXT,X as SESSION_EXPIRY,Ee as SESSION_REQUEST_EXPIRY_BOUNDARIES,Le as SIGN_CLIENT_CONTEXT,_e as SIGN_CLIENT_DEFAULT,us as SIGN_CLIENT_EVENTS,Ve as SIGN_CLIENT_PROTOCOL,gs as SIGN_CLIENT_STORAGE_OPTIONS,me as SIGN_CLIENT_STORAGE_PREFIX,De as SIGN_CLIENT_VERSION,Ls as SessionStore,Ms as SignClient,ke as TVF_METHODS,Me as WALLETCONNECT_DEEPLINK_CHOICE,Re as default};
//# sourceMappingURL=index.es.js.map
